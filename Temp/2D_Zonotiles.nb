(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 11.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    344957,      10277]
NotebookOptionsPosition[    275790,       8610]
NotebookOutlinePosition[    319315,       9527]
CellTagsIndexPosition[    319272,       9524]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["Zonogonal Tilings", "Title"],

Cell[TextData[{
 "by\n",
 StyleBox["Russell Towle",
  FontWeight->"Bold"],
 "\ncreated in May 2000\nversion 2.3, February 27, 2005\nrtowle@inreachcom"
}], "Subsubtitle"],

Cell[CellGroupData[{

Cell["Preface", "Section",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 StyleBox["In the previous version of February 10, 2005, a new and expanded \
treatment of the classic Penrose tilings has been added, and problems with \
sign-patterns and offsets fixed. This version, of February 27, 2005, adds \
export of dragon designs to POV, and an improved function for taking the \
union of a set of edges.\n",
  FontSlant->"Italic"],
 "\nHere you will find that an ",
 StyleBox["arrangement of lines",
  FontSlant->"Italic"],
 " leads to a ",
 StyleBox["zonogon tiled by smaller zonogons",
  FontSlant->"Italic"],
 ", or ",
 StyleBox["zonotile",
  FontSlant->"Italic"],
 ". A ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function was contrived, which accepts a list of lines as input. Terms will \
be defined in the ",
 StyleBox["Stars, Crosses, and Shadows",
  FontWeight->"Bold"],
 " subsection, below. To display the examples within this ",
 StyleBox["Preface",
  FontWeight->"Bold"],
 ", and throughout the notebook, you must first evaluate the \
\[OpenCurlyDoubleQuote]Initialization\[CloseCurlyDoubleQuote] section. One \
way to do so is to open the ",
 StyleBox["Kernel",
  FontWeight->"Bold"],
 " menu and, from the ",
 StyleBox["Evaluation",
  FontWeight->"Bold"],
 " sub-menu, choose ",
 StyleBox["Evaluate Initialization",
  FontWeight->"Bold"],
 ".\n\nThis notebook has evolved for years yet remains rough and unpolished. \
The guiding light has been experimentation, not cool and rational and \
mathematical exposition. In many ways, usually, an arrangement of lines may \
be resolved into subsets, which play varying roles in the derived tiling. \
Hence by all rights I should have designed functions for breaking sets into \
subsets, modifying and recombining them with transparent ease and dexterity. \
But I did not. Instead global variables are rampant, often with inscrutable \
names such as ",
 StyleBox["zaq",
  FontWeight->"Bold"],
 " and ",
 StyleBox["xaq",
  FontWeight->"Bold"],
 ", sometimes with evocative names like ",
 StyleBox["lns",
  FontWeight->"Bold"],
 ". Whenever I say to myself, \[OpenCurlyDoubleQuote]today I will clean up \
that code, make it right,\[CloseCurlyDoubleQuote] instead I find myself \
experimenting with tilings.\n\nI hope you too will experiment.\n\n",
 StyleBox["Russell Towle, Dutch Flat, California, January, 2005.",
  FontSlant->"Italic"]
}], "Text"],

Cell[CellGroupData[{

Cell["A Personal Note", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "I confess at once, I am no mathematician. Nevertheless I have enjoyed a \
long struggle to understand ",
 StyleBox["zonohedra",
  FontSlant->"Italic"],
 ", a struggle which commenced around 1970. From the beginning, \
space-fillings and tilings by zonohedra and zonogons beckoned strongly. The \
famous Penrose tilings of the plane, using 36- and 72-degree rhombs, \
especially pleased me.\n\nLiving for many years without electricity, in a \
hexagonal mountain cabin, I developed a facility for drawing certain \
hidden-detail-removed projections of the polar zonohedra, in which regular \
polygons, of an even number of sides, are tiled by rhombs. Idle \
experimentation led to various schemes by which the same suite of rhombs \
within the projection, might be attached to the outside, building up larger \
and larger concentric 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons. See ",
 StyleBox["Expansions of Polar Zonohedra",
  FontWeight->"Bold"],
 " in the ",
 StyleBox["Periodic and Quasi-Periodic Tilings",
  FontWeight->"Bold"],
 " section, below.\n\nSimultaneously, a grappling with Professor H.S.M. \
Coxeter\[CloseCurlyQuote]s famous ",
 StyleBox["Regular Polytopes",
  FontSlant->"Italic"],
 " (Dover, 1973) revealed my beloved zonohedra to sometimes form ",
 StyleBox["orthogonal shadows of hypercubes",
  FontSlant->"Italic"],
 ", and my \[OpenCurlyDoubleQuote]expansions\[CloseCurlyDoubleQuote] to be \
related to close-packed arrays of hypercubes.\n\nYears passed, and in the \
late 1980s, I gained access to a primitive computer, and wrote programs in \
BASIC which made these \[OpenCurlyDoubleQuote]expansions\
\[CloseCurlyDoubleQuote] of the polar zonohedra, using complicated nested \
loops.\n\nIn the middle 1990s I obtained ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", and just so soon as possible, began trying to make Penrose tilings. I \
failed. Via the Internet, the outlines of the problem took shape. There were \
matching methods, substitution methods, a \[OpenCurlyDoubleQuote]generalized \
dual\[CloseCurlyDoubleQuote] or \[OpenCurlyDoubleQuote]multigrid\
\[CloseCurlyDoubleQuote] method, and a \[OpenCurlyDoubleQuote]generalized \
projection\[CloseCurlyDoubleQuote] method. The name of Nicolaas de Bruijn was \
often in view (see, among others, his ",
 StyleBox["Algebraic Theory of Penrose\[CloseCurlyQuote]s non-periodic \
tilings of the plane",
  FontSlant->"Italic"],
 ", Kon. Nederl. Akad. Wetensh., Proc. Ser. A 84, 1981).\n\nI obtained some \
code implementing the generalized dual method, in the C programming language, \
and tried and failed to port it to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". So many hours, for nought. My greater interest was in the projection \
method, but no avenues opened to build upon someone else\[CloseCurlyQuote]s \
work. Starting from scratch led nowhere.\n\nFinally, in 1999 I believe, I \
downloaded some PostScript code from the Internet. The file was named \
\[OpenCurlyDoubleQuote]multigrid.ps\[CloseCurlyDoubleQuote] and, sad to say, \
I can\[CloseCurlyQuote]t recall who wrote the thing. Wishing to credit the \
man, I searched again and again without ever finding the site from which it \
came. I think he was at a university in Europe. Thank you, sir.\n\nBy a \
rather fiendish process I ported the PostScript to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", and managed some small improvements along the way; my code returns a list \
of polygons, while the original gave only line segments.\n\nHere, then, we \
have a version of the generalized dual, or multigrid, method. I can\
\[CloseCurlyQuote]t say I fully understand ",
 StyleBox["why",
  FontSlant->"Italic"],
 " it works, even to this day. In point of fact it does not always work, and \
the failures remain mostly a puzzle to me. ",
 StyleBox["How",
  FontSlant->"Italic"],
 " it does what it does will be considered below. Quite a wide variety of \
zonogons tiled by smaller zonogons will be met. For a time I called these \
things ",
 StyleBox["zonotiles",
  FontSlant->"Italic"],
 ", or ",
 StyleBox["2D zonotiles",
  FontSlant->"Italic"],
 ". Perhaps it is better to call them ",
 StyleBox["plane zonotopal tilings",
  FontSlant->"Italic"],
 ". Or not: ",
 StyleBox["zonotile",
  FontSlant->"Italic"],
 " is one single word."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Stars, Crosses, and Shadows", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "A convex polygon with central symmetry is called a ",
 StyleBox["zonogon",
  FontSlant->"Italic"],
 ", and a convex polyhedron bounded entirely by zonogons is called a ",
 StyleBox["zonohedron",
  FontSlant->"Italic"],
 ". The generalization to space of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " dimensions is a ",
 StyleBox["zonotope",
  FontSlant->"Italic"],
 ". An ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-zonotope is bounded by (",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1)-dimensional zonotopes, in turn bounded by (n-2)-dimensional zonotopes, \
and so on. Only rarely are zonotopes ",
 StyleBox["regular",
  FontSlant->"Italic"],
 ", nor must they be equilateral. Almost all the tilings presented here are \
equilateral, and one loses little by this restriction, for every zonotope is \
isomorphic to an equilateral zonotope. A parallelogram is isomorphic to a \
rhomb, a parallelepiped to a rhombic hexahedron. Note that a square is a ",
 StyleBox["regular",
  FontSlant->"Italic"],
 " rhomb, a cube, a ",
 StyleBox["regular",
  FontSlant->"Italic"],
 " rhombic hexahedron. Hypercubes, or ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cubes, are especially simple and regular zonotopes.\n\nParallelism is an \
important attribute of zonotopes. Every edge, every zonogon, every \
zonohedron, has an equal and opposite counter-edge, counter-zonogon, \
counter-zonohedron, etc., similarly situated, and parallel. Take the \
tesseract, or 4-cube. It is bounded by eight 3-cubes, which occur in four \
parallel pairs. Every cube has an equal and opposite counter-cube.\n\nAt this \
point the reader might well wonder why an appeal is made to higher space, \
when the subject, after all, is plane tilings.\n\nThe answer is that \
zonotopes generally, and zonogons in particular, can be orthogonal shadows of \
hypercubes, cast into lower dimensions. The \[OpenCurlyDoubleQuote]shadow\
\[CloseCurlyDoubleQuote] of a convex polytope is the convex hull of its \
projection, with its interior. For instance, the regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons, such as the square, regular hexagon, regular octagon, etc., are all \
zonogons, and all orthogonal plane shadows of ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cubes. The square we must count as the shadow of itself. The hexagon is an \
orthogonal shadow of a 3-cube, cast onto a plane perpendicular to any one of \
the cube\[CloseCurlyQuote]s long diagonals.\n\nNow, hypercubes tile the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space; it is natural to imagine that ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-dimensional shadows of ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cubes might somehow tile the ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-space. Here, ",
 StyleBox["s",
  FontSlant->"Italic"],
 "=2, and our ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-zonotopes are zonogons, of an infinite variety, regular, irregular, always \
of 2",
 StyleBox["k",
  FontSlant->"Italic"],
 " sides, where ",
 StyleBox["k",
  FontSlant->"Italic"],
 " is the number of independent vectors which determine some one tile. For \
now it is enough to remark upon the connection between zonogonal tilings and \
hypercubes.",
 "\n\nWe also look beyond Flatland because the \
\[OpenCurlyDoubleQuote]generalized dual\[CloseCurlyDoubleQuote] or \
\[OpenCurlyDoubleQuote]multigrid\[CloseCurlyDoubleQuote] method itself \
generalizes to higher space. From an arrangement of lines in the plane, and \
an arrangement of planes in three dimensions, the method generalizes to an \
arrangement of hyperplanes, of (",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1)-spaces in an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space. One goes from tilings of zonogons, to tilings of zonohedra, to \
tilings of 4-polytopes bounded by zonohedra, and so on.\n\nIt is more than a \
curiosity that any regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon can be dissected into the \[OpenCurlyDoubleQuote]triangular\
\[CloseCurlyDoubleQuote] number, ",
 StyleBox["n",
  FontSlant->"Italic"],
 " things taken two at a time, of rhombs (of the same edge length as the 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon); that is, the square dissects into itself, the hexagon, into three \
rhombs, the octagon, into six rhombs, the decagon, into ten, the dodecagon, \
fifteen. Most usually, these dissections can occur in a large number of \
different ways, but in any case, the rhombs arise as orthogonal projections \
of squares bounding the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube.\n\nSuppose we have ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines in general position, in the plane. \[OpenCurlyDoubleQuote]General \
position\[CloseCurlyDoubleQuote] means that no two lines are parallel, nor do \
any two coincide. Every line, then, intersects every other line. What is the \
number of intersection points? The triangular number of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " things taken two at a time. Evaluate the cell below to see a sequence of \
triangular numbers."
}], "Text"],

Cell["\<\
Table[
Binomial[ n, 2],
{n,2,10}]\
\>", "Input"],

Cell[TextData[{
 "Now let\[CloseCurlyQuote]s look at some cyclically tiled 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons. Be sure to have evaluated the ",
 StyleBox["Initialization",
  FontWeight->"Bold"],
 " section, first."
}], "Text"],

Cell["\<\
(*Display a series of rhombically tiled regular 2n-gons*)
arr=Partition[ Table[tiling[i],{i,2,7}], 3];
Show[GraphicsArray[arr]];\
\>", "Input"],

Cell[TextData[{
 "Parenthetically, and broadly speaking, every zonohedron can be dissected \
into the \[OpenCurlyDoubleQuote]tetrahedral\[CloseCurlyDoubleQuote] number, \
",
 StyleBox["n",
  FontSlant->"Italic"],
 " things taken three at a time, of parallelepipeds. Quite a number of words \
would be needed to properly qualify this assertion. When a zonohedron is the \
orthogonal projection of a hypercube, the parallelepipeds arise as \
projections of 3-cubes bounding the hypercube.\n\nReturning to the hexagonal \
shadow of a cube, cast onto a plane: suppose rather we make a ",
 StyleBox["wireframe",
  FontSlant->"Italic"],
 " projection, onto the same plane: we obtain the same hexagon, but it is \
filled with rhombs in two different ways. They appear to interpenetrate, \
appear to divide the hexagon into six equilateral triangles. Of course, in \
the cube, they do not interpenetrate. Wireframe projections can be confusing.\
\n\nNow make the very same projection, but with hidden detail removed, as \
though the square faces of the cube were opaque. We obtain a hexagon neatly \
tiled by three equal rhombs.\n\nOne of the more abstruse questions bearing \
upon the tilings of zonogons by smaller zonogons, is whether a given tiling \
can or cannot arise as a hidden-detail-removed projection of a hypercube. I \
cannot speak to that. It is enough for now to remark that the tilings of \
zonogons by smaller zonogons are related to hidden-detail-removed projections \
of hypercubes and close-packed arrays of hypercubes.\n\nA zonogon, \
zonohedron, or zonotope is said to be ",
 StyleBox["determined by",
  FontSlant->"Italic"],
 " a set of vectors which span the space. In an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space, a set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " non-zero vectors is said to \[OpenCurlyDoubleQuote]span\
\[CloseCurlyDoubleQuote] the space if they do not all lie in an (",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1)-space. In the plane, this means that any two vectors which do not lie \
in the same line, span the 2-space. Before abandoning higher space and \
retreating to the safety of the plane, please consider the following \
construction of an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube, and its various shadows.\n\nIn space of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " dimensions, we can have ",
 StyleBox["n",
  FontSlant->"Italic"],
 " mutually perpendicular vectors. Let all ",
 StyleBox["n",
  FontSlant->"Italic"],
 " of these be unit vectors, and add to these another ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors, their opposites. We might obtain these 2",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors from a Cartesian frame of coordinate axes, taking unit vectors in \
both directions, along each of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " axes. This cluster of perpendicular unit vectors is called a ",
 StyleBox["cross",
  FontSlant->"Italic"],
 ".\n\nThe orthogonal projection of a cross into a lower space is call a ",
 StyleBox["eutactic star",
  FontSlant->"Italic"],
 ". \[OpenCurlyDoubleQuote]Eutactic\[CloseCurlyDoubleQuote] means \
\[OpenCurlyDoubleQuote]well-ordered.\[CloseCurlyDoubleQuote] See Chapter 13 \
of H.S.M. Coxeter\[OpenCurlyQuote]s ",
 StyleBox["Regular Polytopes",
  FontSlant->"Italic"],
 ", (Dover, 1973).",
 "\n\nSelect from the cross ",
 StyleBox["n",
  FontSlant->"Italic"],
 " perpendicular vectors, that is, from each pair formed by a vector and its \
opposite, choose one. Using these, we \[OpenCurlyDoubleQuote]trace out\
\[CloseCurlyDoubleQuote] the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube by a series of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " translations along these chosen vectors, as follows.\n\nA point, moved \
along the first vector, traces out a segment or 1-cube. The segment, moved \
along the second vector, traces out a square or 2-cube. The square, moved \
along the third vector, traces out a cube, or 3-cube; the cube traces out a \
tesseract, or 4-cube; and so on.\n\nNote that every ",
 StyleBox["k",
  FontSlant->"Italic"],
 "-dimensional cube traces out a (",
 StyleBox["k",
  FontSlant->"Italic"],
 "+1)-cube. When we move the incipient hypercube along a new vector, every \
existing vertex makes a new line segment, every segment, a new square, and so \
on.\n\nVery well. Now consider the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross\[CloseCurlyQuote]s orthogonal projection into some lower space, say, \
an ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-space. The vectors of the cross project into the vectors of the eutactic \
star, and are variously foreshortened. It is possible, for instance, that \
they are ",
 StyleBox["equally",
  FontSlant->"Italic"],
 " foreshortened; this is an \[OpenCurlyDoubleQuote]isometric\
\[CloseCurlyDoubleQuote] projection. Let this be the case, so that we will \
not be troubled by vectors which have foreshortened into points. So, while \
the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube is being traced out in the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space, consider what happens in the ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-space. A point traces out a segment, the segment, a rhomb, the rhomb, a \
projection of a 3-cube, that projection of a 3-cube traces out a projection \
of a 4-cube, and so on.\n\nConsider the case where ",
 StyleBox["s",
  FontSlant->"Italic"],
 "=2, a plane, and now trace out orthogonal shadows instead of full-fledged \
projections: then the point traces out a segment, the segment, a rhomb, the \
rhomb, a hexagon, the hexagon, an octagon, the octagon, a decagon, and so on.\
\n\nThat is, a series of zonogons arises, each in turn the shadow of a \
square, 3-cube, 4-cube, 5-cube, and so on until at last, using the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th vector, an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th translation ",
 "traces out a regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon. Regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons are orthogonal, isometric shadows of ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cubes.",
 "\n\nIt was noted above that the regular octagon is a plane shadow of a \
4-cube. Projecting orthogonally and also isometrically, as before, in the \
4-space the four perpendicular vectors trace out a segment, square, cube, and \
finally a tesseract or 4-cube. In the plane, the projections of those four \
vectors trace out a segment, rhomb (possibly a square), irregular hexagon, \
and finally, a regular octagon.\n\nThe essential idea here is that zonotopes \
and hypercubes alike are \[OpenCurlyDoubleQuote]traced out\
\[CloseCurlyDoubleQuote] by a set of vectors.\n\nNot all zonotopes are \
shadows of hypercubes. Not all sets of vectors are eutactic stars. Any set of \
vectors at all, spanning an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space, can be used to trace out an ",
 StyleBox["n-",
  FontSlant->"Italic"],
 "zonotope. In the plane, any two vectors not in the same line trace out a \
parallelogram, any three (no two in the same line) trace out a hexagon, any \
four (no two in the same line) trace out an octagon, any such five vectors, a \
decagon, any six, a dodecagon. If the vectors are of equal magnitude, these \
\[OpenCurlyDoubleQuote]2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons of translation\[CloseCurlyDoubleQuote] are equilateral. If the \
vectors are as symmetrically disposed as may be, these \
\[OpenCurlyDoubleQuote]2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons of translation\[CloseCurlyDoubleQuote] are regular.\n\nIt is quite a \
startling development, in Chapter 13 of ",
 StyleBox["Regular Polytopes",
  FontSlant->"Italic"],
 ", to find that the vectors from the center to the vertices of each and \
every regular polytope form isometric eutactic stars. Hence every regular \
polygon gives an isometric eutactic star. For instance, the five vectors from \
the center to the vertices of the regular pentagon, with their opposites, \
give an isometric eutactic star, the isometric projection into a plane of a \
5-dimensional cross.\n\nIn almost every example of zonogons tiled by smaller \
zonogons in this notebook, we will use such symmetrically disposed vectors. \
We will use the vectors of isometric eutactic stars. We need not do so, but \
symmetry is appealing. We shall both exhibit and disguise these symmetries, \
enhance and disrupt them."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Generalized Dual Method", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "I admit that, for my part, the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function seems a mysterious machine. Exercising all due caution, one tips \
a barrel of lines into the hopper: there follows a whirring, a whistling, a \
clanking, a grinding of gears, and eventually, with a bit of luck, out pops a \
zonotile. I shall do my best to unveil the machine\[CloseCurlyQuote]s \
mysteries."
}], "Text"],

Cell[CellGroupData[{

Cell["Duality", "Subsubsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
From an arrangement of lines, we obtain the tiling of a zonogon tiled by \
smaller zonogons. For simplicity, let us call such a tiling a \
\[OpenCurlyDoubleQuote]zonotile,\[CloseCurlyDoubleQuote] and admit the \
degenerate case when there is but one \[OpenCurlyDoubleQuote]tile,\
\[CloseCurlyDoubleQuote] a single zonogon.

Briefly, every point of intersection between lines corresponds to a tile, and \
every open region between lines corresponds to a vertex in the zonotile. \
Every individual segment cut out between lines, or infinite ray leading away \
from a point of intersection, corresponds to an edge in the zonotile.

That is, given an arrangement of lines, not all parallel, we distinguish \
0-dimensional elements (points of intersection), 1-dimensional elements \
(segments or rays), and 2-dimensional elements (bounded or partially-bounded \
regions of the plane). To the 0-, 1-, and 2-dimensional elements of the line \
arrangement, correspond 2-, 1-, and 0-dimensional elements in the zonotile.

Hence the name, \[OpenCurlyDoubleQuote]generalized dual.\
\[CloseCurlyDoubleQuote] It is not quite the duality we are accustomed to, \
when we say that the dual of the Platonic Octahedron is the cube, or that the \
dual of a regular polygon is simply another similar regular polygon. It is a \
generalized duality.

Please consider the example below, in which an arrangement of five lines is \
shown on the left, and its corresponding zonotile on the right. Note that \
there are ten points of intersection in the line arrangement, and ten rhombs \
in the zonotile. Especially note that the right-hand-most point of \
intersection in the line arrangement corresponds to the right-hand-most rhomb \
in the zonotile. This \[OpenCurlyDoubleQuote]topological\
\[CloseCurlyDoubleQuote] correspondence is not always easy to see. In this \
simple example you should be able to identify each point of intersection \
between the lines of the arrangement, with a particular rhomb in the zonotile.

There are twenty-five segments and rays in the line arrangement, and \
twenty-five edges in the zonotile. There are sixteen open regions in the line \
arrangement, of which ten are infinite in extent, and sixteen vertices in the \
zonotile.\
\>", "Text"],

Cell["zpolar[5]", "Input"],

Cell[TextData[{
 "Try substituting other integers in the ",
 StyleBox["zpolar",
  FontWeight->"Bold"],
 " function, such as 3, 4, 6, 7, etc. A randomized coloring has been applied \
to the rhombs in the zonotiles; the rhombs are first divided into subsets \
according to surface area, then slightly varied shades or red or blue or \
green are applied.\n\nPlease note that the number of edges which meet at any \
one vertex in the zonotile, equal the number of segments or rays surrounding \
the corresponding open region in the line arrangement. By the same token, if \
some ",
 StyleBox["k",
  FontSlant->"Italic"],
 " lines intersect at any one point in the arrangement, a 2",
 StyleBox["k",
  FontSlant->"Italic"],
 "-gon arises in the zonotile.\n\nFor example, if the five lines in the \
arrangement above intersected at one single point\[LongDash]the origin, \
perhaps\[LongDash]then the resulting zonotile would be one undivided regular \
decagon.\n\nSo much for the duality. Now for the method itself."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Method in Outline", "Subsubsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
There are four steps in making a plane zonotile:

1. Select a set of non-zero vectors, no two in the same line.
2. Construct an arrangement of lines perpendicular to the chosen vectors.
3. Form a list of \[OpenCurlyDoubleQuote]sign vectors\[CloseCurlyDoubleQuote] \
from the line arrangement.
4. Use the sign vectors as an encoding to construct the zonotile.\
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Vectors and Lines", "Subsubsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "In space of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " dimensions, given a non-zero vector, we can construct an infinite number \
of parallel \[OpenCurlyDoubleQuote]hyperplanes\[CloseCurlyDoubleQuote] or (",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1)-spaces, perpendicular to that vector. In the plane this reduces to the \
fact that, given a non-zero vector, we can construct an infinite number of \
parallel lines, perpendicular to the given vector. Here we appeal to the \
\[OpenCurlyDoubleQuote]canonical\[CloseCurlyDoubleQuote]\[NonBreakingSpace]\
equation for a line,\n\n",
 StyleBox["ax + by - c ",
  FontSlant->"Italic"],
 "= 0.\n\nWe almost always insist that {",
 StyleBox["a,b",
  FontSlant->"Italic"],
 "} is a ",
 StyleBox["unit",
  FontSlant->"Italic"],
 " vector, so that ",
 StyleBox["c",
  FontSlant->"Italic"],
 " is the distance of the line perpendicular to that unit vector, measured \
from the origin in the direction of {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}. We represent any line, then, as {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "}. If ",
 StyleBox["c",
  FontSlant->"Italic"],
 " is negative, the line lies on the opposite side of the origin from {",
 StyleBox["a,b",
  FontSlant->"Italic"],
 "}; if ",
 StyleBox["c",
  FontSlant->"Italic"],
 " is zero, the line passes through the origin.\n\nHence an arrangement of \
lines is passed to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function as a list, any one line having the form {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "}.\n\n",
 StyleBox["The various zonogons which compose the zonotile itself are \
determined by subsets of the unit vectors {",
  FontWeight->"Bold"],
 StyleBox["a, b",
  FontWeight->"Bold",
  FontSlant->"Italic"],
 StyleBox["}.\n",
  FontWeight->"Bold"],
 "\nIn Nicolaas deBruijn\[CloseCurlyQuote]s \[OpenCurlyDoubleQuote]multigrid\
\[CloseCurlyDoubleQuote] method, it is imagined that for any unit vector {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "} an infinite series of parallel lines arises, spaced one unit apart. This \
he calls a \[OpenCurlyDoubleQuote]grid.\[CloseCurlyDoubleQuote] Each grid is \
then offset by some small real number, to ensure that no more than two lines \
intersect at any one point.\n\nHere we use only a finite number of parallel \
lines, and they are not necessarily equally-spaced. Suppose, however, they \
are. Then for a unit vector {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "} we might represent a set of five parallel lines perpendicular to {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "} as\n\n{{",
 StyleBox["a, b, -2",
  FontSlant->"Italic"],
 "}, {",
 StyleBox["a, b, -1",
  FontSlant->"Italic"],
 "}, {",
 StyleBox["a, b, 0",
  FontSlant->"Italic"],
 "}, {",
 StyleBox["a, b, 1",
  FontSlant->"Italic"],
 "}, {",
 StyleBox["a, b, 2",
  FontSlant->"Italic"],
 "}}.\n\nThat is, there is a set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " directions, expressed by the unit vectors, and for any one direction, \
lines lie at one or more distances. We are not constrained to have the same \
number of distances, nor even the same distances, for each direction. If the \
number of distances, hence the number of perpendicular lines, varies from \
vector to vector among the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors, the bounding zonogon of the zonotile is not equilateral.\n\nMy \
own aim differs also from that of deBruijn, in that I actively seek \
arrangements in which more than two lines intersect at one or more points.\n\n\
In practice, when designing and constructing zonotiles, the distances are \
everything. Often I create the distances as a separate list, and join them to \
the chosen unit vectors in a ",
 StyleBox["Table",
  FontWeight->"Bold"],
 ". Below, an example. There are five unit vectors, and two distances, 0 and \
1. The list of lines, each in the form {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "}, is named \[OpenCurlyDoubleQuote]lns\[CloseCurlyDoubleQuote] and is \
passed to the ",
 StyleBox["drawLines",
  FontWeight->"Bold"],
 " function, which forms the lines themselves, within a specified radius. \
Then \[OpenCurlyDoubleQuote]lns\[CloseCurlyDoubleQuote] is passed to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, and the zonotile is created and displayed.\n\nPlease note that \
since one of the two distances is zero, five lines pass through one point, \
and a decagon arises within the zonotile."
}], "Text"],

Cell["\<\
n=5;(*five directions*)
dist={0,1};(*two distances*)

(*create the triples {x, y, distance}*)
lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1]
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display line arrangement within suitable radius*)
radius=5;
Show[drawLines[lns, radius],
Frame->True];

(*create zonotile*)
zaq=zonotile[lns];
(*display edges of zonotile*)
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[{
 "I have made much of eutactic stars, and symmetrical vectors. The unit \
vectors used above are just such; but the observant eye might detect that \
rather than being multiples of 2\[Pi]/",
 StyleBox["n",
  FontSlant->"Italic"],
 ", they are multiples of \[Pi]/",
 StyleBox["n",
  FontSlant->"Italic"],
 ". In this there is a certain subtlety.\n\nSuch symmetrically disposed \
vectors are not at all required by the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, but I almost always employ them, and the following discussion \
actually ",
 StyleBox["assumes",
  FontSlant->"Italic"],
 " that symmetrical vectors are needed. So have a care.\n\nIn the first \
place, for reasons I do not understand, it seems that all the vectors {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "} must lie in a half-plane. We can never admit a vector and its opposite \
into the list; and by the same token, if we pass the five vectors from the \
center to the vertices of a regular pentagon to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " algorithm, it will fail. An improper zonotile will arise, with \
intersecting tiles.\n\nA graphical representation of the situation will help. \
Let us confront the seemingly simple challenge of making the line arrangement \
obtained by producing the sides of a regular pentagon.\n\nFirst, we will \
construct the ",
 StyleBox["wrong",
  FontSlant->"Italic"],
 " kind of unit vectors {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}, leading from the center to the vertices of a regular pentagon, and then \
their line arrangement, setting distances at 1; we pause to examine the forms \
these improper vectors and lines take, and then ",
 StyleBox["Show",
  FontWeight->"Bold"],
 " them together. And finally, we construct the improper zonotile."
}], "Text"],

Cell["\<\
n=5;(*set how many sides to the regular polygon*)

(*make unit vectors, prepared for use as Line graphics*)
unitvecs=Table[
Line[ Chop[N[{{0,0},{Cos[2*i*Pi/n], Sin[2*i*Pi/n]}}]] ], {i,n}];
Print[\"The unit vectors, as Graphics Line objects, are as follows: \\n\", \
ColumnForm[unitvecs]]

(*make the perpendicular lines in the form {a,b,c}*)
lns=Table[
Chop[N[{Cos[2*i*Pi/n], Sin[2*i*Pi/n], 1}]], {i,n}];
Print[\"The perpendicular lines, in the form {a,b,c}, are as follows: \\n\", \
ColumnForm[lns]]\
\>", "Input"],

Cell["\<\
(*construct and display the unit vectors, colored red*)
g1=Show[ Graphics[ {AbsoluteThickness[2],RGBColor[1,0,0],unitvecs}],
PlotLabel->\"The Unit Vectors\",
Frame->True,
AspectRatio->Automatic];

(*display line arrangement within suitable radius*)
radius=5;
g2=Show[drawLines[lns, radius],
PlotLabel->\"The Perpendicular Lines\",
Frame->True];

(*combine the unit vectors and lines*)
Show[{g1,g2},
PlotLabel->\"The Unit Vectors and the Lines\",
Frame->True,
AspectRatio->Automatic];

(*create zonotile*)
zaq=zonotile[lns];
(*display edges of zonotile*)
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[{
 "Very well. Passing the line arrangement created above to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, an improper zonotile arose, with intersecting tiles. Everything \
would be ever so much simpler if we could use the unit vectors derived from \
the vertices of a regular polygon. We cannot.\n\nInstead, we must confine our \
vectors to a half-plane, and then jump through yet other hoops to form a \
proper line arrangement.\n\nOnce again a graphical representation will help. \
We being by constructing five unit vectors and five perpendicular lines, but \
now we use multiples of \[Pi]",
 StyleBox["/n",
  FontSlant->"Italic"],
 ", not 2\[Pi]",
 StyleBox["/n",
  FontSlant->"Italic"],
 ", and to obtain the sides of a regular pentagon, produced, we make the \
distances ",
 StyleBox["c",
  FontSlant->"Italic"],
 " of the lines {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "} alternately 1 and -1. And then finally, we construct the proper \
zonotile."
}], "Text"],

Cell["\<\
(*proper vectors and proper lines*)
n=5;(*set how many sides to the regular polygon*)

(*make unit vectors, prepared for use as Line graphics*)
unitvecs=Table[
Line[ Chop[N[{{0,0},{Cos[i*Pi/n], Sin[i*Pi/n]}}]] ], {i,n}];
Print[\"The unit vectors, as Graphics Line objects, are as follows: \\n\", \
ColumnForm[unitvecs]]

(*make the perpendicular lines in the form {a,b,c}*)
lns=Table[
Chop[N[{Cos[i*Pi/n], Sin[i*Pi/n], If[EvenQ[i],1,-1]}]], {i,n}];
Print[\"The perpendicular lines, in the form {a,b,c}, are as follows: \\n\", \
ColumnForm[lns]]\
\>", "Input"],

Cell["\<\
(*construct and display the unit vectors, colored red*)
g1=Show[ Graphics[ {AbsoluteThickness[2],RGBColor[1,0,0],unitvecs}],
PlotLabel->\"The Unit Vectors\",
Frame->True,
AspectRatio->Automatic];

(*display line arrangement within suitable radius*)
radius=5;
g2=Show[drawLines[lns, radius],
PlotLabel->\"The Perpendicular Lines\",
Frame->True];

(*combine the unit vectors and lines*)
Show[{g1,g2},
PlotLabel->\"The Unit Vectors and the Lines\",
Frame->True,
AspectRatio->Automatic];

(*create zonotile*)
zaq=zonotile[lns];
(*display edges of zonotile*)
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[{
 "So far, so good. However, if you return to the cell above, beginning \
(*proper vectors and proper lines*), and set ",
 StyleBox["n",
  FontSlant->"Italic"],
 " even, say, to 4 or 6 or 8, note that we do not obtain the \
\[OpenCurlyDoubleQuote]sides, produced\[CloseCurlyDoubleQuote] of regular 4-, \
6-, or 8-gons at all. To explain the changes necessary would only confuse \
matters.\n\nHere it was quite enough to illustrate confinement of unit \
vectors to a half-plane, and offer an example of how distances can be \
manipulated, to obtain a symmetrical arrangement.\n\nHowsoever, I cannot \
leave the subject of confinement quite so unfinished. In the ",
 StyleBox["Stars, Crosses, and Shadows",
  FontWeight->"Bold"],
 " subsection, hypercubes were constructed by translations along ",
 StyleBox["n",
  FontSlant->"Italic"],
 " perpendicular vectors. The complete ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-dimensional ",
 StyleBox["cross",
  FontSlant->"Italic"],
 " contains these same vectors, and their opposites; it is useful to imagine \
the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross as arising from unit vectors taken in both directions along \
Cartesian axes in the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-space. For instance, a 2-cross would consist of the positive vectors {1, \
0} and {0,1}, along with their opposites, {-1, 0} and {0, -1}. To trace out a \
square we select two of these four. We might select the two positive-valued \
vectors, or the two negative-valued vectors, or, for instance, one positive \
and one negative. So long as the selected vectors are perpendicular, the two \
translations trace out a square.\n\nWhen we project the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross of 2",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors orthogonally and isometrically into a lower ",
 StyleBox["s",
  FontSlant->"Italic"],
 "-space, say, a plane, or 2-space, we obtain a eutactic star of 2",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors. The positive-valued vectors of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross project into ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors of the star, and the negative-valued vectors of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross project into ",
 StyleBox["n",
  FontSlant->"Italic"],
 " other vectors of the star, the opposites of the first ",
 StyleBox["n",
  FontSlant->"Italic"],
 ".\n\nJust as we are free to choose any ",
 StyleBox["n",
  FontSlant->"Italic"],
 " of the 2",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cross, to trace out an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube, so long as no two lie in the same line, so also we are free to \
choose any ",
 StyleBox["n",
  FontSlant->"Italic"],
 " of the 2",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors of the (isometric) eutactic star, to trace out the orthogonal \
shadow of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-cube, so long as no two lie in the same line. We will obtain the very same \
shadow, no matter which ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors of the star are chosen. Hence we can select those ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors, in a plane isometric eutactic star, which are confined to a \
half-plane. The situation when ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5 is depicted below. Note that several ways exist to separate the ten \
vectors (five red, and five dashed blue), by a line. The division will always \
give two red and three blue to one side, and three red and two blue on the \
other; but translations along any such subset of five vectors will trace out \
a regular decagon, an isometric, orthogonal shadow of a 5-cube, cast into a \
plane.\n\nAnd five lines perpendicular to any one of these half-plane \
subsets, intersecting at a single point, lead to a regular decagon in the \
zonotile."
}], "Text"],

Cell["\<\
(*make unit vectors, prepared for use as Line graphics*)
unitvecs=Table[
Line[ Chop[N[{{0,0},{Cos[2*i*Pi/n], Sin[2*i*Pi/n]}}]] ], {i,n}];
(*make the opposites of the above*)
opps=Table[
Line[ Chop[N[{{0,0},-1*{Cos[2*i*Pi/n], Sin[2*i*Pi/n]}}]] ], {i,n}];


(*construct and display the unit vectors, colored red*)
Show[ Graphics[ {AbsoluteThickness[2],RGBColor[1,0,0],unitvecs,
AbsoluteDashing[{5,5}],RGBColor[0,0,1],opps}],
PlotLabel->\"The Unit Vectors and Their Opposites\",
Frame->True,
AspectRatio->Automatic];
\
\>", "Input"],

Cell["\<\
Below, we form five lines in a half-plane (three blues and two reds, as it \
happens), intersecting at the origin, and then create the zonotile, a single \
regular decagon.\
\>", "Text"],

Cell["\<\
(*make the perpendicular lines in the form {a,b,0}*)
lns=Table[
Chop[N[{Cos[i*Pi/n], Sin[i*Pi/n], 0}]], {i,n}];
Print[\"The perpendicular lines, in the form {a,b,0}, are as follows: \\n\", \
ColumnForm[lns]]

(*display line arrangement within suitable radius*)
radius=5;
g2=Show[drawLines[lns, radius],
PlotLabel->\"The Perpendicular Lines\",
Frame->True];

(*create zonotile*)
zaq=zonotile[lns];
(*display edges of zonotile*)
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Sign Vectors", "Subsubsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "We recreate the same example as above: our line arrangement is simply the \
sides, produced, of a regular pentagon. Note that the distances are \
alternately -1 and 1. This is because the \[OpenCurlyDoubleQuote]unit vectors \
within the half-plane\[CloseCurlyDoubleQuote] are multiples of ",
 StyleBox["i",
  FontSlant->"Italic"],
 "\[Pi] / 5 for ",
 StyleBox["i",
  FontSlant->"Italic"],
 "={1, 2, 3, 4, 5}. The 5th vector is {-1, 0} and the 5th line is set at \
distance -1, that is, although the unit vector points to negative ",
 StyleBox["x",
  FontSlant->"Italic"],
 ", the line itself is in positive ",
 StyleBox["x",
  FontSlant->"Italic"],
 ", and parallel to the ",
 StyleBox["y",
  FontSlant->"Italic"],
 " axis. This is the \[OpenCurlyDoubleQuote]vertical\[CloseCurlyDoubleQuote] \
line in the arrangement."
}], "Text"],

Cell["\<\
n=5;(*a pentagon, its sides produced*)
(*make the perpendicular lines in the form {a,b,c}*)
lns=Table[
Chop[N[{Cos[i*Pi/n], Sin[i*Pi/n], If[EvenQ[i],1,-1]}]], {i,n}];
Print[\"The perpendicular lines, in the form {a,b,c}, are as follows: \\n\", \
ColumnForm[lns]]

(*display line arrangement within suitable radius*)
radius=5;
g2=Show[drawLines[lns, radius],
PlotLabel->\"The Perpendicular Lines\",
Frame->True];\
\>", "Input"],

Cell[TextData[{
 "Now we create the notorious \[OpenCurlyDoubleQuote]sign vectors,\
\[CloseCurlyDoubleQuote] their components either -1, 0, or 1. Each sign \
vector ",
 StyleBox["should",
  FontSlant->"Italic"],
 " correspond to one particular zonogon in the zonotile. Suppose there are ",
 StyleBox["n",
  FontSlant->"Italic"],
 " unit vectors, and for every vector, perpendicular lines are at ",
 StyleBox["j",
  FontSlant->"Italic"],
 " distances, ",
 StyleBox["j",
  FontSlant->"Italic"],
 ">=1. Then there are ",
 StyleBox["n*j",
  FontSlant->"Italic"],
 " lines altogether, and each sign vector will be of length ",
 StyleBox["n*j",
  FontSlant->"Italic"],
 " as well. Each component is the sign of the determinant of a 3-by-3 matrix \
made of the {",
 StyleBox["a",
  FontSlant->"Italic"],
 ", ",
 StyleBox["b",
  FontSlant->"Italic"],
 ", ",
 StyleBox["c",
  FontSlant->"Italic"],
 "}s. I find this part of the code most suspicious; for one thing, it allows \
construction of degenerate zonogonal tiles, such as rhombs with zero area. \
For another thing, too many sign vectors arise, even after stripping away \
duplicates using ",
 StyleBox["Union",
  FontWeight->"Bold"],
 ". I have made many unsuccessful attempts to streamline and refine this part \
of the code.\n\nHere, we use our existing set of five lines, each \
perpendicular to a unit vector {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}. In this simple example, no degenerate tiles arise, and no duplicates are \
removed; each sign vector corresponds to a particular, legitimate tile."
}], "Text"],

Cell["\<\
r=Length[lns];(*the total number of lines, and length of each sign vector*)
rawsgn=Table[
  Table[
    Table[
      Sign[Chop[Det[ {lns[[i]],lns[[j]],lns[[k]]} ] ] ],
    {i,r}],
  {j,k+1,r}],
{k,r-1}];

(*get rid of duplicate tiles*)
sgn=Union[Flatten[rawsgn,1]];
Print[\"The sign vectors are as follows: \\n\", ColumnForm[sgn]]\
\>", "Input"],

Cell[TextData[{
 "The sign vectors encode construction of the zonotile, as will be seen \
below. In essence, every zonogon in the zonotile is determined by some ",
 StyleBox["k",
  FontSlant->"Italic"],
 " vectors of the ",
 StyleBox["n*j",
  FontSlant->"Italic"],
 " {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s; and we reach the \[OpenCurlyDoubleQuote]point of beginning\
\[CloseCurlyDoubleQuote] where a zonogon is created by adding (and \
subtracting) together the ",
 StyleBox["n*j",
  FontSlant->"Italic"],
 " {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s. Note that in this line arrangement, each line intersects every other, \
and no more than two lines intersect at any one point. The numbers and \
positions of zeros in the sign vector show how many lines intersect, and \
which lines these are.\n\nHere each sign vector contains two zeros; from this \
we deduce that no more than two lines intersect at any one point.\n\nIf all \
five lines intersected at one point, there would be but one unique sign \
vector, {0, 0, 0, 0, 0}.\n\nAfter (unnecessarily, in this case) taking the ",
 StyleBox["Union",
  FontWeight->"Bold"],
 " of these sign vectors, the first of the (reordered) ten becomes \
{-1,-1,0,0,1}. We find zeros at the 3rd and 4th positions. Since there are \
two zeros, the corresponding tile is a rhomb, in particular, the rhomb \
determined by the 3rd and 4th of the unit vectors {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}.\n\nThe other components of the sign vector {-1,-1,0,0,1} include two -1s \
and one 1. The number and position of the 1s show which of the {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s must be ",
 StyleBox["added",
  FontSlant->"Italic"],
 " to reach the \[OpenCurlyDoubleQuote]point of beginning\
\[CloseCurlyDoubleQuote] for construction of the zonogon, while all the rest \
of the vectors are",
 StyleBox[" subtracted",
  FontSlant->"Italic"],
 ".\n\nHowever, the indexing of the {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s does not depend on their original creation, which occurred more likely \
than not within a ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " in which the iterator runs from ",
 StyleBox["i",
  FontSlant->"Italic"],
 " to ",
 StyleBox["n",
  FontSlant->"Italic"],
 "; instead, given the complete list of lines {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "} perpendicular to the {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s, of length, say, 25, the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function merely takes the {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s from the {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "}s in the order of the line list itself.\n\n",
 StyleBox["The length of each and every sign vector equals the length of the \
line arrangement.\n\nThe ordering of the components of each and every sign \
vector equals the ordering of the line arrangement.",
  FontWeight->"Bold",
  FontSlant->"Italic"],
 StyleBox["\n",
  FontWeight->"Bold"],
 "\nPerhaps things will become more clear by examining the next step in \
zonotile construction. We have made the list of ten sign vectors, now we \
shall construct the zonotile itself."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Constructing the Zonotile", "Subsubsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "The process begins by stripping {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}s from the lines, which are a list of {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "}s of length ",
 StyleBox["r",
  FontWeight->"Bold"],
 "."
}], "Text"],

Cell["vecs=Map[#[[{1,2}]]&, lns](*we use the vectors {a, b}*)", "Input"],

Cell[TextData[{
 "Next, the \[OpenCurlyDoubleQuote]raw\[CloseCurlyDoubleQuote] zonotile is \
made in a ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " and named, of all things, ",
 StyleBox["zaq",
  FontWeight->"Bold"],
 ". It is \[OpenCurlyDoubleQuote]raw\[CloseCurlyDoubleQuote] because it may \
contain degenerate zonogons of zero area. The ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " runs through the list of sign vectors ",
 StyleBox["sgn",
  FontWeight->"Bold"],
 ".\n\nTwo \[OpenCurlyDoubleQuote]incrementing\[CloseCurlyDoubleQuote] \
functions are used within the ",
 StyleBox["Table",
  FontWeight->"Bold"],
 ": ",
 StyleBox["rmoveto[ point, vector]",
  FontWeight->"Bold"],
 " takes a global variable, \[OpenCurlyDoubleQuote]point,\
\[CloseCurlyDoubleQuote] and adds the vector \[OpenCurlyDoubleQuote]vector\
\[CloseCurlyDoubleQuote] to increment \[OpenCurlyDoubleQuote]point.\
\[CloseCurlyDoubleQuote] Similarly, ",
 StyleBox["rlineto[ point, vector]",
  FontWeight->"Bold"],
 " increments \[OpenCurlyDoubleQuote]point,\[CloseCurlyDoubleQuote] while \
creating one edge of a zonogon, the edge connecting \
\[OpenCurlyDoubleQuote]point\[CloseCurlyDoubleQuote] to \
\[OpenCurlyDoubleQuote]point + vector.\[CloseCurlyDoubleQuote]\n\nEach \
iteration of the ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " resets the global variable \[OpenCurlyDoubleQuote]point\
\[CloseCurlyDoubleQuote] (below, named ",
 StyleBox["pt",
  FontWeight->"Bold"],
 ") to the origin, {0,0}.\n\nThen a ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop runs through the ",
 StyleBox["r",
  FontWeight->"Bold"],
 " components of the ",
 StyleBox["k",
  FontWeight->"Bold"],
 "th sign vector. Let us see what happens to the global ",
 StyleBox["pt",
  FontWeight->"Bold"],
 " with one iteration of this ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop. We will use ",
 StyleBox["sgn[[ 1 ]]",
  FontWeight->"Bold"],
 ", the first sign vector. Note that within the ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " is an ",
 StyleBox["If",
  FontWeight->"Bold"],
 " block. If the sign of the ",
 StyleBox["i",
  FontSlant->"Italic"],
 "th component is positive, we ",
 StyleBox["add",
  FontSlant->"Italic"],
 " the corresponding {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}; otherwise, we ",
 StyleBox["subtract",
  FontSlant->"Italic"],
 " the corresponding {",
 StyleBox["a, b",
  FontSlant->"Italic"],
 "}."
}], "Text"],

Cell["sgn[[1]](*the sign vector we use for example*)", "Input"],

Cell["\<\
pt={0,0};(*before incrementing*)

(*first, move to proper spot to begin a zonogon*)
   Do[If[ sgn[[1,i]]==1,
     rmoveto[ pt, vecs[[i]] ],(*add the ith vector*)
     rmoveto[ pt, -vecs[[i]] ] ],(*subtract the ith vector*)
   {i,r}]

pt(*after incrementing*)\
\>", "Input"],

Cell[TextData[{
 "We have incremented ",
 StyleBox["pt",
  FontWeight->"Bold"],
 ". Now that we have the \[OpenCurlyDoubleQuote]point of beginning,\
\[CloseCurlyDoubleQuote] we construct a single zonogonal tile, in a terribly \
awkward piece of programming. We name the \[OpenCurlyDoubleQuote]raw\
\[CloseCurlyDoubleQuote] zonogon ",
 StyleBox["rawgon",
  FontWeight->"Bold"],
 ", and use one ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " to create the first ",
 StyleBox["k",
  FontSlant->"Italic"],
 " sides, and a second ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " for the second ",
 StyleBox["k",
  FontSlant->"Italic"],
 " sides; these are joined using ",
 StyleBox["Join",
  FontWeight->"Bold"],
 ". Again an ",
 StyleBox["If",
  FontWeight->"Bold"],
 " block is used, to add an edge to the zonogon only ",
 StyleBox["if",
  FontSlant->"Italic"],
 " the ",
 StyleBox["i",
  FontSlant->"Italic"],
 "th ",
 "sign is zero. There is no \[OpenCurlyDoubleQuote]else\
\[CloseCurlyDoubleQuote] in the ",
 StyleBox["If",
  FontWeight->"Bold"],
 ", so to weed out the empty results, ",
 StyleBox["Cases",
  FontWeight->"Bold"],
 " wraps each ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " to limit output to the form {{",
 StyleBox["x1, y1",
  FontSlant->"Italic"],
 "}, ..., {",
 StyleBox["xk, yk",
  FontSlant->"Italic"],
 "}}. That is, again, if the sign vector contains ",
 StyleBox["k",
  FontSlant->"Italic"],
 " zeros, the zonogon has 2",
 StyleBox["k",
  FontSlant->"Italic"],
 " sides.\n\nIt is a mystery to me that the vectors are multiplied by two."
}], "Text"],

Cell["\<\
(*next, go up one side of the zonogon, down the other*)
   rawgon=Join[
   Cases[
    Table[
\t If[ sgn[[1,i]]==0, rlineto[ pt, 2*vecs[[i]] ] ],
    {i,r}],
   {{_,_}..}],(*end first Cases*)
   Cases[
    Table[
     If[ sgn[[1,i]]==0, rlineto[ pt, 2*-vecs[[i]] ] ],
    {i,r}],
   {{_,_}..}](*end second Cases*)
   ](*end Join*)
   
   zgon=toPoly[rawgon]\
\>", "Input"],

Cell[TextData[{
 "Finally, the vertices of the zonogonal tile are extracted from the list of \
edges, using a minor function, ",
 StyleBox["toPoly",
  FontWeight->"Bold"],
 ". This is the final output for each iteration of the outermost ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " which loops through the sign vectors to construct the zonotile. Hence the \
output of the ",
 StyleBox["Table",
  FontWeight->"Bold"],
 ", and of the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, is a list of polygons, each polygon a list of vertices."
}], "Text"],

Cell["\<\
Show[Graphics[ Line/@ rawgon ],(*the edges of the tile*)
AspectRatio->Automatic,
Frame->True];

Show[Graphics[ Polygon[zgon] ],(*the tile as a Polygon*)
AspectRatio->Automatic,
Frame->True];\
\>", "Input"],

Cell[TextData[{
 "There were a variety of judgement calls made during the writing and \
refinement of the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function. It is based upon PostScript code which returned a list of line \
segments, many segments duplicated several times over. So it seemed good to \
trim the output. Also, I have often found it useful, when modeling polyhedra, \
to sort the polygonal faces into sets of equal surface area, and assign a \
color to each area-set. These plane zonotiles seemed well-suited for such \
treatment. Hence I chose to create raw zonogons as the final output, not yet \
wrapped in the ",
 StyleBox["Graphics",
  FontWeight->"Bold"],
 " primitive ",
 StyleBox["Polygon",
  FontWeight->"Bold"],
 ". Leaving the polygons unwrapped not only slims down the data structure, \
but facilitates sorting by surface area, and the recreation of their bounding \
line segments, should that be desired.\n\nThe ",
 StyleBox["colorsort",
  FontWeight->"Bold"],
 " function was set up to discard the degenerate tiles of zero surface area. \
This could have been done within the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, but so far I have not done so. I have never been satisfied with \
the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function, and have always been sure that much optimization is possible."
}], "Text"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Initialization", "Section",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
Off[General::spell]
Off[General::spell1]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell[CellGroupData[{

Cell["Zonotile code", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
mag[v_]:=Sqrt[v.v](*magnitude of vector 'v'*)
unit[v_]:=v/mag[v](*unit vector in direction of 'v'*)
cent[v_List]:=Plus@@v/Length[v](*centroid of point list*)
tosegs[gon_]:=Transpose[ {gon, RotateLeft[gon]} ](*polygon to edges*)\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["toPoly[e_]:=Drop[Join[First@e,Map[#[[2]]&, Rest@e]],-1]", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "(*Carl Woll's vector union*)\ntol=.000001;\nvunion1[v_]:= Union[v, \
SameTest->(Max[Abs[#1 - #2]] < tol &)] ",
 StyleBox["\nvunion[v_]:= Module[{r},\nr = Split[Sort[Chop[v,.000001]], \
(Abs[#1[[1]] - #2[[1]]] < ", "Text",
  FontSize->12],
 "tol",
 StyleBox[" &)];\nFlatten[vunion1 /@ r, 1]] ", "Text",
  FontSize->12]
}], "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
linestostar[lns_]:=
Block[{posvecs, negvecs, possegs, negsegs},
posvecs=vunion[ Map[#[[{1,2}]]&, lns] ];
negvecs=-1*posvecs;
possegs=Map[Line[{{0,0}, #}]&, posvecs];
negsegs=Map[Line[{{0,0}, #}]&, negvecs];
Graphics[ {AbsoluteThickness[2],RGBColor[1,0,0],possegs,
AbsoluteDashing[{6,6}],RGBColor[0,0,1],negsegs},
Frame->True,
AspectRatio->Automatic]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*tests two rhombs to see if they share a common edge*)
(*if so, the union of their eight vertices is six vertices*)
edgeTest[r1_,r2_]:=
Block[{t=Join[r1,r2]},
Length[t]-Length[vunion[t]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["parse[poly_] := Cases[poly,Polygon[x_]:>x,Infinity]", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
colorSort[poly_]:=(*~30* faster than old version*)
Block[{q1,q2,q3},
q1=Table[{poly[[i]], hullarea[ poly[[i]] ] },{i,Length[poly]}];
q2=Select[q1,Last[#]>.00001&];(*changed from !=0&*)
q3=Split[Sort[q2,#1[[2]]<#2[[2]]&],
TrueQ[(Abs[#1[[2]]-#2[[2]]]<.0001)]&];
Print[\"You will need at least \",Length[q3],
\" colors in the colorlist below.\"];(*how many colors?*)
Table[Cases[q3[[i]],{{_,_}..},Infinity],{i,Length[q3]}]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 AspectRatioFixed->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
notextcolorSort[poly_]:=(*~30* faster than old version*)
Block[{q1,q2,q3},
q1=Table[{poly[[i]], hullarea[ poly[[i]] ] },{i,Length[poly]}];
q2=Select[q1,Last[#]>.00001&];(*changed from !=0&*)
q3=Split[Sort[q2,#1[[2]]<#2[[2]]&],
TrueQ[(Abs[#1[[2]]-#2[[2]]]<.0001)]&];
Table[Cases[q3[[i]],{{_,_}..},Infinity],{i,Length[q3]}]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 AspectRatioFixed->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
hullarea[poly_]:=
Block[{a,c,t},
c=cent[poly];
t=Map[-c+#&, poly ];
(*divide into triangles*)
a=toTriangles[t];
(*sum one-half the areas of the determined parallelograms*)
Chop[N[Plus @@ Flatten[Map[(Abs[Minors[#, 2]]/2)&, a]]]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*find indices of faces into list of vertices*)
facedex[vertlist_, hedron_] := 
  Table[Flatten[
  (Position[vertlist, x_ /; Chop[x-#, .001]=={0,0},{1}] & ) /@ hedron[[i]]], 
   {i, Length[hedron]}]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
rmoveto[pt1_,pt2_]:= (pt=pt1+pt2)
rlineto[pt1_,pt2_]:= {pt1,(pt=pt1+pt2)}\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
drawLines[lns_, rad_]:=
Block[{ortho},
ortho=Table[ Line[Join[
(*(vector * distance) +/- radius * orthogonal vector*)
{lns[[k,{1,2}]]*lns[[k,3]]-rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]},
{lns[[k,{1,2}]]*lns[[k,3]]+rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]}
] ],
{k,Length[lns]}];
Graphics[ortho,AspectRatio->Automatic]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
zonotile[lns_]:=
Block[{a,b,lns2,pt,r,t,gon,temp},
r=Length[lns];
a=Table[
  Table[
    Table[
      Sign[Chop[Det[ {lns[[i]],lns[[j]],lns[[k]]} ] ] ],
    {i,r}],
  {j,k+1,r}],
{k,r-1}];

(*gets rid of duplicate tiles*)
b=Union[Flatten[a,1]];

lns2=Map[#[[{1,2}]]&, lns];

(*polygons, with degenerates removed*)

Cases[
Table[
pt={0,0};

   Do[If[ b[[k,i]]==1,
     rmoveto[ pt, lns2[[i]]/2 ],
     rmoveto[ pt, -lns2[[i]]/2 ] ],
   {i,r}];

   t=Join[
   Cases[
    Table[
\t If[ b[[k,i]]==0, rlineto[ pt, lns2[[i]] ] ],
    {i,r}],
   {{_,_}..}],
   Cases[
    Table[
     If[ b[[k,i]]==0, rlineto[ pt, -lns2[[i]] ] ],
    {i,r}],
   {{_,_}..}]
   ];

gon=toPoly[t]; 
If[ Chop[ hullarea[ gon ] ]>0, gon],
{k,Length[b]}],
{{_,_}..}]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*fixed list of 56 colors*)
defaultcolorlist=Join[
{
RGBColor[0,0,1],
RGBColor[1,1,0],
RGBColor[1,0,0],
RGBColor[0,.5,0],
RGBColor[0,0,.5],
RGBColor[.5,0,0]},
Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{50}]
];\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*takes a list of five -1s and 1s and converts it to full-plane equivalent*)
halftoFull[sgn_]:=sgn[[{2,4,1,3,5}]]*{1,1,-1,-1,-1}

(*takes a list of five -1s and 1s and converts it to half-plane equivalent*)
fulltoHalf[sgn_]:=sgn[[{3,1,4,2,5}]]*{-1,1,-1,1,-1}\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "pentagrid[max_, s_, d_]:=\nBlock[{n, sgn, val, offset, dist},\nn=5;\n\
(*convert sign patterns to half-plane equivalents*)\nsgn=fulltoHalf[ If[ \
Length[s]!=5, Table[s,{n}], s] ];\nval=If[ Length[d]!=5, Table[d,{n}], d];\n\
offset=sgn*val;\ndist=Table[ ",
 StyleBox["offset[[i]]",
  FontColor->RGBColor[1, 0, 0]],
 " + Range[-max, max, 1],{i,n}];\nlns = Flatten[Table[Chop[N[{Cos[i*(Pi/n)], \
Sin[i*(Pi/n)], dist[[i,j]]}]],\n{i, n}, {j, Length[dist[[i]]]}], 1];\n\
Share[zaq = zonotile[lns]]; \nsrt = notextcolorSort[zaq];\n\
col=defaultcolorlist;\nxaq=Graphics[\n\tTable[ {col[[i]],Polygon /@ srt[[ i \
]],\n\tGrayLevel[0],Map[Line /@ tosegs[#]&, srt[[i]] ]}, {i,Length[srt]}],\n\t\
PlotLabel->StringJoin[\"Offset = \", ToString[ Chop[N[s*val]] ] ],\n\t\
AspectRatio->Automatic\n\t];\nShow[xaq,\nBackground->GrayLevel[0],\n\
AspectRatio->Automatic];\n]"
}], "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
showtile[n_Integer,distances_List]:=
Block[{lns,zaq,a1,a2},
lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], distances[[j]] }
]],
{i,n}, {j, Length[distances]}],1];

Share[zaq=zonotile[lns]];

With[{colorlist={
RGBColor[1,1,0],
RGBColor[0,0,1],
RGBColor[1,.3,.3],
RGBColor[0,1,0],
RGBColor[.5,.5,1]}
},
s=notextcolorSort[ zaq ];

xaq=Graphics[
\tTable[ {colorlist[[ 1+Mod[i,5] ]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];
](*end With*)
](*end Block*)\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
zpolar[n1_]:=
Block[{n,dist,lns,sgn,z,vaq,xaq,a1,a2},
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-1,1},{1}];
lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

vaq=drawLines[lns, 10];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[GraphicsArray[{vaq,xaq}],
Background->GrayLevel[1],
AspectRatio->Automatic];
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
zpolarexpand[n1_]:=
Block[{n,dist,lns,sgn,z,vaq,xaq,a1,a2},
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-5,-.5,.5,5},{.5,5}];
lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

vaq=drawLines[lns, 10];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[GraphicsArray[{vaq,xaq}],
Background->GrayLevel[1],
AspectRatio->Automatic];
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*Create the vectors which determine a 2n-gon*)
star[n_Integer]:=
Table[
\tN[{Cos[Pi/(2*n) + Pi + Pi*i/n],
\tSin[Pi/(2*n) + Pi + Pi*i/n]}],
\t{i,0,n-1}]
\t
(*A function which makes the edges bounding a rhomb*)
quad[x_,ref_]:={ref, ref+x[[1]], ref+x[[1]]+x[[2]], mark=ref+x[[2]], ref}

(*A function which creates a 2n-gon filled with rhombs*)
tiling[n_Integer]:=
Module[{v,q},
v=star[n];
q=Table[mark={0,0};
\tTable[quad[{v[[j]],v[[1+Mod[i+j-1,n]]]},mark],{i,n-j}],{j,n-1}];
Graphics[{AbsoluteThickness[2],Line /@ Flatten[q ,1]},
\tAspectRatio->Automatic,
\tPlotLabel->StringForm[\"n=``, rhombs=``\",n,Binomial[n,2] ]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 ImageRegion->{{0, 1}, {0, 1}},
 Background->GrayLevel[0.833326]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Grout & 3D code", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*split polygon into triangles*)
totrigons[vlist_List] :=
    Module[{bary = (Plus @@ vlist)/Length[vlist], circ},
        circ = Partition[ Append[vlist, First[vlist]], 2, 1 ];
        Apply[ {#1, #2, bary}&, circ, {1} ]
    ]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*shrink polygon by its edges by \"dist\"*)
grout[poly_, dist_]:=
Block[{c,t,s,a,ta,tb,th,rat,st},
c=cent[poly];(*find center*)
t=Map[-c+#&, poly ];(*translate to origin*)
a=totrigons[t];(*split into triangles*)
ta=Flatten[ First /@ Chop[N[Map[(Abs[Minors[#, 2]])&, a]]] ];(*areas*2*)
tb=Map[ mag[ #[[2]]-#[[1]] ]&, a];(*edge lengths*)
th=MapThread[ #1/#2&, {ta,tb}];(*heights from edge as base*)
rat=Map[(#-dist)/#&, th];(*subtract dist and form ratio*)
st=MapThread[#1*#2&, {rat,t}];(*scale vertices*)
Map[c+#&, st](*translate back to original center*)
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*Wouter Meussen's convex hull code*)
myOrdering[z_List]:=(Sort[Transpose[{z,Range[Length[z]]}]]//Transpose) [[2]]

ang2[{v1_List,v2_List},v2_]:=1.
ang2[{v1_List,v2_List},v1_]:=-1.
ang2[{v1_List,v2_List},v3_List]:= \
(v2-v1).(v3-v2)/mag[v2-v1]/(mag[v3-v2]+.0000001)

ang[{v1_List,v2_List},v2_|v1_]:=1.
ang[{v1_List,v2_List},v3_List]:=(v2-v1).(v3-v2)/mag[v2-v1]/(mag[v3-v2]+.\
0000001)

convexhull2D[pts_]:=
Block[{cen,dis,idx,xfar,far,xsec,hull},
cen=cent[pts];
dis=mag[#-cen]& /@ pts;
idx=myOrdering[dis];
xfar=Last[idx];
far=pts[[xfar]];
xsec=Sort[{10+  ang2[{cen,far},pts[[#]] ]-10.,
\tmag[(far-pts[[#]])] ,#} &/@idx][[-2,-1]];
hull={xfar,xsec};

FixedPoint[Last[AppendTo[hull, 
Sort[ {10+ang[  pts[[Take[hull,-2] ]],
pts[[#]] ]-10.,
mag[(pts[[ Last[hull] ]] -pts[[#]])] ,#} &/@idx] [[-3,-1]] ] ]&,0,
SameTest->(First[hull]==#2 &)];
pts[[ Drop[hull,-1] ]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 ImageRegion->{{0, 1}, {0, 1}},
 Background->GrayLevel[0.833326]],

Cell["\<\
(*shrink polygon by its edges by \"dist\" and lift by \"height\"*)
loft[poly_, dist_, height_]:=
Block[{c,t,s,a,ta,tb,th,rat,st,small,high,base,lats},
c=cent[poly];(*find center*)
t=Map[-c+#&, poly ];(*translate to origin*)
a=totrigons[t];(*split into triangles*)
ta=Flatten[ First /@ Chop[N[Map[(Abs[Minors[#, 2]])&, a]]] ];(*areas*2*)
tb=Map[ mag[ #[[2]]-#[[1]] ]&, a];(*edge lengths*)
th=MapThread[ #1/#2&, {ta,tb}];(*heights from edge as base*)
rat=Map[(#-dist)/#&, th];(*subtract dist and form ratio*)
st=MapThread[#1*#2&, {rat,t}];(*scale vertices*)
small=Map[c+#&, st];(*translate back to original center*)
high=Map[ Join[#,{height}]&, small];(*lift up*)
base=Map[ Join[#,{0}]&, poly];(*z=0 in 3D*)
lats=MapThread[ Join[#1,Reverse[#2]]&, {tosegs[base],tosegs[high]}];(*lateral \
faces of frustrum*)
Polygon /@ Join[{high},lats](*the laterals and the top face*)
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "(*rhombic tilings only!*)\n(*accepts as inputs lns, the lines of an \
arrangement*)\n(*k1, the gridrange number*)\n(*ind, the indices into Range[5] \
of negative signs*) \n(*and z, the magnitude of the z coordinate*)\n(*creates \
globals poly3D and xaq3D*)\n\nloft3D[lns_, k1_, ind_, z_]:=\n\
Block[{rng,s1,s2,lns2,sgn,a,b,pt,t1,t2,zaq3D},\nrng=2*k1+1;(*how many lines \
per grid*)\ns1=ind[[1]];s2=ind[[2]];(*indices of two negatives in the sign \
pattern*)\n(*and all that to restore the original sign pattern in the z \
coordinates of the roof*)\nlns2=Table[sgn=If[ ",
 StyleBox["(i>(s1-1)*rng && i<s1*rng+1) || (i>(s2-1)*rng && i<s2*rng+1)",
  FontColor->RGBColor[1, 0, 0]],
 ", -1, 1];\nJoin[lns[[i,{1,2}]], sgn*{",
 StyleBox["z",
  FontColor->RGBColor[1, 0, 0]],
 "}], {i,Length[lns]}];\n\n\nShare[\n\n(*make list of sign vectors*)\n\
a=Table[\n  Table[\n    Table[\n      Sign[Chop[Det[ \
{lns[[i]],lns[[k]],lns[[j]]} ] ] ],\n    {i,Length[lns]}],\n  \
{j,k+1,Length[lns]}],\n{k,Length[lns]-1}];\n\nb=Union[Flatten[a,1]];\n\n\n\
(*find polygons, some degenerate*)\nzaq3D=Table[\npt={0,0,0};\nDo[ If[ \
b[[k,j]]==1,\n     rmoveto[pt, -lns2[[j]]/2 ],\n     rmoveto[pt, lns2[[j]]/2 \
]\n    ],\n{j,Length[lns]}];\n\nt1=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     \
rlineto[ pt, -lns2[[j]] ]\n   ],\n   {j,Length[lns]}],{{_,_,_}..}];\n   \n\
t2=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     rlineto[ pt, lns2[[j]] ]\n   ],\n\
   {j,Length[lns]}],{{_,_,_}..}];\n \ntoPoly[Join[t1,t2]],\n{k,1,Length[b]}]\n\
];(*end Share*)\n\n(*discard degenerate polygons*)\n\
poly3D=Select[Cases[zaq3D,{{_,_,_},{_,_,_},{_,_,_}..},Infinity],\n\
Length[#]==4&];\nPrint[\"There are \",Length[poly3D],\" rhombs in the \
roof\"];\n\n\nGraphics3D[{EdgeForm[],Polygon /@ poly3D}]\n](*end loft3D*)\n\n\
\nmycross[ {ax_, ay_, az_}, {bx_, by_, bz_} ] :=\n\t{ay bz - az by, az bx - \
ax bz, ax by - ay bx}(*cross product*)\n\n(*area of parallelogram*)\n\
sz[f_List] := mag[mycross[ f[[2]] - f[[1]], f[[3]] - f[[2]] ]]\n\n(* treat \
4gons specially for efficiency *)\ntotalarea[v_List] /; Length[v] == 4 :=\n\t\
sz[v]\n\n(* treat triangles specially for efficiency *)\ntotalarea[v_List] /; \
Length[v] == 3 :=\n\tsz[v]/2\n\t\n(* general case: use polygon center as \
additional vertex *)\ntotalarea[v_List] :=\n    Module[{bary = cent[v], circ, \
t},\n        circ = tosegs[v];\n        t=Apply[ {#1, #2, bary}&, circ, {1} \
];\n        Sum[sz[t[[i]]]/2,{i,Length[t]}]\n    ]\n    \n(*get Headless \
polygons from Graphics3D object or List*)\nparse[x_]:= Cases[ x, {{_,_,_}..}, \
Infinity]\n\n(*sort polygons by area*)\ncolorSort3D[poly_]:=(*~30* faster \
than old version*)\nBlock[{q1,q2,p},\np=parse[poly];\n\
q1=Table[{p[[i]],totalarea[ p[[i]] ] },{i,Length[p]}];\n\
q2=Split[Sort[q1,#1[[2]]<#2[[2]]&],\nTrueQ[(Abs[#1[[2]]-#2[[2]]]<.0001)]&];\n\
Print[\"You will need at least \",Length[q2],\n\" colors in the colorlist \
below.\"];(*how many colors?*)\n\
Table[Cases[q2[[i]],{{_,_,_}..},Infinity],{i,Length[q2]}]\n]\n\n\n(*from \
Graphics:Shapes: translate a polyhedron, etc.*)\ntrans[shape_, vec_List] :=\n\
Block[{t = N[vec]},\n shape /. {\n  poly:Polygon[_] :> Map[(t + #)&, poly, \
{2}],\n  ln:Line[_]    :> Map[(t + #)&, ln, {2}],\n  pt:Point[_]  :> Map[(t + \
#)&, pt,{1}] }\n    ]"
}], "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Bitten and Stellation Code", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*given ordered vertices of a polygon, returns edges*)
toedges[poly_]:=Partition[Join[poly,{First@poly}],2,1]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*from Graphics:Shapes: translate a polyhedron, etc.*)
trans[shape_, vec_List] :=
Block[{t = N[vec]},
 shape /. {
  poly:Polygon[_] :> Map[(t + #)&, poly, {2}],
  ln:Line[_]    :> Map[(t + #)&, ln, {2}],
  pt:Point[_]  :> Map[(t + #)&, pt,{1}] }
    ]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*makes an array of ij points, translations for close-packing*)
make2Darray[{inum_,jnum_},trans_]:=
Block[{ir,jr,f1,f2},
ir=(inum-1)/2;
jr=(jnum-1)/2;
Flatten[Table[
f1=i*trans[[1]];
f2=j*trans[[2]]+f1;
f2,
{i,-ir,ir,1},
{j,-jr,jr,1}
],1]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
hemi[n_Integer]:=
\tBlock[{i,j},Flatten[Table[{i,j},{i,n-1},{j,i+1,n}],1]]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*adds index numbers to lines*)
newdrawLines[lns_, rad_]:=
Block[{ortho,p1,p2},
ortho=Table[ {Line[Join[
(*(vector * distance) +/- radius * orthogonal vector*)
p1={lns[[k,{1,2}]]*lns[[k,3]]-rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]},
p2={lns[[k,{1,2}]]*lns[[k,3]]+rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]}
] ],
Text[ToString[k], p1[[1]] ],
Text[ToString[k], p2[[1]] ]},
{k,Length[lns]}];
Graphics[ortho,AspectRatio->Automatic]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*index numbers in disks, colors to lines*)
mynewdrawLines[lns_, color_, rad_]:=
Block[{ortho,p1,p2},
ortho=Table[ {color,Line[Join[
(*(vector * distance) +/- radius * orthogonal vector*)
p1={lns[[k,{1,2}]]*lns[[k,3]]-rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]},
p2={lns[[k,{1,2}]]*lns[[k,3]]+rad*First@NullSpace[ N[{lns[[k,{1,2}]]}] ]}
] ],
GrayLevel[1], Disk[p1[[1]], .5],GrayLevel[0],Circle[p1[[1]], \
.5],Text[ToString[k], p1[[1]] ],
GrayLevel[1], Disk[p2[[1]], .5],GrayLevel[0],Circle[p2[[1]], \
.5],Text[ToString[k], p2[[1]] ]},
{k,Length[lns]}];
Graphics[ortho,AspectRatio->Automatic]
]\
\>", "Input",
 PageWidth->Infinity,
 CellFrame->True,
 InitializationCell->True,
 ShowSpecialCharacters->False,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*this works with vectors {a,b} which are not unit vectors*)
newinter2lines[{{a1_,b1_,c1_},{a2_,b2_,c2_}}]:=
Block[{denom,a,b,c,d,e,f},
(*convert inputs to {{a,b,c},{d,e,f}}*)
{a,b}=unit[{a1,b1}];
{d,e}=unit[{a2,b2}];
c=c1*mag[{a1,b1}];
f=c2*mag[{a2,b2}];

denom=Chop[ a*e - b*d ];
If[denom==0,Null,
Chop[{ ((c*e - f*b)/denom), ((a*f - d*c)/denom) }]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*find all intersections, and find radius within which to draw lines*)
findpoints[lnlist_]:=
Block[{dex},
dex=hemi[ Length[ lnlist ] ];
vunion[
DeleteCases[
Table[
newinter2lines[ lnlist[[ dex[[k]] ]] ],
{k, Length[dex]}],
Null](*end DeleteCases*)
](*end vector union*)
]
\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*assumes symmetry*)
(*given the distance of the center of the most-distant tile,*)
(*divide the zonotile into k concentric regions, with*)
(*separate colorlists*)
tilesplit[tile_List,k_]:=
Block[{},
fcents=vunion[ Map[ Chop[cent[#]]&, tile] ];
maxcent=Max[Map[mag[#]&, fcents] ];
{
Select[tile, mag[cent[#]]<=(.001+maxcent/k)&],
Select[tile, mag[cent[#]]>(maxcent/k)&]
}
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*removes duplicates and re-orders line list*)
fixLines[ln_List]:=
Block[{rawlns,newlns},
rawlns=Cases[ln, {_,_,_}, Infinity ];
Print[\"There are \", Length[rawlns],\" lines at first\"];
newlns=Sort[ Union[rawlns], (#1[[1]]>#2[[1]])&];
Print[\"There are \", Length[newlns],\" lines altogether\"];
newlns
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]]
}, Open  ]],

Cell[CellGroupData[{

Cell["POV export code", "Subsection",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*get unique vertices and edges for POV spheres and cylinders*)
vertedge[tile_]:=
Block[{v1,e1},
v1=vunion[Flatten[tile,1]];
e1=eUnion[tile];
Print[\"First member of list is 2D vertices, second, 2D edges\"];
{v1, e1}
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
eUnion[tiling_]:=
Block[{edall,edrat,dex},
edall=Flatten[ Map[ tosegs[ # ]&, tiling],1];
edrat=Rationalize[ cent /@ edall, .01 ];
dex=Flatten[Map[ (First@Position[ edrat, # ])&, Union[ edrat ] ] ];
edall[[dex]]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
make3D[gon_]:=Map[ Join[#,{0}]&, gon]

tected = Unprotect[Infix];
Infix[_[e_], h_:Null] := e;
Protect[ Evaluate[tected] ];

(* optional text followed by numbers, FortranForm with 5 digits *)

ndig = 8;
nForm[r_] := NumberForm[Chop[r,.000001], ndig];

writeNums[file_, txt_:\"\", r_?NumberQ] :=
    Write[file, txt, \" \", nForm[r]]
writeNums[file_, txt_:\"\", r_List] :=
    Write[file, txt, \" \", Infix[nForm /@ r, \" \"]]

(* turn n-gon into list of triangles *)

toTriangles[vlist_List] /; Length[vlist] == 3 := {vlist}

(* treat 4gons specially for efficiency *)

toTriangles[vlist_List] /; Length[vlist] == 4 :=
\t{vlist[[{1, 2, 3}]], vlist[[{3, 4, 1}]]}

(* general case: use center of gravity as additional vertex *)
(* in this way, some nonconvex polygons can also be rendered correctly *)

toTriangles[vlist_List] :=
    Module[{bary = (Plus @@ vlist)/Length[vlist], circ},
        circ = Partition[ Append[vlist, First[vlist]], 2, 1 ];
        Apply[ {#1, #2, bary}&, circ, {1} ]
    ]
    
Ball[x_List,r_]:={x,r}

Rod[x_List,r_]:={x,r}

cyllmake[txt_:\"\", r_List] /; Length[r] == 2 :=
    SequenceForm[txt,\"{\", \"<\", Infix[nForm /@ r[[1,1]], \", \"], \">\",
    \",\", \"<\", Infix[nForm /@ r[[1,2]], \", \"], \">\",\" \",r[[2]],\"}\" \
]
    
ballmake[txt_:\"\", r_List] /; Length[r] == 2 :=
    SequenceForm[txt,\"{\", \"<\", Infix[nForm /@ r[[1]], \", \"], \">\",
    \" \",r[[2]],\"}\" ]
    
facemake[txt_:\"\", r_List] /; Length[r] == 3 :=
    SequenceForm[txt,\"{\", \"<\", Infix[nForm /@ r[[1]], \", \"], \">\",
    \",\", \"<\", Infix[nForm /@ r[[2]], \", \"], \">\",
    \",\", \"<\", Infix[nForm /@ r[[3]], \", \"], \">\",\"}\" ]
    
colmake[txt_:\"\", r_]:=
    SequenceForm[txt,\"{\",\"color rgb\", \"<\", Infix[nForm /@ r, \", \"], \
\">\",\"}\" ]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 ImageRegion->{{0, 1}, {0, 1}},
 Background->GrayLevel[0.833326]],

Cell["\<\
(*send zonotile vertices, edges and polygons 
to POV spheres, cylinders, and triangles*)
TessToPOV[filename_String,fa_List,vert_List,edg_List]:=
Block[{poly,faces},

strm=OpenWrite[filename,
FormatType->OutputForm,
PageWidth->Infinity];
Write[strm,\"#declare FACES = union{\"];
\tDo[
\tWrite[strm,\"mesh{\"];
\tpoly=Map[toTriangles[#]&,fa[[i]] ];
\tfaces=ColumnForm[Map[facemake[\"triangle\",# ]&,Chop[Flatten[poly,1]]],Left];
\tWrite[strm,faces];
\tWrite[strm,colmake[\"pigment\", colors[[i]] ]];
\tWrite[strm,\"}\"],
\t{i,Length[fa]}];
Write[strm,\"}\"];

Write[strm,\"#declare VERTS = union{\"];
q1=Map[Ball[#,.15]&, verts ];
Write[strm,
ColumnForm[ Map[ ballmake[\"sphere\",# ]&, q1 ] ]
];
Write[strm,\"texture{T1}\"];
Write[strm,\"}\"];

Write[strm,\"#declare EDGES = union{\"];
q1=Map[Rod[#,.1]&, sides ];
Write[strm,
ColumnForm[ Map[ cyllmake[\"cylinder\",# ]&, q1 ] ]
];
Write[strm,\"texture{T2}\"];
Write[strm,\"}\"];

Close[strm]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*send zonotile vertices, edges and polygons 
to POV spheres, cylinders, and polygons*)
UnDragonToPOV[filename_String,tile_List,verts_List,sides_List]:=
Block[{q1,strm},

strm=OpenWrite[filename,
FormatType->OutputForm,
PageWidth->Infinity];

Write[strm,\"#declare FACES = union{\"];
\tDo[
\tWrite[strm,\"union{\"];
\tWrite[strm,ColumnForm[ Map[polymake[# ]&, Chop[ tile[[i]] ] ], Left]];
\tWrite[strm,colmake[\"pigment\", colors[[i]] ]];
\tWrite[strm,\"}\"],
\t{i,Length[tile]}];
Write[strm,\"}\"];

Write[strm,\"#declare VERTS = union{\"];
q1=Map[Ball[#,.15]&, verts ];
Write[strm,
ColumnForm[ Map[ ballmake[\"sphere\",# ]&, q1 ] ]
];
Write[strm,\"texture{T1}\"];
Write[strm,\"}\"];

Write[strm,\"#declare EDGES = union{\"];
q1=Map[Rod[#,.1]&, sides ];
Write[strm,
ColumnForm[ Map[ cyllmake[\"cylinder\",# ]&, q1 ] ]
];
Write[strm,\"texture{T2}\"];
Write[strm,\"}\"];

Close[strm]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*send zonotile vertices, edges and polygons 
to POV spheres, cylinders, and prisms*)
DragonToPOV[filename_String,fa_List,vert_List,edg_List]:=
Block[{q1,strm},
strm=OpenWrite[filename,
FormatType->OutputForm,
PageWidth->Infinity];

Write[strm,\"#declare FACES = \"];\t
\tWrite[strm,\"union{\"];
\tWrite[strm,ColumnForm[ Map[prismmake[# ]&, Chop[fa] ], Left]];
\tWrite[strm,\"texture{T1}\"];
\tWrite[strm,\"}\"];

Write[strm,\"#declare VERTS = union{\"];
q1=Map[Ball[#,.15]&, verts ];
Write[strm,
ColumnForm[ Map[ ballmake[\"sphere\",# ]&, q1 ] ]
];
Write[strm,\"texture{T2}\"];
Write[strm,\"}\"];

Write[strm,\"#declare EDGES = union{\"];
q1=Map[Rod[#,.1]&, sides ];
Write[strm,
ColumnForm[ Map[ cyllmake[\"cylinder\",# ]&, q1 ] ]
];
Write[strm,\"texture{T3}\"];
Write[strm,\"}\"];

Close[strm]
]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
polymake[txt_:\"\", r_List]:= (*2D polygons to z=0 3D polygons*)
    ColumnForm[
    {
    \"polygon\",\"{\", 
    StringJoin[ ToString[ Length[ r ] + 1 ], \",\"],
    
Sequence @@ Map[ SequenceForm[\"<\", Infix[nForm /@ #, \", \"], \">\"]&, \
Join[r,{r[[1]]}]],
    
    \"}\"
    }
    ]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
prismmake[txt_:\"\", r_List]:= (*2D polygons to 3D prisms, ZLO<=z<=ZHI*)
    ColumnForm[
    {
    \"prism\",\"{\", 
    \"linear_spline\",
    \"linear_sweep\",
    StringJoin[\"ZLO,\", \"ZHI,\", ToString[ Length[ r ] + 1 ], \",\"],
    
Sequence@@ Map[ SequenceForm[\"<\", Infix[nForm /@ #, \", \"], \">\"]&, \
Join[r,{r[[1]]}]],
    
    \"}\"
    }
    ]\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]],

Cell["\<\
(*sample scene file for Dragon design export to POV*)
scenefile={\"// Persistence of Vision Ray Tracer Scene Description File\", \
\"// File: dragonalia.pov\", \"// Vers: 3.1\", 
  \"// Desc: 2D zonotile\", \"// Date: 2/22/05\", \"// Auth: Russell Towle\", \
\"//\", 
  \"/* ----------------------------------------*/\", \"#version 3.1;\", \
\"#include \\\"colors.inc\\\"\", 
  \"#include \\\"shapes.inc\\\"\", \"#include \\\"textures.inc\\\"\", \
\"#include \\\"metals.inc\\\"\", 
  \"#default { texture { pigment {color rgb <1,1,1>} finish {phong 0.5 \
ambient 0.2 diffuse .6} }}\", 
  \"/* ----------------------------------------*/\", \"camera {\", \
\"\\tlocation <-20, -15, 25>/3\", 
  \"\\tdirection <0, 1, 0> //.75 wide angle\", \"\\tup <0, 0, 1>\", \
\"\\tright <4/3, 0, 0> //aspect ratio, w/h\", 
  \"\\tsky <0., 0., 1.>\", \"\\tlook_at <0.5, 0., 1>\", \"}\", \"/* \
----------------------------------------*/\", 
  \"light_source {<-40, 10, 30>*4 color rgb <1, 1, 1>}\", \"light_source {<5, \
-25, 10>*20 color rgb <1, 1, 1>/2}\", 
  \"/* ----------------------------------------*/\", \"/*Begin Dragon*/\", 
  \"/*T1 for prism, T2 for spheres, T3 for cylinders*/\", 
  \"#declare T1 = texture { pigment {color rgb <1,1,0>} finish {phong 0.01 \
ambient 0.2 diffuse .6} }\", 
  \"#declare T2 = texture { pigment {color rgb <1,1,1>} finish {phong 0.01 \
ambient 0.2 diffuse .6} }\", 
  \"#declare T3 = texture { pigment {color rgb <1,1,1>} finish {phong 0.01 \
ambient 0.2 diffuse .6} }\", 
  \"#declare ZLO = 1;//base of prism\", \"#declare ZHI=2;//top of prism\", \
\"#include\\\"dragon1.inc\\\"\", 
  \"object{FACES rotate<90,0,0>}\", \"//object{VERTS}\", \"//object{EDGES}\", \
\"/*End  Dragon*/\", 
  \"/* ----------------------------------------*/\", \"/*Begin UnDragon*/\", \
\"/*T1 for spheres, T2 for cylinders*/\", 
  \"#declare T1 = texture { pigment {color rgb <1,1,1>} finish {phong 0.01 \
ambient 0.2 diffuse .6} }\", 
  \"#declare T2 = texture { pigment {color rgb <1,1,1>} finish {phong 0.01 \
ambient 0.2 diffuse .6} }\", 
  \"#include\\\"undragon.inc\\\"\", \"/*the faces, edges and vertices defined \
in the #include file*/\", \"object{FACES }\", 
  \"object{VERTS scale<1, 1, 1>}\", \"object{EDGES scale<1, 1, 1>}\", \"/*End \
UnDragon*/\", 
  \"/* ----------------------------------------*/\", \"plane{<0,0,1>, -2\", \
\"pigment{\", \"  checker\", 
  \"    color rgb <1, 1, 1>\", \"    color rgb <1, 1, 1>/2\", \"scale 20}\", \
\"}\", 
  \"/* ----------------------------------------*/\", \"sky_sphere\", \"{\", \
\"  pigment\", \"  {\", \"    gradient z\", 
  \"    color_map { [0.0 color rgb <0.7,0.7,0.7>] [1.0 color rgb \
<1.0,1.0,1.0>] }\", \"  }\", \"}\", 
  \"/* ----------------------------------------*/\"};\
\>", "Input",
 CellFrame->True,
 InitializationCell->True,
 Background->GrayLevel[0.833326]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Tutorial", "Section",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[CellGroupData[{

Cell["Success and Failure", "Subsection"],

Cell[TextData[{
 "It is hoped that users of this notebook will experiment with their own line \
arrangements. There are a few things to keep in mind: foremost, however many \
\[OpenCurlyDoubleQuote]generating\[CloseCurlyDoubleQuote] vectors are chosen, \
from which the perpendicular lines of the arrangement follow, the vectors \
must all reside within a half-plane. There should be no duplicates. The \
vectors ",
 StyleBox["must",
  FontSlant->"Italic"],
 " be cyclically ordered.\n\nHere we cover these points in turn. First, a \
\[OpenCurlyDoubleQuote]successful\[CloseCurlyDoubleQuote] set of vectors is \
created, all within a half-plane, the vectors and their opposites displayed, \
the line arrangement displayed, the zonotile displayed. Next we will consider \
various ways the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function fails. Finally, we test the ordering of distances, the \
duplication of distances, and cyclically ordered random vectors within a \
half-plane."
}], "Text"],

Cell[CellGroupData[{

Cell["Success", "Subsubsection"],

Cell[TextData[{
 "(*only ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines, displaced from the origin*)\nn=5;\ndist={1};\n\nlns=Flatten[Table[\n\
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],\n{i,n},{j, \
Length[dist]}],1];\nPrint[\"There are \", Length[lns],\" lines altogether\"];\
\n\n(*construct and display the unit vectors, colored red*)\n(*with their \
opposites dashed and colored blue*)\ng1=Show[ linestostar[lns],\n\
PlotLabel->\"Vectors and Opposites\",\nFrame->True];\n\n(*display line \
arrangement within suitable radius*)\nradius=5;\ng2=Show[drawLines[lns, \
radius],\nPlotLabel->\"The Perpendicular Lines\",\nFrame->True];\n\n(*combine \
the unit vectors and lines*)\nShow[{g1,g2},\nPlotLabel->\"Vectors and \
Lines\",\nPlotRange->{{-radius, radius},{-radius,radius}},\nFrame->True,\n\
AspectRatio->Automatic];\n\n(*create zonotile*)\nzaq=zonotile[lns];\n\
(*display edges of zonotile*)\ng3=Show[Graphics[{GrayLevel[0], Map[Line /@ \
tosegs[#]&, zaq]} ],\nPlotLabel->\"The Zonotile\",\nFrame->True,\n\
AspectRatio->Automatic];\n\n(*Show vectors, lines, zonotile--drag out \
larger*)\nShow[GraphicsArray[{g1,g2,g3}]];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Failure by Exceeding a Half-Plane", "Subsubsection"],

Cell[TextData[{
 "This failure is not as bad as half-plane violations are, usually. See the \
red code, where the iterator ",
 StyleBox["i",
  FontWeight->"Bold"],
 " is allowed to run past ",
 StyleBox["n",
  FontWeight->"Bold"],
 "."
}], "Text"],

Cell[TextData[{
 "n=5;\ndist={1};\n\nlns=Flatten[Table[\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], \
dist[[j]] }]],\n",
 StyleBox["{i,n+3}",
  FontColor->RGBColor[1, 0, 0]],
 ",{j, Length[dist]}],1];\nPrint[\"There are \", Length[lns],\" lines \
altogether\"];\n\n(*construct and display the unit vectors, colored red*)\n\
(*with their opposites dashed and colored blue*)\ng1=Show[ linestostar[lns],\n\
PlotLabel->\"Vectors and Opposites\",\nFrame->True];\n\n(*display line \
arrangement within suitable radius*)\nradius=5;\ng2=Show[drawLines[lns, \
radius],\nPlotLabel->\"The Perpendicular Lines\",\nFrame->True];\n\n(*combine \
the unit vectors and lines*)\nShow[{g1,g2},\nPlotLabel->\"The Unit Vectors \
and the Lines\",\nPlotRange->{{-radius, radius},{-radius,radius}},\n\
Frame->True,\nAspectRatio->Automatic];\n\n(*create zonotile*)\n\
zaq=zonotile[lns];\n(*display edges of zonotile*)\n\
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Failure by Allowing Duplicates", "Subsubsection"],

Cell["\<\
Here the only apparent failure is that one zone of edges within the zonotile \
has twice the length of the others. The fifth vector was duplicated by adding \
it to the end of the list (see red code); hence no cyclic violation occurred.\
\
\>", "Text"],

Cell[TextData[{
 "(*only ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines, displaced from the origin*)\nn=5;\ndist={1};\n\nlns=Flatten[Table[\n\
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],\n{i,n},{j, \
Length[dist]}],1];\n\n",
 StyleBox["(*we have a pair of duplicates*)\nlns=Join[lns, {lns[[5]]} ];\n",
  FontColor->RGBColor[1, 0, 0]],
 "Print[\"There are \", Length[lns],\" lines altogether\"];",
 StyleBox["\n",
  FontColor->RGBColor[1, 0, 0]],
 "\n(*create zonotile*)\nzaq=zonotile[lns];\n(*display edges of zonotile*)\n\
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Failure by Lack of Cyclic Ordering", "Subsubsection"],

Cell["\<\
If the generating vectors are not cyclically ordered (see red code), all hell \
breaks loose.\
\>", "Text"],

Cell[TextData[{
 "n=5;\ndist={1};\n\nlns=Flatten[Table[\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], \
dist[[j]] }]],\n{i,n},{j, Length[dist]}],1];\nPrint[\"There are \", \
Length[lns],\" lines altogether\"];\n\n",
 StyleBox["(*we violate cyclic order*)\nlns=lns[[ {2,1,5,4,3} ]];\n",
  FontColor->RGBColor[1, 0, 0]],
 "\n(*construct and display the unit vectors, colored red*)\n(*with their \
opposites dashed and colored blue*)\ng1=Show[ linestostar[lns],\n\
PlotLabel->\"Vectors and Opposites\",\nFrame->True];\n\n(*display line \
arrangement within suitable radius*)\nradius=5;\ng2=Show[drawLines[lns, \
radius],\nPlotLabel->\"The Perpendicular Lines\",\nFrame->True];\n\n(*combine \
the unit vectors and lines*)\nShow[{g1,g2},\nPlotLabel->\"The Unit Vectors \
and the Lines\",\nPlotRange->{{-radius, radius},{-radius,radius}},\n\
Frame->True,\nAspectRatio->Automatic];\n\n(*create zonotile*)\n\
zaq=zonotile[lns];\n(*display edges of zonotile*)\n\
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Ordering of the Distances Does Not Matter", "Subsubsection"],

Cell["\<\
The distances need not be kept in ascending order (see red code).\
\>", "Text"],

Cell[TextData[{
 "n=5;\n",
 StyleBox["dist={2,-1,1,0,-2};",
  FontColor->RGBColor[1, 0, 0]],
 "\n\nlns=Flatten[Table[\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],\n\
{i,n},{j, Length[dist]}],1];\n",
 StyleBox["\n",
  FontColor->RGBColor[1, 0, 0]],
 "Print[\"There are \", Length[lns],\" lines altogether\"];",
 StyleBox["\n",
  FontColor->RGBColor[1, 0, 0]],
 "\n(*create zonotile*)\nzaq=zonotile[lns];\n(*display edges of zonotile*)\n\
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Duplication of Distances", "Subsubsection"],

Cell[TextData[{
 "If distances are duplicated (see red code), then so also are the generating \
vectors; so we again obtain a non-equilateral zonotile. I am accustomed to \
use other methods to build non-equilateral zonotiles (see the ",
 StyleBox["Examples",
  FontWeight->"Bold"],
 " section), which do not overload the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function with unnecessary lines. It puzzles me that duplications such as \
these do not fail more badly."
}], "Text"],

Cell[TextData[{
 "n=5;\n",
 StyleBox["dist={-2,-2,-1,0,1,1,1};",
  FontColor->RGBColor[1, 0, 0]],
 "\n\nlns=Flatten[Table[\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],\n\
{i,n},{j, Length[dist]}],1];\n",
 StyleBox["\n",
  FontColor->RGBColor[1, 0, 0]],
 "Print[\"There are \", Length[lns],\" lines altogether\"];",
 StyleBox["\n",
  FontColor->RGBColor[1, 0, 0]],
 "\n(*create zonotile*)\nzaq=zonotile[lns];\n(*display edges of zonotile*)\n\
Show[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Vectors, Cyclically Ordered", "Subsubsection"],

Cell["\<\
Keep them within a half-plane, and let them be cyclically ordered, and the \
vectors need not be equally-spaced. We rather neatly obtain \
\[OpenCurlyDoubleQuote]random\[CloseCurlyDoubleQuote] zonotiles (see red \
code), which change each time the code block is evaluated.\
\>", "Text"],

Cell[TextData[{
 "n=5;\ndist={0,1};\n\n",
 StyleBox["randomfactors=Sort[Table[ Random[Real, {i-.9, i-.01}],{i,n}]]",
  FontColor->RGBColor[1, 0, 0]],
 "\nPrint[\"The random factors are \", randomfactors];\n\nlns=Flatten[Table[\n\
Chop[N[{ Cos[ randomfactors[[i]]*Pi/n], Sin[ randomfactors[[i]]*Pi/n], \
dist[[j]] }]],\n{i,n},{j, Length[dist]}],1];\nPrint[\"There are \", \
Length[lns],\" lines altogether\"];\n\n(*construct and display the unit \
vectors, colored red*)\n(*with their opposites dashed and colored blue*)\n\
g1=Show[ linestostar[lns],\nPlotLabel->\"Vectors and Opposites\",\n\
Frame->True];\n\n(*create zonotile*)\nzaq=zonotile[lns];\n(*display edges of \
zonotile*)\nShow[Graphics[{GrayLevel[0], Map[Line /@ tosegs[#]&, zaq]} ],\n\
Frame->True,\nAspectRatio->Automatic];"
}], "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Comparison of Line Spacings", "Subsection"],

Cell[TextData[{
 "The ",
 StyleBox["showtile",
  FontWeight->"Bold"],
 " function allows easy comparison of line spacings; colors are predefined. \
In the first example, five sets of four lines and five sets of five lines \
(each 5-set containing a line through the origin) are compared. Each set \
contains two lines at unit distance, with the other two or three within \
these. We go from tightly bunched near the origin, to tightly bunched away \
from the origin, and pass through several \[OpenCurlyDoubleQuote]harmonic\
\[CloseCurlyDoubleQuote] ratios along the way, where the spacings are such \
that more than two lines intersect at certain points."
}], "Text"],

Cell["\<\
n=5;
dist={
Union[ Join[a={.1,1}, -a] ],
Union[ Join[a={N[Cos[3*Pi/n]],1}, -a] ],
Union[ Join[a={2*N[Cos[3*Pi/n]],1}, -a] ],
Union[ Join[a={N[Cos[4*Pi/n]],1}, -a] ],
Union[ Join[a={.9,1}, -a] ],
Union[ Join[a={0,.1,1}, -a] ],
Union[ Join[a={0,N[Cos[3*Pi/n]],1}, -a] ],
Union[ Join[a={0,2*N[Cos[3*Pi/n]],1}, -a] ],
Union[ Join[a={0,N[Cos[4*Pi/n]],1}, -a] ],
Union[ Join[a={0,.9,1}, -a] ]
};

Do[showtile[n, dist[[i]] ], {i, Length[dist]}]\
\>", "Input"],

Cell["\<\
By taking equal small steps we may avoid \[OpenCurlyDoubleQuote]harmonic\
\[CloseCurlyDoubleQuote] ratios along the way. Or not.\
\>", "Text"],

Cell["\<\
Do[showtile[6, Union[ Join[a={i,1}, -a] ] ],
{i,.1,.9,.1}]\
\>", "Input"],

Cell["\<\
Here we take a fixed line spacing, of {-1, -.3, 0, .3, 1}, and displace each \
set away from the origin in steps of .1, from 0 to 1.\
\>", "Text"],

Cell["\<\
Do[showtile[7, i+Union[ Join[a={0,.3,1}, -a] ] ],
{i,0,1,.1}]\
\>", "Input"],

Cell["\<\
The limit as we displace the line sets farther from the origin is an \
especially simple tiling of the bounding 14-gon. It is similar to the \
zonotile obtained with a set of seven lines at distance 1.\
\>", "Text"],

Cell["\<\
showtile[7, 25+Union[ Join[a={0,.3,1}, -a] ] ]
showtile[7, {1} ]\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Penrose Tilings and Dragon Designs", "Section"],

Cell[CellGroupData[{

Cell["Introduction", "Subsection"],

Cell[TextData[{
 "Around 1975 Sir Roger Penrose discovered certain aperiodic tilings of the \
plane, some involving ",
 StyleBox["kites",
  FontSlant->"Italic"],
 " and ",
 StyleBox["darts",
  FontSlant->"Italic"],
 ", others, 36- and 72-degree rhombs. One could translate from \
kites-and-darts to rhombs, or vice versa. In 1981 Nicolaas de Bruijn began \
publishing a series of papers on the algebraic underpinnings of these \
\[OpenCurlyDoubleQuote]Penrose\[CloseCurlyDoubleQuote] tilings. De Bruijn \
constructed the Penrose tiling of 36- and 72-degree rhombs using a \
\[OpenCurlyDoubleQuote]pentagrid,\[CloseCurlyDoubleQuote] in which an \
infinite \[OpenCurlyDoubleQuote]grid\[CloseCurlyDoubleQuote] of \
equally-spaced lines, one unit apart, was rotated 0, 72, 144, 216, and 288 \
degrees. De Bruijn showed how a pentagrid led to a tiling of zonogons, and if \
the five grids were properly offset from the origin, the zonogons were simply \
36- and 72-degree rhombs.\n\nHe also extended the concept of a pentagrid to \
that of a multigrid, in which, rather than five directions, the grids were \
perpendicular to some ",
 StyleBox["n",
  FontSlant->"Italic"],
 " directions, ",
 StyleBox["n",
  FontSlant->"Italic"],
 ">=2 (see ",
 StyleBox["The Heptagrid",
  FontWeight->"Bold"],
 ", below). And he showed that this all generalized to higher space, where \
instead of arrangements of lines, we have arrangements of hyperplanes, and \
instead of a tiling of a 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon by rhombs, we have a tiling of a zonotope by parallelotopes. For how \
",
 StyleBox["arrangements of planes",
  FontSlant->"Italic"],
 " lead to the tilings of zonohedra by smaller zonohedra, not necessarily \
rhombic hexahedra, see my ",
 StyleBox["3D_Zonotiles.nb",
  FontWeight->"Bold"],
 ", available on ",
 StyleBox["MathSource",
  FontSlant->"Italic"],
 ".\n\nProfessor Vince Matsko of Quincy University was so very kind as to \
send me his collection of de Bruijn\[CloseCurlyQuote]s papers. For a year I \
have puzzled over them, and to this day I do not follow his arguments and \
proofs. However, things have become somewhat clearer. This version of the ",
 StyleBox["2D_Zonotiles.nb",
  FontWeight->"Bold"],
 " was prompted by my belated realization that random numbers have nothing to \
do with Penrose tilings. I fell into this serious error years ago, somehow \
connecting the aperiodicity of Penrose tilings, with random offsets of the \
grids.\n\nIn the course of experimentation, however, I began to obtain \
results better approximating the \[OpenCurlyDoubleQuote]classic\
\[CloseCurlyDoubleQuote] Penrose tiling of \[OpenCurlyDoubleQuote]arrowed \
rhombs.\[CloseCurlyDoubleQuote] These arose when I began confining my \
random-number offsets within narrow bounds. These in turn led to even \
narrower bounds, and at last random offsets were abandoned in favor of \
single, fixed, rational offsets. Immediately I obtained perfect \
arrowed-rhombus tilings, adorned with those marvelous runs of 72-degree \
rhombs I call \[OpenCurlyDoubleQuote]dragon designs.\[CloseCurlyDoubleQuote] \
A complete reorganization of my ideas followed, and more reading of those \
inscrutable papers of de Bruijn.\n\nThe subsections below contain various \
approaches to making \[OpenCurlyDoubleQuote]perfect\[CloseCurlyDoubleQuote] \
Penrose tilings. Some violate de Bruijn\[CloseCurlyQuote]s rules.\n\nIn an \
attempt to clarify the situation, let me state what little I do know about de \
Bruijn\[CloseCurlyQuote]s approach to Penrose tilings.\n\nA ",
 StyleBox["grid",
  FontSlant->"Italic"],
 " is a set of parallel lines spaced one unit apart. For instance, consider \
the lines parallel to the ",
 StyleBox["x",
  FontWeight->"Bold"],
 " axis given by ",
 StyleBox["y=a",
  FontWeight->"Bold"],
 ", where ",
 StyleBox["a",
  FontWeight->"Bold"],
 " runs through the integers: these form a grid, and we represent any one \
line of this grid as {0, 1, ",
 StyleBox["a",
  FontWeight->"Bold"],
 "}. For de Bruijn\[CloseCurlyQuote]s purposes, a grid had infinitely many \
lines; here, we use a finite number of lines.\n\nA ",
 StyleBox["pentagrid",
  FontSlant->"Italic"],
 " is the set of five grids obtained by rotating a grid 0, 72, 144, 216, and \
288 degrees.\n\nIf no more than two lines intersect at any one point, a \
pentagrid is called ",
 StyleBox["regular",
  FontSlant->"Italic"],
 ", otherwise, ",
 StyleBox["singular",
  FontSlant->"Italic"],
 ". If five lines intersect at a point, the pentagrid is ",
 StyleBox["exceptionally singular",
  FontSlant->"Italic"],
 ".\n\nA pentagrid is described by five offsets, which are real numbers. All \
can be equal, or all different, or some positive and some negative. If they \
are all zero, we obtain an exceptionally singular pentagrid. If they are all \
integers, and the number of lines is infinite, we once again obtain an \
exceptionally singular pentagrid, shifted away from the origin. De Bruijn \
insists that these five real numbers sum to zero: then we can refer to ",
 StyleBox["zero-sum",
  FontSlant->"Italic"],
 " pentagrids. Note that, if some four of the five offsets sum to zero, the \
fifth must ",
 StyleBox["be",
  FontSlant->"Italic"],
 " zero. For example, {0.1, -0.1, 0.1, -0.1, 0}.\n\nDe Bruijn writes: a \
regular [zero-sum] pentagrid determines an arrowed-rhombus pattern. Since the \
pentagrid is regular, no more than two lines intersect at any one point; \
hence only rhombs arise in the tiling, and these of two types, 36- and \
72-degree rhombs. By a certain scheme the edges are marked with red and green \
arrows, and two rhombs can share an edge if and only if colors and directions \
match. This is the ",
 StyleBox["matching condition",
  FontSlant->"Italic"],
 " for the \[OpenCurlyDoubleQuote]classic\[CloseCurlyDoubleQuote] Penrose \
tiling (see, among others, his ",
 StyleBox["Algebraic Theory of Penrose\[CloseCurlyQuote]s non-periodic \
tilings of the plane",
  FontSlant->"Italic"],
 ", Kon. Nederl. Akad. Wetensh., Proc. Ser. A 84, 1981).\n\nThere is a broad \
spectrum of tilings which arise from pentagrids, spanning much variation, and \
whenever we focus on one little part of that spectrum, it seems to become \
indefinitely more complex. This behavior of the tilings is related, one \
senses, to Penrose\[CloseCurlyQuote]s operations on his tilings, ",
 StyleBox["inflation",
  FontSlant->"Italic"],
 " and ",
 StyleBox["deflation",
  FontSlant->"Italic"],
 ". But there are spectra of spectra, patterns of patterns, and various \
varieties of symmetry--how many varieties? Eight, as de Bruijn has it?\n\nTo \
model this spectrum, and, we hope, discover these symmetries, we shall keep \
some variables fixed, and let one thing alone, incrementally, change. We will \
create animations of tilings, for instance, in which we change the absolute \
value of the (single) offset, over some range, taking small steps. By doing \
so, we will find that all different tilings can be obtained within the range \
{0, .5}. Here we call two tilings which differ only by a rotation, or by a \
mirror flip, the same. So, we get the same tiling for offset = .4 as we do \
for offset = .6; the same for offset = -.1, as for offset = .1. Zero and one \
act as mirrors, with the same tilings to either side, in mirror pairs.\n\nBut \
let us immediately verify this."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Pentagrids: a Meandering Exploration", "Subsection"],

Cell[TextData[{
 "To facilitate comparison of many different pentagrids, a ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " function was formed, in which the messy details are hidden away. In \
particular, the problem of reconciling the use of five generating vectors in \
a half-plane, with the expression of offsets and sign patterns in a way \
consistent with pentagrids derived from regular pentagons, is solved behind \
the scenes. ",
 "This was required, for we wish our results to agree with those of de \
Bruijn.\n\nThat is, to make this crucial step clear, we still must use the \
five unit vectors at 36, 72, 108, 144, and 180 degrees, but the ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " function automatically converts the sign-patterns of the offset magnitudes \
from full-plane form to half-plane form, behind the scenes. It is exactly as \
though we were using the more natural pentagrid generators at 72, 144, 216, \
288, and 360 degrees. The details are far too obnoxious to reveal here.\n\n\
Oh, what a headache the conversion from full- plane to half-plane sign \
patterns gave me! It adds one more level of complexity to something already \
well beyond my feeble mind.",
 "\n\nThe ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " ",
 "function accepts three inputs, viz., ",
 StyleBox["pentagrid[ gridrange, signs, magnitudes ]",
  FontWeight->"Bold"],
 ".\n\n1. ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " controls the number of lines in a grid, which, before being offset, are at \
the distances ",
 StyleBox["Range[ -gridrange, gridrange, 1 ]",
  FontWeight->"Bold"],
 " from the origin. Usually ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " will be an integer, ",
 StyleBox["k",
  FontWeight->"Bold"],
 ", in which case there are",
 StyleBox[" 2*k+1",
  FontWeight->"Bold"],
 " lines per grid (an odd number). In this case, the central line of each \
grid passes through the origin (this is how de Bruijn conceived an un-offset \
infinite grid). Sometimes we will set ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " to some half of an odd integer, say, ",
 StyleBox["k/2",
  FontWeight->"Bold"],
 ", in which case there are",
 StyleBox[" k+1",
  FontWeight->"Bold"],
 " lines per grid (an even number), and none pass through the origin. There \
are five grids; a ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " of 10 gives 21 lines per grid, 105 lines altogether. That makes for a \
complicated, time-consuming tiling.\n\n2. ",
 StyleBox["signs",
  FontWeight->"Bold"],
 " allows us to specify the ",
 StyleBox["signs",
  FontSlant->"Italic"],
 " of the five offsets, +1 or -1. We can either enter a single number, say, \
1, in which case all five are taken to be positive, or five separate signs, \
for instance, {1, -1, 1, -1, 1}. Later we shall make special use of these \
sign-patterns.\n\n3. ",
 StyleBox["magnitudes",
  FontWeight->"Bold"],
 " allows us to specify the ",
 StyleBox["magnitudes",
  FontSlant->"Italic"],
 " of the five offsets. We can either enter a single number, say, ",
 StyleBox["d",
  FontWeight->"Bold"],
 ", in which case all five are taken to be ",
 StyleBox["d",
  FontWeight->"Bold"],
 ", or five separate real numbers, for instance, {.1, .2, .2, .1, 0}.\n\nWe \
get our five ",
 StyleBox["offsets",
  FontWeight->"Bold"],
 " as the product of ",
 StyleBox["signs",
  FontWeight->"Bold"],
 " and ",
 StyleBox["magnitudes",
  FontWeight->"Bold"],
 ". In the example above, {1, -1, 1, -1, 1}*{.1, .2, .2, .1, 0}={.1, -.2, .2, \
-.1, 0}. Note that this gives a zero-sum pentagrid, since (.1 + -.2 + .2 + \
-.1 + 0) = 0.\n\nPlease note that typical usages of the ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " function might then take the forms\n\n",
 StyleBox["pentagrid[ 3, 1, 0 ]",
  FontWeight->"Bold"],
 " (seven lines per grid, 35 lines altogether; signs all positive; magnitudes \
all zero; hence offsets={0,0,0,0,0})\n",
 StyleBox["pentagrid[ 3, {1, -1, 1, -1, 1}, .4 ]",
  FontWeight->"Bold"],
 " (seven lines per grid, 35 lines altogether; signs alternate; magnitudes \
all .4; hence offsets={.4, -.4, .4, -.4, .4})\n",
 StyleBox["pentagrid[ 3, -1, {.1, .2, .3, .4, .5 ]",
  FontWeight->"Bold"],
 " (seven lines per grid, 35 lines altogether; signs all negative; five \
magnitudes; hence offsets={-.1, -.2, -.3, -.4, -.5})"
}], "Text"],

Cell[TextData[{
 "First consider the case of the ",
 StyleBox["exceptionally singular",
  FontSlant->"Italic"],
 " pentagrid in which all offsets are zero. It is a zero-sum pentagrid. Five \
lines cross at the origin, {0,0}, and three lines intersect at a multitude of \
other places; a regular decagon, and two types of hexagon, are symmetrically \
disposed within the tiling. Note the ten \[OpenCurlyDoubleQuote]spokes\
\[CloseCurlyDoubleQuote] of hexagons, radiating from the decagon: between \
these spokes are patches of perfect, arrowed-rhombus, dragon-designed Penrose \
tiling. Setting ",
 StyleBox["maxdist",
  FontWeight->"Bold"],
 " larger will expand these intervals."
}], "Text"],

Cell[TextData[StyleBox["pentagrid[ 3, 1, 0 ]",
 FontWeight->"Bold"]], "Input"],

Cell[TextData[{
 "Next consider the case of setting all five offsets to 1. In an infinite \
pentagrid, the pentagrid is carried into itself. In our finite pentagrid, the \
spokes of hexagons no longer reach to the edges of the tiling.. Try ",
 StyleBox["pentagrid[ 3, 1, 2 ]",
  FontWeight->"Bold"],
 " or ",
 StyleBox["pentagrid[ 3, 1, -1 ]",
  FontWeight->"Bold"],
 ", and increasing ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 "."
}], "Text"],

Cell[TextData[StyleBox["pentagrid[ 3, 1, 1 ]",
 FontWeight->"Bold"]], "Input"],

Cell[TextData[{
 "Next consider the case of setting four offsets to 0, the fifth to 1. In an \
infinite pentagrid, once again, the entire pentagrid is carried into itself. \
In fact, in an infinite pentagrid, the ",
 StyleBox["magnitudes",
  FontWeight->"Bold"],
 " could be an absolutely random set of five integers, without any effect on \
the tiling. Compare this tiling to the one above: the decagon is displaced, \
since only one of the five grids has been offset."
}], "Text"],

Cell[TextData[StyleBox["pentagrid[ 3, 1, {1,0,0,0,0} ]",
 FontWeight->"Bold"]], "Input"],

Cell[TextData[{
 "In the example below, one might feel that some great new scheme of tiling \
has been discovered, where rhombs struggle to meet, ten at a vertex; and all \
we have done is make our grid lines run from -7/2 to 7/2, in steps of 1! \
There are eight lines per grid, forty altogether. We set ",
 StyleBox["signs",
  FontWeight->"Bold"],
 " all positive but the ",
 StyleBox["magnitudes",
  FontWeight->"Bold"],
 " are zero in any case. It is a zero-sum pentagrid, but not after the \
fashion of de Bruijn, for his gridlines, before offset, have integer \
distances from the origin."
}], "Text"],

Cell[TextData[StyleBox["pentagrid[ 7/2, 1, 0 ]",
 FontWeight->"Bold"]], "Input"],

Cell[TextData[{
 "Note, however, that we could have achieved the same effect merely by \
setting ",
 StyleBox["magnitudes",
  FontWeight->"Bold"],
 " = 1/2. It is my intent here, in investigating symmetries of tilings, to \
call the tiling below ",
 StyleBox["the same",
  FontSlant->"Italic"],
 " as the tiling above. It is slightly more complicated, arising from 45 \
lines insread of 40."
}], "Text"],

Cell[TextData[StyleBox["pentagrid[ 4, 1, 1/2 ]",
 FontWeight->"Bold"]], "Input"],

Cell["\<\
Here we visit another singular pentagrid, in which four lines intersect at \
the origin, giving an irregular octagon at the center of the tiling.\
\>", "Text"],

Cell[TextData[StyleBox["pentagrid[ 3, 1, {.4,0,0,0,0} ]",
 FontWeight->"Bold"]], "Input"],

Cell[TextData[{
 "Now we keep signs positive, and animate offsets across the range 0 to 1 in \
steps of .1. Note that only ",
 StyleBox["k",
  FontWeight->"Bold"],
 " = 0 gives a zero-sum pentagrid. Here, we use a finite number of lines, and \
the effect is, in part, to move the center of symmetry slowly through the \
tiling.\n\nHaving created the sequence of tilings, each with its offset \
labeled at the top, scroll to the middle, and confirm for yourself that the \
tiling of offset = .4 is equivalent to the tiling of offset = .6, as .3 is to \
.7, .2 to .8, and .1 to .9, and 0 to 1."
}], "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 4, 1, k ], ",
  FontWeight->"Bold"],
 "{k, 0, 1, .1}]"
}], "Input"],

Cell[TextData[{
 "Very well; we have seen that tilings mirror the offset of 1/2, that is, \
offset-r and offset+r give the same tiling, for all our purposes. The same is \
true for the offset of 0, which can be verified by changing the ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop above to run from -.5 to .5 in steps of 0.1. This follows from unit \
spacing of the grid lines.\n\nTo get a sense of how ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " can affect our enumeration of different tilings, compare the image \
sequence below, to that above. We are stepping through offsets from 0 to 1 in \
increments of 0.1 as before, but with only three lines per grid, rather than \
nine. Now sequences of identical tilings begin to arise, spanning more than \
one offset, rather than a different tiling for each offset. Also, the tilings \
do not perfectly mirror across 0.5, or rather, they appear not to mirror. \
Actually the same symmetry-type is mirrored, but for much the same reasons \
that the hexagon-spokes above, terminate before reaching the edge of the \
tiling, here the increasing offset, combined with small grids, is masking the \
mirrored equivalence."
}], "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 1, 1, k ], ",
  FontWeight->"Bold"],
 "{k, 0, 1, .1}]"
}], "Input"],

Cell[TextData[{
 "From now on we often will confine our \[OpenCurlyDoubleQuote]spectral \
analysis\[CloseCurlyDoubleQuote] to the offsets ",
 StyleBox["between",
  FontSlant->"Italic"],
 " 0 and 1/2.\n\nHere we examine the sign pattern {-1,-1,-1,-1,-1}. We have \
seven lines per grid, 45 altogether, and move through the interval {.01, .49} \
in steps of .02. This step is small enough, for these five grids of nine \
lines apiece, that ",
 StyleBox["some",
  FontSlant->"Italic"],
 " tilings repeat, but not small enough that ",
 StyleBox["all",
  FontSlant->"Italic"],
 " tilings repeat.\n\nTwo perfect, arrowed-rhomb, dragon-designed tilings \
arise within the spectrum: at offsets .19 and .21, we have the rounded \
\[OpenCurlyDoubleQuote]Madonna\[CloseCurlyDoubleQuote] dragon design; at \
offset .39, the spiky \
\[OpenCurlyDoubleQuote]Archangel\[CloseCurlyDoubleQuote] design is found."
}], "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,-1,-1,-1,-1}, k ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .02}]"
}], "Input"],

Cell["\<\
Now we refine our march through a narrower range of offsets, using grids of \
thirteen lines, and a step of .005. We look in the vicinity of the Archangel \
motif, offset=.39, recalling that offsets .37 and .41, above, gave different \
tilings. We shall at least gain a better idea of the proper offset or \
\[OpenCurlyDoubleQuote]locus\[CloseCurlyDoubleQuote] for the Archangel \
tiling, for the sign-pattern {1, -1, 1, -1, 1} (it seems to fall around .395).\
\>", "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 6, {-1,-1,-1,-1,-1}, k ], ",
  FontWeight->"Bold"],
 "{k, .38, .41, .005}]"
}], "Input"],

Cell["\<\
Compare what happens if magnitudes are fixed, and signs reversed: the tiling \
is identical except for a mirror flip.\
\>", "Text"],

Cell["\<\
pentagrid[ 3, {-1, -1, -1, -1, -1}, .39 ]
pentagrid[ 3, {1, 1, 1, 1, 1}, .39 ]\
\>", "Input"],

Cell[TextData[{
 "Please consider the following ",
 StyleBox["sign patterns",
  FontSlant->"Italic"],
 ". We will hold magnitudes fixed at .01, which allows easy comparison of the \
central decagon.. Our object is to exhaust all possibilities of setting two \
of the five signs negative, leaving three positive. The number of five \
things, taken two at a time, is ten. The ",
 StyleBox["hemi",
  FontWeight->"Bold"],
 " function returns indices into",
 StyleBox[" Range[ n ]",
  FontWeight->"Bold"],
 " (here ",
 StyleBox["n=5",
  FontWeight->"Bold"],
 ") of things taken two at a time, that is, {1,2}, {2, 3}, ..., {4,5}. These \
are not zero-sum pentagrids. We observe that the tilings, neglecting mirror \
flips, are of but four symmetry-types. "
}], "Text"],

Cell[TextData[{
 "pairdex=hemi[5]\nallsgn=Map[ ReplacePart[{1,1,1,1,1}, -1, \
{{#[[1]]},{#[[2]]}} ]&, pairdex]\nPrint[\"There are \", Length[allsgn], \" \
non-zero-sum sign-pair patterns.\"]\nr=.01;\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 "pentagrid[ 3, allsgn[[k]], {r,r,r,r,r}], {k, Length[ allsgn ]}]"
}], "Input"],

Cell["\<\
Experiment has shown that, neglecting rotations, the same tilings arise for \
these subsets of the ten combinations:

{1,2} and {1,5} and {2,3} and {3,4} and {4,5} lead to the \
\[OpenCurlyDoubleQuote]cyclic\[CloseCurlyDoubleQuote] central decagon, with \
four 36-degree rhombs at one vertex..
{1,3} and {1,4} and {2,4} and {2,5} and {3,5} lead to the \
\[OpenCurlyDoubleQuote]winged\[CloseCurlyDoubleQuote] tiled center. This \
gives an arrowed-rhombus, perfect Penrose tiling in which Archangel and \
Madonna motives are to either side of a line perpendicular to a line of \
bilateral symmetry.

We write down the indices of the signs for each type, and make the following \
list:\
\>", "Text"],

Cell["\<\
symm={ {{1,2}, {1,5}, {2,3}, {3,4}, {4,5}}, {{1,3}, {1,4}, {2,4}, {2,5}, \
{3,5}} }
Length /@ symm\
\>", "Input"],

Cell["\<\
Note that the subsets are of length 5. How does the situation look, \
graphically? We use the indices as coordinates and assign a different color \
to each symmetry type.\
\>", "Text"],

Cell["\<\
col={RGBColor[1, .5, .5],RGBColor[.5, .5, 1],
RGBColor[.5, 1, .5],RGBColor[.5, .5, .5]};

Show[ Graphics [{
Table[
\tMap[ {col[[k]], Disk[ #, .2 ]}&, symm[[k]] ],
\t{k, Length[symm]}],
Table[
\tMap[ Text[ ToString[#], #, {0,0}]&, symm[[k]] ],
\t{k, Length[symm]}]
}],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
Was this an accident of the fixed magnitude, .39? Make the same ten tilings \
from the ten sign patterns, but with magnitude .39.\
\>", "Text"],

Cell[TextData[{
 "pairdex=hemi[5]\nallsgn=Map[ ReplacePart[{1,1,1,1,1}, -1, \
{{#[[1]]},{#[[2]]}} ]&, pairdex]\nPrint[\"There are \", Length[allsgn], \" \
non-zero-sum sign-pair patterns.\"]\nr=.39;\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 "pentagrid[ 3, allsgn[[k]], {r,r,r,r,r}], {k, Length[ allsgn ]}]"
}], "Input"],

Cell[TextData[{
 "We see that the same four sets of sign-patterns correspond to two different \
tiling symmetries. If we were to look at the line arrangements using ",
 StyleBox["drawLines[ lns, 5]",
  FontWeight->"Bold"],
 ", and use ",
 StyleBox["PlotRange",
  FontWeight->"Bold"],
 " to limit our look to a region around the very center of the arrangement, \
we would find that the two different symmetry-types correspond to two \
different decagonal tilings, which are seen at the very center, when the \
magnitudes are small and equal, as in the example above.\n\nNow we \
recapitulate the above, but make zero-sum pentagrids. Note that if the first \
four magnitudes are fixed, and these first four offsets sum to zero, then the \
fifth offset must ",
 StyleBox["be",
  FontSlant->"Italic"],
 " zero. If two of the first four signs are negative, two positive, then \
these four sum to zero. Hence to exhaust all possibilities we need the six \
combinations of ",
 StyleBox["four",
  FontSlant->"Italic"],
 " things, taken two at a time. Now every tiling has just one line of \
bilateral symmetry."
}], "Text"],

Cell[TextData[{
 "pairdex=hemi[4]\nallsgn=Map[ ReplacePart[{1,1,1,1,1}, -1, \
{{#[[1]]},{#[[2]]}} ]&, pairdex]\nPrint[\"There are \", Length[allsgn], \" \
sign-pair patterns.\"]\nr=.01;\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 "pentagrid[ 3, allsgn[[k]], {r,r,r,r,0}], {k, Length[ allsgn ]}]"
}], "Input"],

Cell["\<\
We write down the indices of the signs for each type, and make the following \
list:\
\>", "Text"],

Cell["\<\
symm={ {{1,2}, {1,3}, {2,4}, {3,4}}, {{1,4}, {2,3}} }
Length /@ symm\
\>", "Input"],

Cell["\<\
Note that the subsets are of length 4 and 2. How does the situation look, \
graphically? We use the indices as coordinates and assign a different color \
to each symmetry type.\
\>", "Text"],

Cell["\<\
col={RGBColor[1, .5, .5],RGBColor[.5, .5, 1],
RGBColor[.5, 1, .5],RGBColor[.5, .5, .5]};

Show[ Graphics [{
Table[
\tMap[ {col[[k]], Disk[ #, .2 ]}&, symm[[k]] ],
\t{k, Length[symm]}],
Table[
\tMap[ Text[ ToString[#], #, {0,0}]&, symm[[k]] ],
\t{k, Length[symm]}]
}],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
Let us consider some final cases. Here we use a fixed magnitude and compare \
the five ways just one of the five offsets can be negative. These are not \
zero-sum pentagrids. All tilings are the same, differing only by rotation. \
The central decagon has a signature pattern I call \
\[OpenCurlyDoubleQuote]beaked.\[CloseCurlyDoubleQuote]\
\>", "Text"],

Cell["\<\
pentagrid[ 3, {-1, 1, 1, 1, 1}, .01 ]
pentagrid[ 3, {1, -1, 1, 1, 1}, .01 ]
pentagrid[ 3, {1, 1, -1, 1, 1}, .01 ]
pentagrid[ 3, {1, 1, 1, -1, 1}, .01 ]
pentagrid[ 3, {1, 1, 1, 1, -1}, .01 ]\
\>", "Input"],

Cell["\<\
The sixteenth sign-pattern governing the set of five equal magnitudes is \
simply all signs negative. The number 16 arises as 10 (five things taken two \
at a time) + 5 (five things taken one at a time) + 1 (five things taken 0, or \
5, at a time).\
\>", "Text"],

Cell["pentagrid[ 3, {-1, -1, -1, -1, -1}, .01 ]", "Input"],

Cell["\<\
We look at all sixteen sign patterns, and find there are but four \
symmetry-types, arising as sets of 5, 5, 5, and 1. These are easily \
recognized by the four types of central decagon in the tilings.\
\>", "Text"],

Cell[TextData[{
 "pairdex=hemi[5];\nallsgn=Join[\nMap[ ReplacePart[{1,1,1,1,1}, -1, \
{{#[[1]]},{#[[2]]}} ]&, pairdex],\nTable[ RotateRight[ {-1,1,1,1,1}, i], \
{i,0,4}],\n{{1,1,1,1,1}}\n]\nPrint[\"There are \", Length[allsgn], \" sign \
patterns.\"];\n",
 "r=.01;\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 "pentagrid[ 3, allsgn[[k]], {r,r,r,r,r}], {k, Length[ allsgn ]}]"
}], "Input"],

Cell["\<\
Note that by reversing signs we get thirty-two sign-patterns altogether; but \
reversing all five signs gives the same tiling, with a mirror flip. So the \
sixteen above are enough for our purposes.To complete this part of a \
methodical investigation of tiling spectra, we should pick out four \
sign-patterns representative of the four symmetry-types encountered, and \
animate changes in offset between 0.01 and 0.49, in steps of .08.\
\>", "Text"],

Cell[TextData[{
 "(*the {1,2} class*)\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,-1,1,1,1}, k ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell[TextData[{
 "(*the {1,3} class*)\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,1,-1,1,1}, k ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell[TextData[{
 "(*the {1} class*)\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,1,1,1,1}, k ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell[TextData[{
 "(*the {1,2,3,4,5} class*)\nDo[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,-1,-1,-1,-1}, k ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell["\<\
We have by no means exhausted all possible types of pentagrid.

Note: sometimes it is not easy to pick out changes from one tiling to the \
next. Double-click on any one image to animate the sequence of tilings, and \
the differences become apparent.\
\>", "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,-1,1,1,1}, {k,k,0,k,k} ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell["\<\
Here we let three magnitudes become zero, which force three offsets to zero, \
which means that hexagons are inescapable.\
\>", "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 3, {-1,1,1,1,-1}, {k,0,0,0,k} ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .08}]"
}], "Input"],

Cell[TextData[{
 "Here we let two magnitudes become zero, and set up the the other signs and \
magnitudes such that the offsets sum to zero: a zero-sum regular pentagrid. \
Yet\[LongDash]there seem to be places where four, or eight or ten, 36-degree \
rhombs arise; a violation of Penrose\[CloseCurlyQuote]s arrowed-rhombus \
pattern. We also increase ",
 StyleBox["gridrange",
  FontWeight->"Bold"],
 " to 5 and step through the magnitudes more slowly."
}], "Text"],

Cell[TextData[{
 "Do[",
 StyleBox[" ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["pentagrid[ 5, {1,1,-1,1,1}, {0, k, 2*k, k, 0} ], ",
  FontWeight->"Bold"],
 "{k, .01, .49, .03}]"
}], "Input"],

Cell["\<\
Such, then, is a first look at the varieties of tilings which arise from \
pentagrids.\
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Two Perfect Penrose Tilings", "Subsection"],

Cell["\<\
I think of a patch of Penrose as \[OpenCurlyDoubleQuote]perfect\
\[CloseCurlyDoubleQuote] when it not only meets matching conditions, but \
exhibits the largest possible \[OpenCurlyDoubleQuote]dragon\
\[CloseCurlyDoubleQuote] designs. I allow the term to apply to any set of \
72-degree rhombs meeting edge-to-edge, within the matrix of 36-degree rhombs. \
The simplest of all these dragons, then, are the stars of five 72-degree \
rhombs. The most complicated are the \[OpenCurlyDoubleQuote]starry\
\[CloseCurlyDoubleQuote] and \[CloseCurlyDoubleQuote]rounded\
\[CloseCurlyDoubleQuote] motifs, which scale larger and larger within the \
tiling, as the number of lines in the arrangement increases. I sometimes call \
the starry motif the \[CloseCurlyDoubleQuote]Archangel,\
\[CloseCurlyDoubleQuote] and the rounded motif, the \
\[OpenCurlyDoubleQuote]Madonna.\[CloseCurlyDoubleQuote] Archangels and \
Madonnas interpenetrate in an Escherian luxury of symmetry.

The first pentagrid,with magnitudes all equal to 0.2, gives a tiling centered \
upon a rounded \[OpenCurlyDoubleQuote]Madonna\[CloseCurlyDoubleQuote] dragon \
motif; the latter, magnitudes equal to 0.4, gives a tiling centered upon a \
starry \[OpenCurlyDoubleQuote]Archangel\[CloseCurlyDoubleQuote] dragon motif.\
\
\>", "Text"],

Cell["pentagrid[ 3, {-1, -1, -1, -1, -1}, .2 ]", "Input"],

Cell["pentagrid[ 3, {-1, -1, -1, -1, -1}, .4 ]", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Two More Perfect Penrose Tilings: bilateral symmetry", "Subsection"],

Cell["{1,3} and {1,4} and {2,4} and {2,5} and {3,5}", "Input"],

Cell[TextData[{
 "Here please compare an ",
 StyleBox["r-sum",
  FontWeight->"Bold"],
 " pentagrid and a ",
 StyleBox["zero-sum",
  FontWeight->"Bold"],
 " pentagrid which give the same tiling, divided by a horizontal line of \
symmetry. A vertical line divides the domains of the Madonnas (left) and \
Archangels (right)."
}], "Text"],

Cell["\<\
r=.01;
pentagrid[ 5, {-1, 1, 1, -1, 1}, r ]
pentagrid[ 5, {-1, 1, 1, -1, 1}, {r,r,r,r,0} ]\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["In Search of Dragons", "Subsection"],

Cell[TextData[{
 "Within the classic arrowed-rhombus Penrose tiling of 36- and -72-degrees \
rhombs are \[OpenCurlyDoubleQuote]runs\[CloseCurlyDoubleQuote] or sequences \
of 72-degree rhombs which (to me) resemble \[OpenCurlyDoubleQuote]dragon \
designs.\[CloseCurlyDoubleQuote] We first make a \
\[OpenCurlyDoubleQuote]perfect\[CloseCurlyDoubleQuote] Penrose zonotile, \
color-sorted, with global sorted list ",
 StyleBox["srt",
  FontWeight->"Bold"],
 ". (Several global variables are saved when the ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " function is used, notably, ",
 StyleBox["xaq",
  FontWeight->"Bold"],
 " (the final graphic), and ",
 StyleBox["srt.",
  FontWeight->"Bold"],
 " T",
 "his has two sublists, the 36- and 72-degree rhombs, as ",
 StyleBox["srt[[ 1 ]]",
  FontWeight->"Bold"],
 " and ",
 StyleBox["srt[[ 2 ]]",
  FontWeight->"Bold"],
 ". First we choose those of the 72s with centers within 20 units of the \
origin.\n\nThe method devised to find the dragons is slow and awkward."
}], "Text"],

Cell["pentagrid[ 5, {-1, -1, -1, -1, -1}, .4 ]", "Input"],

Cell[TextData[{
 "(*we name the 72-degree rhombs selected \"q,\" an inspired choice.*)\n\
q=Select[ srt[[2]], ",
 StyleBox["mag[cent[#]]<40&",
  FontColor->RGBColor[1, 0, 0]],
 "];\nPrint[\"There were \", Length[q], \" rhombs selected.\"];\n\n\
xa=Graphics[\n\t{defaultcolorlist[[2]],Polygon /@ q,\n\tGrayLevel[0],Map[Line \
/@ tosegs[#]&, q ]}\n\t];\nShow[xa,\nBackground->GrayLevel[0],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"],

Cell[TextData[{
 "The search for dragons begins with a single rhomb. Note that one can \
command-click on the image above and choose ",
 StyleBox["Copy",
  FontWeight->"Bold"],
 " to obtain point coordinates, and then select some one rhomb with that \
point (call it ",
 StyleBox["pt",
  FontWeight->"Bold"],
 ") near its center, by writing ",
 StyleBox["mag [ cent[#] - pt ] < 1",
  FontWeight->"Bold"],
 " in the top line of code, below, and find your own dragons."
}], "Text"],

Cell["\<\
(*this should work with the example*)
s1=First@Select[ srt[[2]], mag[cent[#]-{-3.55279, -9.47876}]<1&];(*looking \
for a rhomb near the center*)

xe=Graphics[
\t{defaultcolorlist[[2]],Polygon @ s1,
\tGrayLevel[0],Line /@ tosegs[s1]}
\t];
Show[xe,
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
Now, we find all dragon rhombs to one side of the chosen rhomb, and then all \
to the other side; we join the two lists, and display. This may take a while. \
If the dragon forms a closed loop, then we find it twice over; but it is easy \
to change the code to find it just once.\
\>", "Text"],

Cell["\<\
alldex=Range[Length[q]];
seldex1=First@Position[ q, s1 ];
restdex1=Complement[ alldex, seldex1];


(*go in one direction*)
chosentile=s1;
seldex=seldex1;
restdex=restdex1;

nearest=Select[ q, mag[ cent[#]-cent[chosentile] ]<5&];
s2=Select[ nearest, edgeTest[chosentile, # ]==2& ];

While[Length[s2]>0,
nearest=Select[ q[[restdex]], mag[ cent[#]-cent[chosentile] ]<5&];
s3=Select[ nearest, edgeTest[chosentile, # ]==2& ];
If[s3!={},
seldex=Union[Flatten[ { Map[ First@Position[ q, # ]&, s3 ], seldex} ]];
restdex=Complement[ alldex, seldex];
chosentile=First@s3;(*for iteration*)
s2=s3,
s2={}];
]

(*indices into the list \"q\"*)
finaldex1=Select[seldex, IntegerQ[#]&]

(*
(*go in the other direction*)
chosentile=s1;
seldex=seldex1;
restdex=restdex1;

nearest=Select[ q, mag[ cent[#]-cent[chosentile] ]<5&];
s2=Select[ nearest, edgeTest[chosentile, # ]==2& ];

While[Length[s2]>0,
nearest=Select[ q[[restdex]], mag[ cent[#]-cent[chosentile] ]<5&];
s3=Select[ nearest, edgeTest[chosentile, # ]==2& ];
If[s3!={},
seldex=Union[Flatten[ { Map[ First@Position[ q, # ]&, s3 ], seldex} ]];
restdex=Complement[ alldex, seldex];
chosentile=Last@s3;(*for iteration*)
s2=s3,
s2={}];
]

(*indices into the list \"q\"*)
finaldex2=Select[seldex, IntegerQ[#]&]
*)

Length[bothdex=finaldex1];
dra=q[[ bothdex ]];
dragon=Graphics[
\t{RGBColor[1,0,0],Polygon /@ dra,
\tGrayLevel[0],Map[Line /@ tosegs[#]&, dra ]}
\t];
Show[dragon,
Background->GrayLevel[1],
Frame->True,
AspectRatio->Automatic];


Show[{xaq,dragon},
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[{
 "restdex=Complement[ alldex, bothdex];\nnondra=q[[ restdex ]];(*72ers not in \
the dragon*)\nPrint[\"There are \", Length[dra], \" dragon rhombs.\"];\n\
thra=Select[ srt[[1]], ",
 StyleBox["mag[cent[#]]<40&",
  FontColor->RGBColor[1, 0, 0]],
 "];(*36ers*)\nundra=Join[nondra, thra];\nPrint[\"There are \", \
Length[undra], \" non-dragon rhombs.\"];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Dragon Export to POV-Ray", "Subsection"],

Cell[TextData[{
 "It seemed an interesting challenge to export dragon designs to the free \
ray-tracer, POV-Ray. I decided to implement POV\[CloseCurlyQuote]s ",
 StyleBox["polygon",
  FontWeight->"Bold"],
 " and ",
 StyleBox["prism",
  FontWeight->"Bold"],
 " syntax, while retaining the usual spheres and cylinders, for the tiling\
\[CloseCurlyQuote]s vertices and edges. Two #include files are written, to be \
called from a sample POV scene file (",
 StyleBox["dragonalia.pov",
  FontWeight->"Bold"],
 "), itself also written, below. To use these files, create a directory for \
them, and from the ",
 StyleBox["Input",
  FontWeight->"Bold"],
 " menu use ",
 StyleBox["Get File Path",
  FontWeight->"Bold"],
 " to fill in the ",
 StyleBox["SetDirectory",
  FontWeight->"Bold"],
 " function, below."
}], "Text"],

Cell["\<\
(*an example; creates global tile list 'zaq'*)
pentagrid[ 2, {-1, -1, -1, -1, -1}, .4 ]\
\>", "Input"],

Cell[TextData[{
 "(*we name the 72-degree rhombs selected \"q,\" an inspired choice.*)\n\
q=Select[ srt[[2]], ",
 StyleBox["mag[cent[#]]<40&",
  FontColor->RGBColor[1, 0, 0]],
 "];\nPrint[\"There were \", Length[q], \" rhombs selected.\"];\n\n\
xa=Graphics[\n\t{defaultcolorlist[[2]],Polygon /@ q,\n\tGrayLevel[0],Map[Line \
/@ tosegs[#]&, q ]}\n\t];\nShow[xa,\nBackground->GrayLevel[0],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"],

Cell[TextData[{
 "The search for dragons begins with a single rhomb. Here one must \
command-click on the image above and choose ",
 StyleBox["Copy",
  FontWeight->"Bold"],
 " to obtain point coordinates near the center of any one dragon tile, and \
then paste the coordinates into the red text, below."
}], "Text"],

Cell[TextData[{
 "(*this should work with the example*)\ns1=First@Select[ srt[[2]], \
mag[cent[#]-",
 StyleBox["{0.535415, -3.2255}",
  FontColor->RGBColor[1, 0, 0]],
 "]<1&];(*looking for a rhomb near the center*)\n\nxe=Graphics[\n\t\
{defaultcolorlist[[2]],Polygon @ s1,\n\tGrayLevel[0],Line /@ tosegs[s1]}\n\t\
];\nShow[xe,\nBackground->GrayLevel[0],\nFrame->True,\n\
AspectRatio->Automatic];"
}], "Input"],

Cell["\<\
Now, we find a dragon design, and display. It must form a closed loop. This \
may take a while.\
\>", "Text"],

Cell[TextData[{
 "alldex=Range[Length[q]];\nseldex1=First@Position[ q, s1 ];\n\
restdex1=Complement[ alldex, seldex1];\n\n\n(*go in one direction*)\n\
chosentile=s1;\nseldex=seldex1;\nrestdex=restdex1;\n\nnearest=Select[ q, mag[ \
cent[#]-cent[chosentile] ]<5&];\ns2=Select[ nearest, edgeTest[chosentile, # \
]==2& ];\n\nWhile[Length[s2]>0,\nnearest=Select[ q[[restdex]], mag[ \
cent[#]-cent[chosentile] ]<5&];\ns3=Select[ nearest, edgeTest[chosentile, # \
]==2& ];\nIf[s3!={},\nseldex=Union[Flatten[ { Map[ First@Position[ q, # ]&, \
s3 ], seldex} ]];\nrestdex=Complement[ alldex, seldex];\n\
chosentile=First@s3;(*for iteration*)\ns2=s3,\ns2={}];\n]\n\n(*indices into \
the list \"q\"*)\ndragondex=Select[seldex, IntegerQ[#]&]\ndra=q[[ dragondex \
]];\ndragon=Graphics[\n\t{RGBColor[1,0,0],Polygon /@ dra,\n\t\
GrayLevel[0],Map[Line /@ tosegs[#]&, dra ]}\n\t];\nShow[dragon,\n\
Background->GrayLevel[1],\nFrame->True,\nAspectRatio->Automatic];\n\n\n\
Show[{xaq,dragon},\nBackground->GrayLevel[0],\nFrame->True,\n\
AspectRatio->Automatic];\n\n",
 "\n",
 "restdex=Complement[ alldex, dragondex];\nnondra=q[[ restdex ]];(*72ers not \
in the dragon*)\nPrint[\"There are \", Length[dra], \" dragon rhombs.\"];\n\
thra=Select[ srt[[1]], ",
 StyleBox["mag[cent[#]]<40&",
  FontColor->RGBColor[1, 0, 0]],
 "];(*36ers*)\nundra=Join[nondra, thra];\nPrint[\"There are \", \
Length[undra], \" non-dragon rhombs.\"];"
}], "Input"],

Cell["We discard duplicate vertices and edges and transform to 3D.", "Text"],

Cell["\<\
(*The Dragon's unique vertices and edges*)
ve=vertedge[dra];
Print[\"There are \", Length[ ve[[1]] ], \" distinct vertices in the tiling\"];
Print[\"There are \", Length[ ve[[2]] ], \" distinct edges in the tiling\"];
vaq=Graphics[{GrayLevel[0],Map[Line[#]&, ve[[2]] ]}];
Show[vaq,
AspectRatio->Automatic];

(*make vertices 3D*)
verts=make3D[ve[[1]] ];

(*make edges 3D*)
sides=Map[ make3D[#]&, ve[[2]] ];\
\>", "Input"],

Cell["\<\
Now assemble the rest of the tiling in POV format, as polygons, spheres, and \
cylinders.\
\>", "Text"],

Cell["\<\
(*The UnDragon's unique vertices and edges*)
ve=vertedge[undra];
Print[\"There are \", Length[ ve[[1]] ], \" distinct vertices in the tiling\"];
Print[\"There are \", Length[ ve[[2]] ], \" distinct edges in the tiling\"];
vaq=Graphics[{GrayLevel[0],Map[Line[#]&, ve[[2]] ]}];
Show[vaq,
AspectRatio->Automatic];

s=colorSort[ undra ];

(*make vertices 3D*)
verts=make3D[ve[[1]] ];

(*make edges 3D*)
sides=Map[ make3D[#]&, ve[[2]] ];

(*non-dragon colors*)
colors={{0,0,1},{.6,.6,1}};\
\>", "Input"],

Cell["One must choose a directory to write the #include file.", "Text"],

Cell["SetDirectory[\"Macintosh HD :Desktop Folder: povdragon:\"]", "Input"],

Cell["Write the dragon file, undragon file, and sample scene file.", "Text"],

Cell["\<\
DragonToPOV[\"dragon1.inc\",dra,verts,sides]
UnDragonToPOV[\"undragon.inc\",s,verts,sides]
Export[\"dragonalia.pov\", scenefile, \"Lines\"]\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Heptagrid", "Subsection"],

Cell["\<\
A \[OpenCurlyDoubleQuote]heptagrid\[CloseCurlyDoubleQuote] is a set of seven \
grids. Here again we animate offsets over the critical range, 0 < offset < \
.5, in steps of .04. We do not use a zero-sum heptagrid, but make the central \
region a regular heptagon.\
\>", "Text"],

Cell[TextData[{
 StyleBox["Do[\nn=7;\nmaxdist = 3;",
  FontColor->RGBColor[1, 0, 0]],
 "\nrand = Table[\nsgn=If[Mod[i,2]==0, 1, -1];\nsgn*d,\n{i, n}];\ndist=Table[ \
rand[[i]] + Range[-maxdist, maxdist, 1],{i,n}];\n\nlns = \
Flatten[Table[Chop[N[{Cos[i*(Pi/n)], Sin[i*(Pi/n)], dist[[i,j]]}]],\n{i, n}, \
{j, Length[dist[[i]]]}], 1];\n\n(*Show[drawLines[lns,10],\nFrame->True,\n\
PlotRange->{{-1,1},{-1, 1}}];*)\nShare[zaq = zonotile[lns]]; \ns = \
notextcolorSort[zaq];\nIf[Length[s]<=Length[colorlist],\nxaq=Graphics[\n\t\
Table[ {colorlist[[i]],Polygon /@ s[[ i ]],\n\tGrayLevel[0],Map[Line /@ \
tosegs[#]&, s[[i]] ]}, {i,Length[s]}]\n\t];\nShow[xaq,\n\
Background->GrayLevel[0],\nPlotLabel->ToString[d],\nAspectRatio->Automatic];,\
\nPrint[\"Not enough colors!\"]\n],\n{d, 0.01, 0.49, .04}]"
}], "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Periodic and Quasi-Periodic Tilings", "Section"],

Cell[CellGroupData[{

Cell["Regular and Archimedean Zonotiles", "Subsection"],

Cell[CellGroupData[{

Cell["Squares", "Subsubsection"],

Cell[TextData[{
 "Create two sets of ",
 StyleBox["k ",
  FontSlant->"Italic"],
 "equally spaced lines parallel to the sides of a square. For all such sets \
the bounding zonogon of the zonotile is a square."
}], "Text"],

Cell["\<\
n=2;
dist=Range[-2,2];
lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 5]];

(*create and display*)
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Regular Hexagons", "Subsubsection"],

Cell[TextData[{
 "Create three sets of ",
 StyleBox["k ",
  FontSlant->"Italic"],
 "equally spaced lines parallel to the sides of an equilateral triangle, with \
one line in each set through the origin. For all such sets the bounding \
zonogon of the zonotile is a regular hexagon. If the distances run from 0 to ",
 StyleBox["k",
  FontSlant->"Italic"],
 ", a triangular region of hexagons occupies the center of the hexagonal \
zonotile. If the distances run from ",
 StyleBox["-k",
  FontSlant->"Italic"],
 " to ",
 StyleBox["k",
  FontSlant->"Italic"],
 ", a hexagonal region of hexagons arises."
}], "Text"],

Cell["\<\
n=3;
dist=Range[0,3];(*set to Range[-3,3] for hexagonal region*)
lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 10]];

(*create and display*)
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Dodecagons, Hexagons, and Squares", "Subsubsection"],

Cell[TextData[{
 "Let the sets of lines be centered upon the origin, and of two different \
spacings, which alternate, to force intersections within a central region of \
the zonotile. Two \[OpenCurlyDoubleQuote]Archimedean\[CloseCurlyDoubleQuote] \
regions of tiles within the zonotile arise, when ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=6 and ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=4."
}], "Text"],

Cell["\<\
n=6;
a=2.0;
dist=Table[
\tIf[EvenQ[i],f=1,f=N[Sqrt[3]]];
\tN[f*Range[-a,a,.5]],
\t{i,n}];
lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Octagons and Squares", "Subsubsection"],

Cell["\<\
n=4;
a=2.0;
dist=Table[
\tIf[EvenQ[i],f=1,f=N[Sqrt[2]]];
\tN[f*Range[-a,a,.5]],
\t{i,n}];
lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Disguised Symmetry", "Subsection"],

Cell[TextData[{
 "This zonotile takes about a minute to develop. Since ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=12, the bounding zonogon is a regular 24-gon. However, 8-fold symmetry is \
embedded within the structure of the zonotile (and the arrangement of lines). \
Try changing the ",
 StyleBox["Mod[ i, 3 ]",
  FontWeight->"Bold"],
 " in the definition of ",
 StyleBox["dist",
  FontSlant->"Italic"],
 " below."
}], "Text"],

Cell["\<\
n=12;
a=1.25;
dist=Table[If[Mod[i,3]==0,f=1,f=N[Sqrt[3]]];
N[f*Range[-a,a,.5]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Stellation and Zonogonal Tilings, 2000", "Subsection"],

Cell[TextData[{
 "If the lines are chosen such that there are but ",
 StyleBox["n",
  FontSlant->"Italic"],
 " of them, like the produced sides of a regular ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon, then we obtain a core convex ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon surrounded by intersections marking the vertices of various \
stellations. These stellations may be regular star polygons or compounds of \
convex polygons. Associated with each such line set is a zonotile which may \
be regarded as a hidden-detail removed polar projection of an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-polar zonohedron, or as the \[OpenCurlyDoubleQuote]zonogonal completion\
\[CloseCurlyDoubleQuote] of the line set\[CloseCurlyQuote]s core convex ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon. A special ",
 StyleBox["zpolar",
  FontWeight->"Bold"],
 " function was cobbed together to pair the line arrangement with the \
zonotile. Note the one-to-one correspondence between line intersections and \
rhombs in the zonotiles."
}], "Text"],

Cell["zpolar[5]", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Expansions of Polar Zonohedra", "Subsection"],

Cell[TextData[{
 "In the middle 1980s, experiments with drawing \[OpenCurlyDoubleQuote]polar\
\[CloseCurlyDoubleQuote] projections of polar zonohedra, showed that the same \
suite of rhombs which composed the projection, could be added to its exterior \
in various ways, to close up another, larger bounding polygon. The simplest \
of the addition schemes gave what I came to call the \
\[OpenCurlyDoubleQuote]dodecahedral expansion\[CloseCurlyDoubleQuote] of \
polar zonohedra (because, when a physical model was made, there proved to be \
rhombic-dodecahedral ridges and valleys). To my surprise this same scheme of \
rhombic addition can be obtained using line arrangements. Using the ",
 StyleBox["zpolarexpand[ n]",
  FontWeight->"Bold"],
 " function below one can quickly review the line arrangements and induced \
dodecahedral expansions for ",
 StyleBox["n",
  FontWeight->"Bold"],
 " from 3 to 15.\n\nFirst, note how the sides of a regular ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon, produced, make a line arrangement which dualizes to the \
\[OpenCurlyDoubleQuote]polar projection\[CloseCurlyDoubleQuote] of an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-fold polar zonohedron (I call the projection of a polar zonohedron onto a \
plane orthogonal to its axis of ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-fold symmetry the \[OpenCurlyDoubleQuote]polar projection\
\[CloseCurlyDoubleQuote]). Here ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=9."
}], "Text"],

Cell["\<\
n=9;
zpolar[n]
zpolarexpand[n]\
\>", "Input"],

Cell[TextData[{
 "To explore other possibilities, and proceed in a more step-by-step manner, \
use the two code examples below. The essential idea of the line arrangements \
is as follows: If the lines are chosen such that there are but ",
 StyleBox["n",
  FontSlant->"Italic"],
 " of them, like the produced sides of a regular ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon, then we obtain a core convex ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon surrounded by intersections marking the vertices of various \
stellations. These stellations may be regular star polygons or compounds of \
convex polygons. Associated with each such line set is a zonotile which may \
be regarded as a hidden-detail removed polar projection of an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-polar zonohedron, or as the \[OpenCurlyDoubleQuote]zonogonal completion\
\[CloseCurlyDoubleQuote] of the line set\[CloseCurlyQuote]s core convex ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon. If we add a second set of lines parallel to each of the first ",
 StyleBox["n",
  FontSlant->"Italic"],
 ", and far enough away so as to be beyond the most distant points of \
intersection of the inner set, we obtain the first dodecahedral expansion.\n\n\
If we add a third and fourth or however many other sets, farther away yet, \
and beyond again the most distant previous points of intersection, we obtain \
the second, third, and so on, dodecahedral expansion of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-polar zonohedron. All these \[OpenCurlyDoubleQuote]dodecahedral expansions\
\[CloseCurlyDoubleQuote] are related to building up hypercubes of edge 2, 3, \
4, etc., from a hypercube of edge 1."
}], "Text"],

Cell[TextData[StyleBox["Second Dodecahedral Expansion for n=12",
 FontSize->24,
 FontWeight->"Bold"]], "Text"],

Cell["\<\
n=12;
dist={.5, 4, 15};
If[EvenQ[n],dist=Sort[Join[dist,-dist]] ];
If[ EvenQ[n], n=n/2];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];


(*display lines within suitable radius*)
Show[drawLines[lns, 30]];
zaq=zonotile[lns];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];


z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[StyleBox["Partly Perturbed Second Dodecahedral Expansion for \
n=13",
 FontSize->24,
 FontWeight->"Bold"]], "Text"],

Cell["\<\
n=13;
dist={.5, 5, 40};
If[EvenQ[n],dist=Sort[Join[dist,-dist]] ];
If[ EvenQ[n], n=n/2];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
If[j>2, dist[[j]]+=j];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];


(*display lines within suitable radius*)
Show[drawLines[lns, 35]];
zaq=zonotile[lns];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];


colorlist={RGBColor[1, 1, 0],RGBColor[1, 0, 0],RGBColor[0, 0, 1],
RGBColor[0.5, 0, 0],RGBColor[0.2, 0.2, 0.6],RGBColor[0.8, 0.4, 1.],
RGBColor[0.6, 0.8, 1.],RGBColor[0.6, 0.2, 0.2],RGBColor[0, 0, 0.8],
RGBColor[0, 0.6, 0.6],RGBColor[1., 0.6, 0],RGBColor[1., 0.8, 1.]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[StyleBox["Perturbed Third Dodecahedral Expansion for n=13",
 FontFamily->"Times",
 FontSize->24,
 FontWeight->"Bold"]], "Input"],

Cell["\<\
n=13;
dist={.5, 5, 35,222};
If[EvenQ[n],dist=Sort[Join[dist,-dist]] ];
If[ EvenQ[n], n=n/2];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
If[j>2, dist[[j]]+=j];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];


(*display lines within suitable radius*)
Show[drawLines[lns, 35]];
zaq=zonotile[lns];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];


colorlist={RGBColor[1, 1, 0],RGBColor[1, 0, 0],RGBColor[0, 0, 1],
RGBColor[0.5, 0, 0],RGBColor[0.2, 0.2, 0.6],RGBColor[0.8, 0.4, 1.],
RGBColor[0.6, 0.8, 1.],RGBColor[0.6, 0.2, 0.2],RGBColor[0, 0, 0.8],
RGBColor[0, 0.6, 0.6],RGBColor[1., 0.6, 0],RGBColor[1., 0.8, 1.]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 "Central 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon surrounded by rhombs"
}], "Subsection"],

Cell[TextData[{
 "An alternation in sign is applied to the line distances, which go from 0 to \
3 (or more). When ",
 StyleBox["n",
  FontSlant->"Italic"],
 " is odd, t",
 "he ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines through the origin give a regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon at the center of the zonotile, surrounded by rhombs."
}], "Text"],

Cell["\<\
n=7;
dist={0,1,2,3};
lns=Flatten[Table[
f=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], f*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 10]];\
\>", "Input"],

Cell["\<\
Create the zonotile and sort polygons by area; a randomized RGB coloring is \
applied.\
\>", "Text"],

Cell["\<\
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Central rhombs with higher zonogons at periphery", "Subsection"],

Cell[TextData[{
 "An alternation in sign is applied to the pairs of line distances, which are \
set to {-1,1+(N[2*Cos[Pi/",
 StyleBox["n",
  FontSlant->"Italic"],
 "]])}. When ",
 StyleBox["n",
  FontSlant->"Italic"],
 " is odd,",
 " ",
 StyleBox["n",
  FontSlant->"Italic"],
 " \[OpenCurlyDoubleQuote]higher\[CloseCurlyDoubleQuote] zonogons (usually \
octagons) arise near the periphery of the zonotile, with rhombs near the \
center.."
}], "Text"],

Cell["\<\
n=7;
dist={-1,1+(N[2*Cos[Pi/n]])}
lns=Flatten[Table[
f=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], f*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 15]];\
\>", "Input"],

Cell["\<\
Create the zonotile and sort polygons by area; a randomized RGB coloring is \
applied.\
\>", "Text"],

Cell["\<\
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Row of 2n-gons", "Subsection"],

Cell[TextData[{
 "These curious zonotiles arise for integers {",
 StyleBox["n, k",
  FontSlant->"Italic"],
 "}, ",
 StyleBox["n",
  FontSlant->"Italic"],
 ">=2, ",
 StyleBox["k",
  FontSlant->"Italic"],
 ">=1, in which ",
 StyleBox["k",
  FontSlant->"Italic"],
 " lines are taken perpendicular to each of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " unit vectors. A horizontal band of ",
 StyleBox["k",
  FontSlant->"Italic"],
 " regular 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons bisects the zonotile. This works to best effect for ",
 StyleBox["n",
  FontSlant->"Italic"],
 " odd."
}], "Text"],

Cell["\<\
n=7;(*number of directions*)
linenumber=4;(*number of lines in each set*)
lns1=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], j*Cos[i*Pi/n] }]],
{i,n},{j,linenumber}],1];
Print[\"There are \", Length[lns1],\" lines at first\"];

(*crude crude sort into cyclical order*)
lns=Sort[vunion[lns1], (#1[[1]]>#2[[1]])&];

Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 20]];


Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Row of 2n-gons II", "Subsection"],

Cell["\<\
n=5;
d=6;
dist=Table[If[Mod[i,2]==0, f=-1, f=N[((1+Sqrt[5])/2)] ];
N[f*Range[-d,d,1]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];

colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Ring of  Regular 2n-gons", "Subsection",
 Background->RGBColor[1, 1, 0]],

Cell[TextData[{
 "Added in late 2004. I especially like ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5, ",
 StyleBox["k",
  FontSlant->"Italic"],
 "=5; but by all means compare, say ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5, ",
 StyleBox["k",
  FontSlant->"Italic"],
 "=1, 2, 3, 4, 5, etc., with all due respect for the number of lines passed \
to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function. The 2*",
 StyleBox["n",
  FontSlant->"Italic"],
 "*",
 StyleBox["k",
  FontSlant->"Italic"],
 " 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gons divide the zonotile into a \[OpenCurlyDoubleQuote]flowery\
\[CloseCurlyDoubleQuote] interior and a \[OpenCurlyDoubleQuote]rhombic\
\[CloseCurlyDoubleQuote] exterior. A careful examination of the line \
arrangement (drag the graphic out larger, below) will show why the thirty \
regular decagons (in this example, ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5, ",
 StyleBox["k",
  FontSlant->"Italic"],
 "=3) make such a neat division of the zonotile into its flowery and rhombic \
kingdoms: only on or inside this boundary do all ",
 StyleBox["n",
  FontSlant->"Italic"],
 " directions come into play. Beyond the boundary, only subsets of the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " directions can be involved in intersections, until at last, any one \
direction can meet but one other, and then even these rare matings end, and \
then away go the lines into infinite space, never to meet again."
}], "Text"],

Cell["\<\
n=5;(*n symmetrical unit vectors*)
k=3;(*a ring of 2*n*k 2ngons arises in the zonotile*)
t=n*k;(*number of 2ngon in ring*)
dist=Table[ N[Cos[i*Pi/t] ], {i,0,t}]
lns=Flatten[Table[
sgn=If[ EvenQ[i], -1, 1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"]

(*display lines within suitable radius*)
Show[drawLines[lns, 5],Frame->True];\
\>", "Input"],

Cell["\<\
Timing[ Share[zaq=zonotile[lns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*Make a list of random colors of the proper length.*)
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input",
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["Ring of  Regular 2k-gons", "Subsection",
 Background->RGBColor[1, 1, 0]],

Cell[TextData[{
 "Added in late 2004. Much like the ",
 StyleBox["Ring of Regular 2n-gons",
  FontWeight->"Bold"],
 " subsection, above, except here we use divisors ",
 StyleBox["j",
  FontSlant->"Italic"],
 " of ",
 StyleBox["n",
  FontSlant->"Italic"],
 ", rather than multiples. A set of ",
 StyleBox["k=n/j",
  FontSlant->"Italic"],
 " independent vectors traces out, \[OpenCurlyDoubleQuote]determines,\
\[CloseCurlyDoubleQuote] a 2",
 StyleBox["k",
  FontSlant->"Italic"],
 "-gon. If the vectors are of equal magnitude and symmetrically disposed, the \
2",
 StyleBox["k",
  FontSlant->"Italic"],
 "-gon may be regular. In the example, twenty-four regular octagons lie on a \
ring. Set ",
 StyleBox["j",
  FontSlant->"Italic"],
 "=4, and twenty-four regular hexagons would form a ring; set ",
 StyleBox["j",
  FontSlant->"Italic"],
 "=2, and twenty-four regular dodecagons would arise."
}], "Text"],

Cell["\<\
n=12;(*n symmetrical unit vectors*)
j=3;
k=n/j;(*a ring of 2*n (2*n*k)-gons arises in the zonotile*)
dist=Table[ N[Cos[i*Pi/k] ], {i,0,k}]
lns=Flatten[Table[
sgn=If[ EvenQ[i], -1, 1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"]

(*display lines within suitable radius*)
Show[drawLines[lns, 5],Frame->True];\
\>", "Input"],

Cell["\<\
Timing[ Share[zaq=zonotile[lns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*Make a list of random colors of the proper length.*)
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input",
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["Stars and Hexagons", "Subsection",
 Background->RGBColor[1, 1, 0]],

Cell["\<\
This line arrangement gives a nice mixture of regular hexagons with stars of \
60-degree rhombs.\
\>", "Text"],

Cell["\<\
n=3;
dist={-8,-7,-5, -4, -2, -1, 1, 2, 4, 5, 7, 8};

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*simple colors*)
colorlist={
RGBColor[1,0,0],
RGBColor[0,0,.5]
};

If[Length[s]<=Length[colorlist],
xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];,
Print[\"Not enough colors!\"]
]\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Spiralia", "Subsection",
 Background->RGBColor[1, 1, 0]],

Cell["\<\
Here an attempt is made to make a line arrangement follow a spiral. A small \
amount of random offset is added to the distances.\
\>", "Text"],

Cell["\<\
n=12;
spi=4;
dist=Table[sgn=If[EvenQ[k],-1,1];
N[sgn*( Random[Real,{.01,.02}] + (i+(k-1)*n))],{i,n},{k,spi}]

lns=Flatten[Table[
Chop[N[ { Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] } ]],
{i,n}, {j, Length[dist[[i]]]}],1];

lns=fixLines[lns];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 50]];

Share[zaq=zonotile[lns]];
s=notextcolorSort[ zaq ];

(*Set up your own list of colors*)
colorlist1={
RGBColor[1,0,0],RGBColor[.3,.3,1],RGBColor[1,1,0],
RGBColor[0,0,1],RGBColor[1,.4,.4],RGBColor[.4,.4,.4],
RGBColor[.5,0,0],RGBColor[0,1,0]};

colorlist=If[Length[s]<=Length[colorlist1], colorlist1, Table[
RGBColor[Random[Real,{0,1}],Random[Real,{0,1}],Random[Real,{0,1}]],
{Length[s]}]];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Old and Odd Examples", "Section"],

Cell["\<\
Restless experimentation with line arrangements led to these odd and old \
examples.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Hexagonal Penrose", "Subsection"],

Cell["\<\
n=6;
dist=Table[If[i==4 || i==5, f=1, f=1.5 ];(*try 1.4, other numbers*)
N[f+Range[-2,2,1]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

colorlist={RGBColor[1,1,0],RGBColor[1,.5,.5],RGBColor[1,0,0],RGBColor[0,0,1]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Hexagonal Penrose 2", "Subsection"],

Cell["\<\
n=6;
dist=Table[If[i==1 || i==2, f=1, f=Sqrt[2] ];
N[(f)+Range[-1,1,.5]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

colorlist={RGBColor[1,1,0],RGBColor[.5,0,0],RGBColor[0,0,.75],RGBColor[.5,.5,\
1]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Hexagonal Penrose 3", "Subsection"],

Cell["\<\
n=12;
dist=Table[If[i==1 || i==2, f=1, f=Sqrt[2] ];
N[(f)+Range[-3,2,1]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

colorlist={RGBColor[1., 0, 0],RGBColor[1., 1., 0],RGBColor[0, 0, \
1.],RGBColor[0.4, 0.4, 0],RGBColor[0.2, 0.8, 0.6],RGBColor[0.8, 0.4, \
1.],RGBColor[0.6, 0.8, 1.],RGBColor[0.6, 0.2, 0.2],RGBColor[0, 0, \
0.8],RGBColor[0, 0.6, 0.6],RGBColor[1., 0.6, 0],RGBColor[1., 0.8, \
1.],RGBColor[0.2, 0.2, 0.8]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Hexagonal Penrose 4", "Subsection"],

Cell["\<\
n=12;
dist=Table[If[i==3 || i==4, f=1, f=Sqrt[3] ];
N[(f)+Range[-5,5,1]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i, 1,n,2}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

colorlist={RGBColor[1., 0, 0],RGBColor[1., 1., 0],RGBColor[0, 0, \
1.],RGBColor[0.4, 0.4, 0],RGBColor[0.2, 0.8, 0.6],RGBColor[0.8, 0.4, \
1.],RGBColor[0.6, 0.8, 1.],RGBColor[0.6, 0.2, 0.2],RGBColor[0, 0, \
0.8],RGBColor[0, 0.6, 0.6],RGBColor[1., 0.6, 0],RGBColor[1., 0.8, \
1.],RGBColor[0.2, 0.2, 0.8]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Disrupted Symmetry 1", "Subsection"],

Cell[TextData[{
 "Note red code. Try changing the ",
 StyleBox["Mod",
  FontWeight->"Bold"],
 " to 2 or 4 or 6. A somewhat remarkable hexagonal tiling arises."
}], "Text"],

Cell[TextData[{
 "n=12;\ndist=Table[ ",
 StyleBox["f=If[Mod[i,3]==0, 1, Cos[Pi/n] ]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nN[f*(Range[-1,1,1])],{i,n}];\n\nlns=Flatten[Table[\nChop[N[\n{ \
Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }\n]],\n{i,n}, {j, \
Length[dist[[1]]]}],1];\nPrint[\"There are \", Length[lns],\" lines \
altogether\"];\n\n(*draw the lines within some suitable radius*)\n\
Show[drawLines[lns, 10]];;\n\nShare[zaq=zonotile[lns]];\ns=colorSort[ zaq ];\n\
Print[\n\"There are \", a1=Map[Length[#]&, s],\n\" polygons, \", Plus@@a1,\" \
altogether, of areas \",\na2=Map[hullarea[First[#]]&, s]\n];\nPrint[\"The \
zonotile has total area of \",a1.a2,\", which is the sum of \",\n\
MapThread[Times,{a1,a2}]];\n\ncolorlist=Table[\n\tRGBColor[\n\t  \
Random[Real,{0,1}],\n\t  Random[Real,{0,1}],\n\t  Random[Real,{0,1}]],\n\
{Length[s]}];\n\nxaq=Graphics[\n\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],\
\n\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]\n\t];\n\
Show[xaq,\nBackground->GrayLevel[0],\nAspectRatio->Automatic];"
}], "Input"],

Cell["A chance to create a different random colorlist.", "Text"],

Cell["\<\
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Disrupted Symmetry 2", "Subsection"],

Cell["\<\
n=12;
d=4/2;
dist=Table[If[Mod[i-1,2]==0,f=-1,f=2];(*try Mod[i,3], Mod[i,4], etc.*)
N[f*Range[-d,d,1]],{i,n}];

lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n],
(*randomize line distances if away from center*)
If[Abs[ dist[[i,j]] ]>1, Random[Real,{-.1,.1}] + dist[[i,j]], dist[[i,j]] ] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Non-equilateral zonotiles", "Subsection"],

Cell["\<\
The distances of the lines, and thus the magnitudes of the vectors \
determining the zonotile, may be modified to give non-equilateral zonotiles.\
\>", "Text"],

Cell["\<\
n=5;
dist=Range[-2,2];
lns=Flatten[Table[
f=If[EvenQ[i],1,2];
f*Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 20]];\
\>", "Input"],

Cell["\<\
Create the zonotile and sort polygons by area; a randomized RGB coloring is \
applied.\
\>", "Text"],

Cell["\<\
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Non-equilateral zonotiles: gray strips", "Subsection"],

Cell["\<\
n=10;
factor=2;
r=5/2;
dist=Range[-r,r,1];
lns=Flatten[Table[
f=If[Mod[i,factor]==0,1,3];
f*Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], Random[Real,{-.2,.3}] + dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 20]];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];

(*Set up your own list of colors*)
colorlist={
GrayLevel[1],
GrayLevel[.8],
GrayLevel[.6],
GrayLevel[.4],
GrayLevel[.2],
RGBColor[1,0,0],
RGBColor[0,0,1],
RGBColor[.7,.7,1],
RGBColor[1,1,0],
RGBColor[0,0,.5],
RGBColor[.3,.3,.3],
RGBColor[.5,0,0]};

If[Length[s]<=Length[colorlist],
xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];,
Print[\"Not enough colors!\"]
]\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Non-equilateral zonotiles: gray hexagons", "Subsection"],

Cell["\<\
n=6;
dist=Table[If[i==3 || i==4, f=1, f=3/2 ];(*try 1.4, other numbers*)
N[f+Range[-3,2,1]],{i,n}];

lns=Flatten[Table[
f=If[Mod[i,2]==0,1,2];
f*
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];

colorlist={RGBColor[1,1,0],RGBColor[.3,.3,1],RGBColor[1,0,0],RGBColor[0,0,1],\
RGBColor[.5,0,0],RGBColor[.7,.7,.7]};

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Beyond Flatland", "Section"],

Cell[TextData[{
 "Also see ",
 StyleBox["Bitten Wieringa Roofs",
  FontWeight->"Bold"],
 " in the ",
 StyleBox["Bitten Zonotiles",
  FontWeight->"Bold"],
 " section."
}], "Text"],

Cell[CellGroupData[{

Cell["Lofting into the Third Dimension: Rhombic Roofs", "Subsection"],

Cell[TextData[{
 "When the sets of parallel lines are chosen such that no more than two lines \
intersect at any point, and only rhombs can arise, it is possible to \
\[OpenCurlyDoubleQuote]loft\[CloseCurlyDoubleQuote] the zonotile into three \
dimensions. After making the \[OpenCurlyDoubleQuote]sign vectors\
\[CloseCurlyDoubleQuote] we step through the list of lines, adding \
alternately positive and negative ",
 StyleBox["z",
  FontSlant->"Italic"],
 " coordinates. In the example below, ",
 StyleBox["z",
  FontSlant->"Italic"],
 "=.707. Spurious polygons arise around the edges of the zonotile, but these \
are stripped away by selecting only polygons of four sides (the rhombs). The \
method fails entirely if any \[OpenCurlyDoubleQuote]higher\
\[CloseCurlyDoubleQuote] zonogons (hexagons, octagons, etc.) arise within the \
zonotile.\n\nHere a Penrose-like tiling is created, for the 3D surface. This \
seems much like what has been called a ",
 StyleBox["Wieringa roof",
  FontSlant->"Italic"],
 ".\n\nTrying varying ",
 StyleBox["n",
  FontWeight->"Bold"],
 " and ",
 StyleBox["maxdist",
  FontWeight->"Bold"],
 " and the slope of the vectors, here ",
 StyleBox[".707",
  FontWeight->"Bold"],
 ", and also change ",
 StyleBox["Mod[ i - 1, k]",
  FontWeight->"Bold"],
 " (here ",
 StyleBox["k",
  FontWeight->"Bold"],
 "=2) to any of ",
 StyleBox["k",
  FontWeight->"Bold"],
 "=1, 2, 3, ..., ",
 StyleBox["n",
  FontWeight->"Bold"],
 ".\n\nIt is fruitful to settle upon an attractive set of lines, such as in \
the example, with ",
 StyleBox["n=5",
  FontWeight->"Bold"],
 ", ",
 StyleBox["maxdist=5",
  FontWeight->"Bold"],
 ", slope=",
 StyleBox[".707",
  FontWeight->"Bold"],
 ", and then divide the cell below at the comment reading \
\[OpenCurlyDoubleQuote]divide cell here ... .\[CloseCurlyDoubleQuote] Then \
one can experiment freely with changing the signs of the ",
 StyleBox["z",
  FontSlant->"Italic"],
 " coordinates, using ",
 StyleBox["Mod",
  FontWeight->"Bold"],
 " or any other scheme."
}], "Text"],

Cell[TextData[{
 StyleBox["n = 5; (*number of vectors*)\nmaxdist = 5; (* (2*maxdist+1) lines \
per vector *) ",
  FontColor->RGBColor[1, 0, 0]],
 "\ndist = Table[sgn=If[EvenQ[i],-1,1];\nN[ sgn* (Random[Real, {0.01, 0.02}] \
+ Range[-maxdist, maxdist, 1]) ],\n {i, n}]; \nlns = \
Flatten[Table[Chop[N[{Cos[i*(Pi/n)], Sin[i*(Pi/n)], dist[[i,j]]}]],\n  {i, \
n}, {j, Length[dist[[i]]]}], 1]; \nPrint[\"There are \", Length[lns], \" \
lines altogether\"]\nShow[drawLines[lns, 15]];\n\n\n(*divide cell here for \
comparison of sign effects*) \n(*create and display 3D zonotile*)\n\n(*from \
2D homogenous to 3D Cartesian, z = +/- .707*)\nlns2=Table[sgn=If[ ",
 StyleBox["Mod[i-1,2]==0",
  FontColor->RGBColor[1, 0, 0]],
 ",1,-1];\nJoin[lns[[i,{1,2}]],sgn*{",
 StyleBox[".707",
  FontColor->RGBColor[1, 0, 0]],
 "}], {i,Length[lns]}];\n\n\nShare[\n\n(*make list of sign vectors*)\n\
a=Table[\n  Table[\n    Table[\n      Sign[Chop[Det[ \
{lns[[i]],lns[[k]],lns[[j]]} ] ] ],\n    {i,Length[lns]}],\n  \
{j,k+1,Length[lns]}],\n{k,Length[lns]-1}];\n\nb=Union[Flatten[a,1]];\n\n\n\
(*find polygons, some degenerate*)\nzaq=Table[\npt={0,0,0};\nDo[ If[ \
b[[k,j]]==1,\n     rmoveto[pt, lns2[[j]] ],\n     rmoveto[pt, -lns2[[j]] ]\n  \
  ],\n{j,Length[lns]}];\n\nt1=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     \
rlineto[ pt,2*lns2[[j]] ]\n   ],\n   {j,Length[lns]}],{{_,_,_}..}];\n   \n\
t2=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     rlineto[ pt, 2*-lns2[[j]] ]\n   \
],\n   {j,Length[lns]}],{{_,_,_}..}];\n \ntoPoly[Join[t1,t2]],\n\
{k,1,Length[b]}]\n];\n\n(*discard degenerate polygons*)\n\
poly=Select[Cases[zaq,{{_,_,_},{_,_,_},{_,_,_}..},Infinity],\nLength[#]==4&];\
\nPrint[\"There are \",Length[poly],\" rhombs in the zonotile\"];\n\n\
(*display*)\nShow[Graphics3D[{EdgeForm[],Polygon /@ poly}],\n\
ViewPoint->2.5*unit[{0,0,2}],\nBoxed->False,\nPlotRange->All,\n\
Background->GrayLevel[0]];"
}], "Input"],

Cell[CellGroupData[{

Cell["Animation of 3D slope", "Subsubsection"],

Cell[TextData[{
 "Here a ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop is used to change the ",
 StyleBox["z",
  FontSlant->"Italic"],
 " coordinate or slope of the 3D vectors, going from -1 to 1 in steps of 0.2. \
",
 StyleBox["It is assumed that the input cell above has already been \
evaluated.",
  FontWeight->"Bold",
  FontSlant->"Italic"]
}], "Text"],

Cell[TextData[{
 "(*create animation of slope*)\nDo[\n\n(*from 2D homogenous to 3D Cartesian, \
z = +/- .707*)\nlns2=Table[sgn=If[ ",
 StyleBox["Mod[i-1,2]==0",
  FontColor->RGBColor[1, 0, 0]],
 ",1,-1];\nJoin[lns[[i,{1,2}]],sgn*{",
 StyleBox["slope",
  FontColor->RGBColor[1, 0, 0]],
 "}], {i,Length[lns]}];\n\n\nShare[\n\n(*make list of sign vectors*)\n\
a=Table[\n  Table[\n    Table[\n      Sign[Chop[Det[ \
{lns[[i]],lns[[k]],lns[[j]]} ] ] ],\n    {i,Length[lns]}],\n  \
{j,k+1,Length[lns]}],\n{k,Length[lns]-1}];\n\nb=Union[Flatten[a,1]];\n\n\n\
(*find polygons, some degenerate*)\nzaq=Table[\npt={0,0,0};\nDo[ If[ \
b[[k,j]]==1,\n     rmoveto[pt, lns2[[j]] ],\n     rmoveto[pt, -lns2[[j]] ]\n  \
  ],\n{j,Length[lns]}];\n\nt1=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     \
rlineto[ pt,2*lns2[[j]] ]\n   ],\n   {j,Length[lns]}],{{_,_,_}..}];\n   \n\
t2=Cases[\nTable[\n   If[ b[[k,j]]==0,\n     rlineto[ pt, 2*-lns2[[j]] ]\n   \
],\n   {j,Length[lns]}],{{_,_,_}..}];\n \ntoPoly[Join[t1,t2]],\n\
{k,1,Length[b]}]\n];\n\n(*discard degenerate polygons*)\n\
poly=Select[Cases[zaq,{{_,_,_},{_,_,_},{_,_,_}..},Infinity],\nLength[#]==4&];\
\n\n(*display*)\nShow[Graphics3D[{EdgeForm[],Polygon /@ poly}],\n\
ViewPoint->2.5*unit[{0,-1,2}],\nBoxed->False,\nPlotRange->All,\n\
Background->GrayLevel[0]],\n{slope,-1,1,.2}];"
}], "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Lofting II: Arrowed Rhombs", "Subsection"],

Cell[TextData[{
 "Can we make a true Weiringa roof from an arrowed-rhombus, perfect Penrose \
tiling? That is what is attempted here. In the subsection above, choice of \
which edges (vectors) have positive ",
 StyleBox["z",
  FontWeight->"Bold"],
 " and which negative, is not quite random, but might as well be. Here we \
match up the signs of the ",
 StyleBox["z",
  FontWeight->"Bold"],
 " coordinates with the signs of the grid offsets.",
 "\n\nLike so many examples in this notebook, this one requires evaluating \
the input cells in sequence, from top to bottom.\n\nA ",
 StyleBox["loft3D[ lns, k, dex, mag]",
  FontWeight->"Bold"],
 " function was contrived, which assumes that the tiling is rhombic, and that \
the five grids have an equal number of lines, and that two of the five offset \
signs are negative. It takes four inputs:\n\n1. ",
 StyleBox["lns",
  FontWeight->"Bold"],
 " is the raw list of lines in an arrangement. It is left global in the ",
 StyleBox["pentagrid",
  FontWeight->"Bold"],
 " function, for instance.\n2. ",
 StyleBox["k",
  FontWeight->"Bold"],
 " is the gridrange: before offset, the lines in a grid are at distances ",
 StyleBox["Range[ -k, k, 1]",
  FontWeight->"Bold"],
 ".\n3. ",
 StyleBox["dex",
  FontWeight->"Bold"],
 " is the indices into {1,2,3,4,5} of which two offsets are negative.\n4. ",
 StyleBox["mag",
  FontWeight->"Bold"],
 " is the single fixed non-negative magnitude of offset.\n\nThe ",
 StyleBox["loft3D",
  FontWeight->"Bold"],
 " function is found in the ",
 StyleBox["Grout",
  FontWeight->"Bold"],
 " subsection of the ",
 StyleBox["Initialization",
  FontWeight->"Bold"],
 " section.\n\nIn the particular example used here, a perfect Penrose tiling \
of Madonna motif is made and then lofted. For the Archangel motif, use",
 StyleBox[" ",
  FontWeight->"Bold"],
 StyleBox["pentagrid[ k, sgn, .39 ]",
  FontWeight->"Bold"],
 ". Note that below we have ",
 StyleBox["loft3D[ lns, k, dex, .49 ]",
  FontWeight->"Bold"],
 "; if we set the magnitude of ",
 StyleBox["z = 0.5",
  FontWeight->"Bold"],
 ", then all rhombs in the roof have the same shape (being equivalent to the \
faces of an ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5 polar zonohedron whose edges make the angle arc tan 2 to the axis of \
5-fold symmetry). Here we set ",
 StyleBox["z = 0.49",
  FontWeight->"Bold"],
 " so that the rhombs of the roof have two very slightly different shapes, \
and thus can be easily separated and colored."
}], "Text"],

Cell["\<\
k=5;
sgn={1, -1, 1, -1, 1};
dex=Flatten[Position[ sgn, -1]];
pentagrid[ k, sgn, .2 ](*leaves \"lns\" global*)

Show[ xaq3D=loft3D[lns, k, dex, .49],
ViewPoint->2.5*unit[{0,0,2}],
Boxed->False,
PlotRange->All,
Background->GrayLevel[0]];\
\>", "Input"],

Cell[TextData[{
 "Next we loft the plane tiling into 3D with ",
 StyleBox["z=0",
  FontWeight->"Bold"],
 ", translate the \[OpenCurlyDoubleQuote]roof\[CloseCurlyDoubleQuote] ten \
units into positive ",
 StyleBox["z",
  FontWeight->"Bold"],
 ", and color-sort both polygon lists."
}], "Text"],

Cell[TextData[{
 "colorlist={RGBColor[0,0,1],RGBColor[1,0,0],RGBColor[1,1,0]};(*set up a few \
colors*)\n\nrho2D=Select[Cases[zaq,{{_,_},{_,_},{_,_}..},Infinity],\n\
Length[#]==4&];\ntfloor=Table[ Map[ Join[#[[{1,2}]],{",
 StyleBox["0",
  FontColor->RGBColor[1, 0, 0]],
 "}]&, rho2D[[i]] ], {i,Length[rho2D]}];\n(*split the polygons into lists \
according to area*)\ns1=colorSort3D[tfloor];\n\ntroof=trans[Polygon /@ \
poly3D, {0,0,10}];(*translate roof up ten units*)\ns2=colorSort3D[troof];"
}], "Input"],

Cell["\<\
Now, apply colors to the tiles of floor and roof , display each, and display \
both together.\
\>", "Text"],

Cell[TextData[{
 "xaq1=Graphics3D[\n{EdgeForm[GrayLevel[0]],\n\tTable[ \
{SurfaceColor[colorlist[[i]],",
 StyleBox["GrayLevel[.5], 5", "Input"],
 " ],\n\t\tPolygon /@ s1[[ i ]]}, {i,Length[s1]}]\n}];\nShow[xaq1,\n\
LightSources -> \n   {\n   {{-1,0,2}, RGBColor[1, 1, 1]},\n   {{1,1,0}, \
RGBColor[1, 1, 1]}\n   },\nBoxed->False,\nBackground->GrayLevel[0],\n\
ViewPoint->2.25*unit[ {0,-1,2} ] ];\n\n\nxaq2=Graphics3D[\n\
{EdgeForm[GrayLevel[0]],\n\tTable[ {SurfaceColor[colorlist[[i]],",
 StyleBox["GrayLevel[.5], 5", "Input"],
 " ],\n\t\tPolygon /@ s2[[ i ]]}, {i,Length[s2]}]\n}];\nShow[xaq2,\n\
LightSources -> \n   {\n   (*{ {-1,1,1}, RGBColor[1, 1, 1] },*)\n   { \
{0,-1,1}, RGBColor[1, 1, 1] }\n   },\nBoxed->False,\n\
Background->GrayLevel[0],\nViewPoint->2.5*unit[ {0,0,3} ] ];\n\n\n\
Show[{xaq1,xaq2},\nLightSources -> \n   {\n   (*{{-1,0,2}, RGBColor[1, 1, \
1]},*)\n   { {0,1,1}, RGBColor[1, 1, 1] }\n   },\nBoxed->True,\nAxes->True,\n\
Background->GrayLevel[0],\nViewPoint->2.5*unit[ {.3,-3,2.5} ] ];"
}], "Input",
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["3D Expansions of Polar Zonohedra", "Subsection"],

Cell[TextData[{
 "Note the three distances, {1, 10, 100}, chosen so that the outer sets of \
lines are beyond all points of intersection of any inner sets of lines. A \
fourth distance might be 1000 (try adding this). We could calculate what \
would be needed, but this works up to n=20 for \
\[OpenCurlyDoubleQuote]dodecahedral\[CloseCurlyDoubleQuote] expansions of \
polar zonohedra. However, the expansions are not quite the same as I \
originally imagined, in fact, a bewildering variety arise. Use of ",
 StyleBox["RealTime3D",
  FontWeight->"Bold"],
 " helps to visualize the peculiar surfaces."
}], "Text"],

Cell["\<\
n=11;
dist={1, 10, 100};
If[EvenQ[n],dist=Sort[Join[dist,-dist]] ];
If[ EvenQ[n], n=n/2];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
(*If[j>1, dist[[j]]+=j];*)
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 20]];
(*create and display 3D zonotile*)

(*from 2D homogenous to 3D Cartesian, z = +/- .707*)
lns2=Table[f=If[ Mod[i,2]==0,1,-1];
Join[lns[[i,{1,2}]], f*{.5}], {i,Length[lns]}];


Share[

(*make list of sign vectors*)
a=Table[
  Table[
    Table[
      Sign[Chop[Det[ {lns[[i]],lns[[k]],lns[[j]]} ] ] ],
    {i,Length[lns]}],
  {j,k+1,Length[lns]}],
{k,Length[lns]-1}];

b=Union[Flatten[a,1]];


(*find polygons, some degenerate*)
zaq=Table[
pt={0,0,0};
Do[ If[ b[[k,j]]==1,
     rmoveto[pt, lns2[[j]] ],
     rmoveto[pt, -lns2[[j]] ]
    ],
{j,Length[lns]}];

t1=Cases[
Table[
   If[ b[[k,j]]==0,
     rlineto[ pt,2*lns2[[j]] ]
   ],
   {j,Length[lns]}],{{_,_,_}..}];
   
t2=Cases[
Table[
   If[ b[[k,j]]==0,
     rlineto[ pt, 2*-lns2[[j]] ]
   ],
   {j,Length[lns]}],{{_,_,_}..}];
 
toPoly[Join[t1,t2]],
{k,1,Length[b]}]
];

(*discard degenerate polygons*)
poly=Select[Cases[zaq,{{_,_,_},{_,_,_},{_,_,_}..},Infinity],
Length[#]==4&];
Print[\"There are \",Length[poly],\" rhombs in the zonotile\"];

(*display*)
Show[zaq=Graphics3D[Polygon /@ poly],
ViewPoint->2.5*unit[{0,0,2}],
Boxed->False,
PlotRange->All,
Background->GrayLevel[0]];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Bitten Zonotiles", "Section"],

Cell[CellGroupData[{

Cell["Mod Experiment: \[OpenCurlyDoubleQuote]Bitten\[CloseCurlyDoubleQuote] \
Zonotiles", "Subsection"],

Cell[CellGroupData[{

Cell["Discussion", "Subsubsection"],

Cell[TextData[{
 "These unusual zonotiles have a convoluted history. There are certain \
non-convex rhombic polyhedra I call ",
 StyleBox["k-armed spirallohedra",
  FontSlant->"Italic"],
 ", and when ",
 StyleBox["k",
  FontSlant->"Italic"],
 "=3 or ",
 StyleBox["k",
  FontSlant->"Italic"],
 "=4, these spirallohedra close-pack to fill space, much after the manner of \
cubes or rhombic dodecahedra, respectively. I experimented taking plane \
sections of packings of these two types of spirallohedra, and found special \
sections which induced tilings of the sectioning plane by congruent irregular \
non-convex polygons. These polygons had two or three shallow \
\[OpenCurlyDoubleQuote]bites\[CloseCurlyDoubleQuote] taken from them.\n\nAt \
almost the same time, while contriving strange new line arrangements for \
zonotiles, I stumbled upon the idea of setting the {x, y, ",
 StyleBox["distance",
  FontSlant->"Italic"],
 "} triples such that the distances were set to ",
 StyleBox["Mod[ i-1, kmod]",
  FontWeight->"Bold"],
 ", where ",
 StyleBox["kmod",
  FontWeight->"Bold"],
 " was some divisor of ",
 StyleBox["n",
  FontWeight->"Bold"],
 ", and ",
 StyleBox["i",
  FontWeight->"Bold"],
 " was the iterator in the ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " loop which creates the list of vectors. I noticed was that in some cases I \
obtained a zonotile with a neat little region of rhombs or mixed rhombs and \
hexagons, near its boundary, such that a smoothly curved bite could be taken \
out. I soon found how to make two such regions. Eventually I hit upon the \
following expression for the distance: ",
 StyleBox["Mod[i-1,kmod] - ((kmod-1)/2) } ]",
  FontWeight->"Bold"],
 ". Roughly speaking, this allows the creation of ",
 StyleBox["n/kmod",
  FontWeight->"Bold"],
 " exactly equal, adjacent, congruent regions along part of the periphery of \
the zonotile. The cases when two regions or three regions are removed closely \
resemble the \[OpenCurlyDoubleQuote]special sections\[CloseCurlyDoubleQuote] \
of the 3- and 4-armed spirallohedral arrays. The regions are convex and are \
bounded by series of edges corresponding to vectors taken in strict cyclic or \
anti-cyclic order; they are ",
 StyleBox["2kmod",
  FontWeight->"Bold"],
 "-gons, tiled by smaller zonogons. In some cases such a region is merely a \
rhomb or a hexagon.\n\nIn one subsection below, we force line intersections \
to obtain bites as pure ",
 StyleBox["2kmod",
  FontWeight->"Bold"],
 "-gons, rather than regions of rhombs, etc.",
 "\n\nSuppose the ",
 StyleBox["n/kmod",
  FontWeight->"Bold"],
 " regions are in fact removed (as they are in examples, below). It occurred \
to me that, much in the way that the resulting non-convex polygon might be \
called a \[OpenCurlyDoubleQuote]bitten\[CloseCurlyDoubleQuote] zonogon, so \
also the spirallohedra themselves might be thought of as \
\[OpenCurlyDoubleQuote]bitten\[CloseCurlyDoubleQuote] zonohedra\[LongDash]for \
they may be constructed from polar zonohedra (dissected in a special way into \
rhombic hexahedra) by subtracting congruent regions of those hexahedra.\n\nIf \
this analogy has any merit, it might well generalize to higher spaces, to a \
whole class of bitten zonotopes. However, that is very uncertain! What is \
certain is that, when the bites are two or three, and all equal, and affect \
one-half the periphery of the zonogon (zonotile, here), the bitten figure \
tiles the plane. Examples are found below.\n\nIt is fruitful to compare odd, \
singly-even, and doubly-even ",
 StyleBox["n",
  FontWeight->"Bold"],
 " in the following cell. A coloring-by-area algorithm s applied to help pick \
out the congruent regions; since the colors are chosen at random, \
re-evaluation will give a different set of colors, which may be more \
pleasing. These pairs of {",
 StyleBox["n, kmod",
  FontWeight->"Bold"],
 "} give representative results:\n\n1. {24, 8} gives a 48-gon tiled by \
rhombs. Three regions are centered upon the \[OpenCurlyDoubleQuote]top\
\[CloseCurlyDoubleQuote] of the zonotile.\n2. {12, 6} gives a 24-gon tiled by \
rhombs. Two regions.\n3. {18, 9} gives a 36-gon tiled mostly by rhombs, but \
with hexagons within the two regions.\n4. {25, 5} gives a 50-gon tiled by \
rhombs and many types of \
\[OpenCurlyDoubleQuote]higher\[CloseCurlyDoubleQuote] zonogons. Five regions.\
\n5. {20, 5} gives a 40-gon tiled by rhombs and many higher zonogons. Four \
regions.\n6. {20, 4} gives a 40-gon tiled by rhombs only. Five regions.\n\n\
The smaller \[OpenCurlyDoubleQuote]legal\[CloseCurlyDoubleQuote] pairs of \
integers {",
 StyleBox["n, kmod",
  FontWeight->"Bold"],
 "} are {4,2}, {6,2}, {6,3}, {8,2}, {8,4}, and {9,3}."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Example", "Subsubsection"],

Cell["\<\
(*the idea, get bilateral symmetry; n/kmod=number of subtractable regions*)
(*compare odd n, singly-even, and doubly-even n*)
n=12;(*bounded by a regular 2n-gon*)
kmod=4;(*the lines displaced mod kmod minus an offset*)
rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];

(*display line arrangement within suitable radius*)
radius=25;
Show[drawLines[lns, radius],
Frame->True];

Share[zaq=zonotile[lns]];

s=colorSort[ zaq ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[1],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*what about 'kmod'? loop through kmods*)
Do[
n=12;(*bounded by a regular 2n-gon*)

rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];

Share[zaq=zonotile[lns]];

s=notextcolorSort[ zaq ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[1],
PlotLabel->ToString[kmod],
AspectRatio->Automatic],
{kmod,2,2*n,1}];\
\>", "Input"],

Cell["\<\
In the cell below we loop through a variety of displacements, to see how the \
resulting zonotile changes.\
\>", "Text"],

Cell["\<\
(*change colorlist if desired*)
colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{100}];
\
\>", "Input"],

Cell["\<\
nudge=Random[Real,{.001,.002}];
(*what does the \"mod zonotile\" look like at different displacements?*)
n=24;
kmod=12;
Do[(*loop through displacements*)

rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-offset } ]],
{i,n}];

Share[zaq=zonotile[lns]];
s=notextcolorSort[ zaq ];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
PlotLabel->ToString[offset],
Background->GrayLevel[0],
AspectRatio->Automatic],

{offset,-12-nudge, 12-nudge,.5}];(*the displacements*)\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Two-Bite Tiles and Tilings", "Subsubsection"],

Cell[TextData[{
 "Now we actually take the bites from the zonotile. First, a two-bite \
zonotile is created. Possible values for ",
 StyleBox["n",
  FontSlant->"Italic"],
 " are 4, 6, 8, 10, etc."
}], "Text"],

Cell["\<\
(*the idea, get bilateral symmetry; n/kmod=number of subtractable regions*)
(*compare odd n, singly-even, and doubly-even n*)
n=12;(*bounded by a regular 2n-gon*)
kmod=n/2;(*the lines displaced mod kmod minus an offset*)
rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];

(*display line arrangement within suitable radius*)
radius=25;
Show[drawLines[lns, radius],
Frame->True];

Share[zaq=zonotile[lns]];
sca=Max[ First /@ Chop[ Flatten[zaq,1] ] ]; (*scale factor, to reduce to unit \
circumradius*)
zaq=Chop[ (1/sca)*zaq ]; (*scale down to unit circumradius*)\
\>", "Input"],

Cell["\<\
Length[zaq]
Length[ bite1=Chop[ Select[zaq, (mag[ {1,1}-Chop[cent[#]] ])<1&] ] ]
Length[ bite2=Chop[ Select[zaq, (mag[ {-1,1}-Chop[cent[#]] ])<1&] ] ]
Length[ bitten=Chop[ Select[zaq, 
((mag[ {-1,1}-Chop[cent[#]] ]>1) &&
(mag[ {1,1}-Chop[cent[#]] ]>1) )&] ] ]\
\>", "Input"],

Cell["\<\
s=colorSort[ bitten ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["Now, make the tiling.", "Text"],

Cell["\<\
t2={{1,1},{-1,1}};(*for two-bite zonogons*)
latticepoints=make2Darray[{5,5},t2];(*make lattice*)
region=Select[latticepoints, mag[#]<4&];(*select points near origin*)
pack=Map[trans[xaq,#]&, 1.05*region];(*exploded by writing \"1.05*region\"*)

Show[{pack},
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Three-Bite Tiles and Tilings", "Subsubsection"],

Cell[TextData[{
 "And here, a three-bite zonotile. Possible values for ",
 StyleBox["n",
  FontSlant->"Italic"],
 " are 6, 9, 12, 15, etc."
}], "Text"],

Cell["\<\
(*the idea, get bilateral symmetry; n/kmod=number of subtractable regions*)
(*compare odd n, singly-even, and doubly-even n*)
n=12;(*bounded by a regular 2n-gon*)
kmod=n/3;(*the lines displaced mod kmod minus an offset*)
rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];

(*display line arrangement within suitable radius*)
radius=25;
Show[drawLines[lns, radius],
Frame->True];

Share[zaq=zonotile[lns]];
sca=Max[ First /@ Chop[ Flatten[zaq,1] ] ]; (*scale factor, to reduce to unit \
circumradius*)
zaq=Chop[ (1/sca)*zaq ]; (*scale down to unit circumradius*)\
\>", "Input"],

Cell["\<\
Length[zaq]
Length[ bite1=Chop[ Select[zaq, (mag[ {1.5, Sqrt[3/4]}-Chop[cent[#]] ])<1&] ] ]
Length[ bite2=Chop[ Select[zaq, (mag[ {-1.5, Sqrt[3/4]}-Chop[cent[#]] ])<1&] \
] ]
Length[ bite3=Chop[ Select[zaq, (mag[ {0,Sqrt[3]}-Chop[cent[#]] ])<1&] ] ]
Length[ bitten=Chop[ Select[zaq, 
(
(mag[ {1.5, Sqrt[3/4]}-Chop[cent[#]] ]>1) &&
(mag[ {-1.5, Sqrt[3/4]}-Chop[cent[#]] ]>1) &&
(mag[ {0,Sqrt[3]}-Chop[cent[#]] ]>1)
)&] ] ]\
\>", "Input"],

Cell["\<\
s=colorSort[ bitten ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["Now, make the tiling.", "Text"],

Cell["\<\
t3={{1.5, Sqrt[3/4]},{0,Sqrt[3]}};(*for three-bite zonogons*)
latticepoints=make2Darray[{5,5},t3];(*make lattice*)
region=Select[latticepoints, mag[#]<4&];(*select points near origin*)
pack=Map[trans[xaq,#]&, 1.01*region];(*exploded by writing \"1.05*region\"*)

Show[{pack},
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Forcing Line Intersections: Bites as Single Zonogons", "Subsubsection"],

Cell["Create Lines Which Determine a k-bite Zonotile", "Text",
 FontSize->18],

Cell["\<\
(*the idea, get bilateral symmetry; n/kmod=number of subtractable regions*)
(*compare odd n, singly-even, and doubly-even n*)
n=24;(*bounded by a regular 2n-gon*)
bitenumber=3;(*set number of bites*)
kmod=n/bitenumber;(*the lines displaced mod kmod minus an offset*)
rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];


(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[lns, radius], redpts}];\
\>", "Input"],

Cell["Find \[OpenCurlyDoubleQuote]Representative\[CloseCurlyDoubleQuote] \
Points", "Text",
 FontSize->18],

Cell["\<\
(*method to obtain actual points*)
(*relies upon ordering of lines*)
chk=Map[{First[#], Last[#]}&, seldex=Partition[Range[n], kmod]]
pt=Table[
t=lns[[ chk[[k]] ]];
Chop[newinter2lines[ {t[[1]], t[[2]]} ]],
{k, Length[chk]}]
Length[pt]\
\>", "Input"],

Cell["Find Compensatory Distances and Re-form Line List", "Text",
 FontSize->18],

Cell["\<\
Do[
selpt=pt[[k]];
thelines=Map[#[[{1,2}]]&, lns[[ seldex[[k]] ]] ];
newlns=Map[ Join[#, {selpt.#}]&, thelines];(*join 'em up*)
lns=ReplacePart[lns, newlns, List /@ seldex[[k]], List /@ \
Range[Length[newlns]] ],
{k, Length[seldex]}];
(*display line arrangement within suitable radius*)
Show[newdrawLines[lns, radius],
Frame->True];

Share[zaq=zonotile[lns]];
sca=Max[ First /@ Chop[ Flatten[zaq,1] ] ]; (*scale factor, to reduce to unit \
circumradius*)
zaq=Chop[ (1/sca)*zaq ]; (*scale down to unit circumradius*)\
\>", "Input"],

Cell["Construct Zonotile", "Text",
 FontSize->18],

Cell["\<\
s=colorSort[ zaq ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Two- and Three-bite Tilings", "Subsection"],

Cell[TextData[{
 "I only know of two types of tilings of the plane using bitten zonogons, \
both lattice-type tilings, in which translations yield the positions of the \
equal tiles. Two-bite tilings mimic the tessellation of squares, while \
three-bite tilings mimic the tessellation of hexagons. In both cases the \
bitten zonogon has one half intact. Hence, for symmetry to obtain, the number \
of sides of one-half the zonogon must be either a multiple of two (for \
two-bite tilings) or three (for three-bite tilings). The dodecagon of twelve \
sides satisfies both requirements and is used in the example below.\n\nThe \
simplest two-bite zonogon is the octagon, and the simplest three-bite \
zonogon, the dodecagon. A \[OpenCurlyDoubleQuote]spurious\
\[CloseCurlyDoubleQuote] one-bite hexagon can be obtained which also tiles \
the plane; no example of this is offered, and it is trivial.\n\nTo delve a \
little deeper: a zonogon is a convex polygon with an even number of sides, \
and each side has an equal and opposite \[OpenCurlyDoubleQuote]counter-side,\
\[CloseCurlyDoubleQuote] and each vertex a counter-vertex. Regular polygons \
of an even number of sides are zonogons, for instance. Any zonogon may be \
said to be \[OpenCurlyDoubleQuote]determined by\[CloseCurlyDoubleQuote] a set \
of, say, ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors. Translations along these vectors \[OpenCurlyDoubleQuote]trace out\
\[CloseCurlyDoubleQuote] the zonogon, which has ",
 StyleBox["2n",
  FontSlant->"Italic"],
 " sides. Although below, in the code, ",
 StyleBox["n",
  FontSlant->"Italic"],
 " refers only to the total number of sides, it would be more proper, in the \
case of zonogons, to call them ",
 StyleBox["2n",
  FontSlant->"Italic"],
 "-gons.\n\nHence for a dodecagon of twelve sides, ",
 StyleBox["n",
  FontSlant->"Italic"],
 " would equal six. And we would say that for a two-bite zonogon (of the \
\[OpenCurlyDoubleQuote]special\[CloseCurlyDoubleQuote] type in which one-half \
remains intact, and the other half is symmetrically bitten), ",
 StyleBox["n",
  FontSlant->"Italic"],
 " must be a multiple of two. Hence a decagon cannot give a two-bite zonogon, \
for ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5. A square cannot either, for the smallest bite removes the entire square \
itself. We can obtain two-bite zonogons for ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=4, 6, 8, 10, etc. We can obtain three-bite zonogons for ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=6, 9, 12, etc.\n\nBelow, however, I use ",
 StyleBox["n",
  FontSlant->"Italic"],
 " to denote the total number of sides. Hence two-bite tilings arise for ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=8, 12, 16, 20, etc., and three-bite tilings for ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=12, 18, 24, 30, etc."
}], "Text"],

Cell["\<\
n=24; 
verts=Table[Chop[N[{Cos[2*i*Pi/n], Sin[2*i*Pi/n]}]],
{i, 0, n-1}];(*vertices of regular n-gon*)

sides=toedges[ verts ];(*the sides of the n-gon*)

v1=Map[ #[[2]]-#[[1]]&, sides];(*the vectors*)

(*show n-gon*)
Show[Graphics[ Line /@ sides],
Background->GrayLevel[1],
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[StyleBox["Two-Bite \[OpenCurlyDoubleQuote]Square\" Tilings",
 FontSize->18]], "Text"],

Cell["\<\
bitenumber=2;
Print[\"There will be \", bitenumber, \" bites.\"]

bitelength=(n/2)/2;(*this sets number of segments in a bite*)

biteproduct=bitelength*bitenumber;

ordered=Range[n];

p=Partition[ Take[ordered, biteproduct], bitelength];(*split ordered list \
into bites*)
q=Take[ordered, -(n-biteproduct)];
neworder=Flatten[
Join[ Reverse /@ p[[ Range[bitenumber] ]], q ]
];

pt={1,0};(*set first vertex, global \"pt\"*)
(*now use the new ordering of vectors to make bitten polygon*)
bitten=Table[rlineto[pt, v1[[ neworder[[i]] ]] ],
{i,n}];
Show[obj=Graphics[ Line /@ bitten ],
Background->GrayLevel[1],
Frame->True,
AspectRatio->Automatic];

obj=Graphics[ {RGBColor[.25,.25,1],Polygon [First /@ bitten]} ];

t2={{1,1},{-1,1}};(*for two-bite zonogons*)
latticepoints=make2Darray[{10,10},t2];(*make lattice*)
region=Select[latticepoints, mag[#]<5&];(*select points near origin*)
pack=Map[trans[obj,#]&, 1.05*region];(*exploded by writing \"1.05*region\"*)

Show[{pack},
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[StyleBox["Three-Bite \[OpenCurlyDoubleQuote]Hexagonal\" Tilings",
 FontSize->18]], "Text"],

Cell["\<\
bitenumber=3;
Print[\"There will be \", bitenumber, \" bites.\"]

bitelength=(n/2)/3;(*this sets number of segments in a bite*)

biteproduct=bitelength*bitenumber;

ordered=Range[n];

p=Partition[ Take[ordered, biteproduct], bitelength];(*split ordered list \
into bites*)
q=Take[ordered, -(n-biteproduct)];
neworder=Flatten[
Join[ Reverse /@ p[[ Range[bitenumber] ]], q ]
];

pt={1,0};(*set first vertex, global \"pt\"*)
(*now use the new ordering of vectors to make bitten polygon*)
bitten=Table[rlineto[pt, v1[[ neworder[[i]] ]] ],
{i,n}];
Show[obj=Graphics[ Line /@ bitten ],
Background->GrayLevel[1],
Frame->True,
AspectRatio->Automatic];

obj=Graphics[ {RGBColor[.25,.25,1],Polygon [First /@ bitten]} ];

t3={{1.5, Sqrt[3/4]},{0,Sqrt[3]}};(*for three-bite zonogons*)
latticepoints=make2Darray[{10,10},t3];(*make lattice*)
region=Select[latticepoints, mag[#]<5&];(*select points near origin*)
pack=Map[trans[obj,#]&, 1.05*region];(*exploded by writing \"1.05*region\"*)

Show[{pack},
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The General Equally-Bitten Polygon", "Subsection"],

Cell["\<\
n=11; 
verts=Table[Chop[N[{Cos[2*i*Pi/n], Sin[2*i*Pi/n]}]],
{i, 0, n-1}];(*vertices of regular n-gon*)

sides=toedges[ verts ];(*the sides of the n-gon*)

v1=Map[ #[[2]]-#[[1]]&, sides];(*the vectors*)

(*show n-gon*)
Show[Graphics[ Line /@ sides],
Background->GrayLevel[1],
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
bitelength=2;(*this sets number of segments in a bite*)
(*number of bites in a \"proper tile\" is (n/bitelength)/2*)

bitenumber=5;
Print[\"There will be \", bitenumber, \" bites.\"]

biteproduct=bitelength*bitenumber;

ordered=Range[n];

p=Partition[ Take[ordered, biteproduct], bitelength];(*split ordered list \
into bites*)
q=Take[ordered, -(n-biteproduct)];
neworder=Flatten[
Join[ Reverse /@ p[[ Range[bitenumber] ]], q ]
]

pt={1,0};(*set first vertex, global \"pt\"*)
(*now use the new ordering of vectors to make bitten polygon*)
bitten=Table[rlineto[pt, v1[[ neworder[[i]] ]] ],
{i,n}];
Show[obj=Graphics[ Line /@ bitten ],
Background->GrayLevel[1],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Bitten Wieringa Roofs", "Subsection"],

Cell[TextData[{
 "A rhombic tiling which has been lofted into the third dimension\[LongDash]a \
Wieringa Roof\[LongDash]is constructed, as a 3-bite zonotile, forcing \
intersections such that the bites are single, \[OpenCurlyDoubleQuote]higher\
\[CloseCurlyDoubleQuote] zonogons. The bites are removed, and the Bitten \
Wieringa Roof still tiles!\n\nActually, it is at times a happy accident that \
the \[OpenCurlyDoubleQuote]lofting\[CloseCurlyDoubleQuote] method discards \
higher zonogons, hence discards the bites. But when ",
 StyleBox["n",
  FontSlant->"Italic"],
 " is odd, other higher zonogons arise, not parts of the bites. These get \
discarded, too. Hence the example below works properly only for ",
 StyleBox["n",
  FontSlant->"Italic"],
 " a multiple of 6."
}], "Text"],

Cell["\<\
(*the idea, get bilateral symmetry; n/kmod=number of subtractable regions*)
(*compare odd n, singly-even, and doubly-even n*)
n=24;(*bounded by a regular 2n-gon*)
bitenumber=3;(*set number of bites*)
kmod=n/bitenumber;(*the lines displaced mod kmod minus an offset*)
rot=((Pi/2)+(Pi/(2*n)));(*rotate to vertical*)
lns=Table[
Chop[N[{ Cos[-rot+(i*Pi/n)], Sin[-rot+(i*Pi/n)], Mod[i-1,kmod]-((kmod-1)/2) } \
]],
{i,n}];

(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[drawLines[lns, radius],
Frame->True,
PlotRange->All];

(*method to obtain actual points*)
(*relies upon ordering of lines*)
chk=Map[{First[#], Last[#]}&, seldex=Partition[Range[n], kmod]];
pt=Table[
t=lns[[ chk[[k]] ]];
Chop[newinter2lines[ {t[[1]], t[[2]]} ]],
{k, Length[chk]}];


Do[
selpt=pt[[k]];
thelines=Map[#[[{1,2}]]&, lns[[ seldex[[k]] ]] ];
newlns=Map[ Join[#, {selpt.#}]&, thelines];(*join 'em up*)
lns=ReplacePart[lns, newlns, List /@ seldex[[k]], List /@ \
Range[Length[newlns]] ],
{k, Length[seldex]}];

Share[zaq=zonotile[lns]];
sca=Max[ First /@ Chop[ Flatten[zaq,1] ] ]; (*scale factor, to reduce to unit \
circumradius*)
zaq=Chop[ (1/sca)*zaq ]; (*scale down to unit circumradius*)

s=notextcolorSort[ zaq ];

colorlist=Table[RGBColor[Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]],{Length[s]}];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{colorlist[[k]],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell[TextData[{
 "OK, now we work our magic on the plane tiling. ",
 StyleBox["It is a great mystery to me that this shot in the dark actually \
scored.",
  FontSlant->"Italic"],
 " Of course it generalizes to higher space: the tiling of a zonohedron by \
smaller zonohedra might be gradually lofted into the fourth dimension, so \
that the zonohedral tiles occupied various sets of parallel 3-spaces, instead \
of all lying in one 3-space.\n\nHere the zonogons (only rhombs, under this \
method) suddenly occupy various planes, in parallel sets as it were, and the \
vectors which form their sides make the same angle, arc tangent Sqrt[2], with \
the ",
 StyleBox["z",
  FontSlant->"Italic"],
 " coordinate axis. Hence these vectors make the complement, arc tangent \
Sqrt[1/2], to the ",
 StyleBox["z",
  FontSlant->"Italic"],
 "=0 coordinate plane. The blue text, below, shows where the tangent of this \
angle may be changed. Try .2, .5, 1, and 2, for instance, in place of \
Sqrt[1/2].\n\nAlso change the red code at will; I think of ",
 StyleBox["Mod[ i-1, 2 ]",
  FontWeight->"Bold"],
 " as \[OpenCurlyDoubleQuote]regular,\[CloseCurlyDoubleQuote] so that is how \
the example stands. Try mod 1, 2, 3, and so on. The sign of the distance is \
affected."
}], "Text"],

Cell[TextData[{
 "(*from 2D homogenous to 3D Cartesian, z = +/- .5*)\nlns2=Table[sgn=If[ ",
 StyleBox["Mod[i-1,2]==0",
  FontColor->RGBColor[1, 0, 0]],
 ",-1,1];\nJoin[lns[[i,{1,2}]],",
 StyleBox["sgn*{N[Sqrt[1/2]]}",
  FontColor->RGBColor[0, 0, 1]],
 "], {i,Length[lns]}];\n\n\nShare[\n\n(*make list of sign vectors*)\na=Table[\
\n  Table[\n    Table[\n      Sign[Chop[Det[ {lns[[i]],lns[[k]],lns[[j]]} ] ] \
],\n    {i,Length[lns]}],\n  {j,k+1,Length[lns]}],\n{k,Length[lns]-1}];\n\n\
b=Union[Flatten[a,1]];\n\n\n(*find polygons, some degenerate*)\nzaq=Table[\n\
pt={0,0,0};\nDo[ If[ b[[k,j]]==1,\n     rmoveto[pt, -lns2[[j]] ],\n     \
rmoveto[pt, lns2[[j]] ]\n    ],\n{j,Length[lns]}];\n\nt1=Cases[\nTable[\n   \
If[ b[[k,j]]==0,\n     rlineto[ pt,2*-lns2[[j]] ]\n   ],\n   \
{j,Length[lns]}],{{_,_,_}..}];\n   \nt2=Cases[\nTable[\n   If[ b[[k,j]]==0,\n \
    rlineto[ pt, 2*lns2[[j]] ]\n   ],\n   {j,Length[lns]}],{{_,_,_}..}];\n \n\
toPoly[Join[t1,t2]],\n{k,1,Length[b]}]\n];\n\n(*discard degenerate polygons*)\
\npoly=Select[Cases[zaq,{{_,_,_},{_,_,_},{_,_,_}..},Infinity],\n\
Length[#]==4&];\nPrint[\"There are \",Length[poly],\" rhombs in the bitten \
zonotile\"];\n\nsca=(Sin[Pi/(2*n)]);(*scale down to unit circumradius*)\n\
xaq=Graphics3D[{EdgeForm[],Polygon /@ Chop[ sca*poly ]}];\n\n(*display*)\n\
Show[xaq,\nViewPoint->2.5*unit[{0,0,2}],\nBoxed->False,\nPlotRange->All,\n\
Background->GrayLevel[0]];\n"
}], "Input"],

Cell[TextData[{
 "We have lofted a ",
 StyleBox["bitten zonotile",
  FontWeight->"Bold"],
 " into the 3rd dimension. Now, we make the tiling. Quite a process leads to \
the critical one of the two translation vectors needed for 3-bite tilings. It \
is found and named ",
 StyleBox["v3",
  FontWeight->"Bold"],
 ". Then a 5-by-5 lattice is made, centered on the origin, using the two \
translation vectors, which are named ",
 StyleBox["t3",
  FontWeight->"Bold"],
 ". From these 25 lattice points are selected those less than 3 units from \
the origin. Feel free to experiment with dimensions of the lattice and radii \
of selection. I should find a better method, one which would serve for the \
2-bite tilings as well. This method seems to fail at times."
}], "Text"],

Cell["\<\
(*funky method to find translation vector*)
q=vunion[Select[Chop[Flatten[sca*poly,1]], mag[#[[{1,2}]]]>.99&]];(*periphery \
of 2n-gon*)
highy=Max[#[[2]]& /@ q];(*the largest positive y, height of highest horns*)
v1=q[[1]];(*left-most point*)
v2=First@Select[q, Abs[#[[2]]-highy]<.001&];(*leftmost of highest horns*)
v3=v1+v2;(*add them and, I hope, voila*)

t3={v3,{0,-Sqrt[3],0}};(*for three-bite zonogons*)
latticepoints=make2Darray[{5,5},t3];(*make lattice*)
region=Select[latticepoints, mag[#]<3&];(*select points near origin*)
pack=Map[trans[xaq,#]&, 1.0*region];(*exploded by writing \"1.05*region\"*)

Show[pack,
ViewPoint->2.5*unit[{0,0,1}],
Boxed->False,
Background->GrayLevel[0]];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Harmonices Stellarum", "Section"],

Cell["\<\
From methods evolved to find the intersection-point distances of stellation \
complexes, we obtain line arrangements with many points of multiple line \
intersections, and therefore, many higher zonogons in the zonotile.

Having obtained some symmetrical tiling with many higher zonogons, a random \
wind ruffles some of the lines, but not others.

Combine two line arrangements of different symmetries, one of which remains \
fixed, while the other slowly changes. Animate the sequence of zonotiles.\
\>", "Text"],

Cell[CellGroupData[{

Cell["The Double Stellation of Regular Polygons", "Subsection"],

Cell[TextData[{
 "Construct a regular ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon of inradius 1. ",
 "Produce its sides, and if ",
 StyleBox["n",
  FontSlant->"Italic"],
 ">4, the lines will intersect in one or more orbits of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " new points. We find the distances to these \[OpenCurlyDoubleQuote]kissing\
\[CloseCurlyDoubleQuote] points from the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines, and also the distances to the \[OpenCurlyDoubleQuote]missing\
\[CloseCurlyDoubleQuote] points, being points we choose from the intervals \
within, between, and beyond the kissing points. Joining the missing and \
kissing points, we obtain a spectrum of distances.\n\nA second set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines is now added to the first, choosing from some one of our missing or \
kissing points for the distance (inradius). If a missing point is used, only \
rhombs arise in the zonotile. If a kissing point if used, hexagons or \
octagons will arise within the zonotile, as well as rhombs. The last missing \
point, a distance beyond all others, gives the \
\[OpenCurlyDoubleQuote]dodecahedral expansion\[CloseCurlyDoubleQuote] \
pattern, as described elsewhere.\n\nClearly the process can be iterated; \
also, one might well use all the kissing points at once as distances, or all \
the missing points, or all of both. "
}], "Text"],

Cell["\<\
(*set n1, therefore, n*)
n1=7;
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-1,1},{1}];

lns=Flatten[Table[
sgn=If[EvenQ[i],-1,1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

(*find all points of intersection*)
pts=findpoints[ lns ];

Share[zaq=zonotile[lns]];
s=notextcolorSort[ zaq ];

If[ Length[s]<8,
colorlist={
RGBColor[1,.25,.25],
RGBColor[.25,.25,1],
RGBColor[0,1,0],
RGBColor[1,1,0],
RGBColor[0,0,.5],
RGBColor[.3,0,0],
RGBColor[.5,.5,.5]},
(*else*)
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}]
];(*end If*)

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}],
\tAspectRatio->Automatic];

spread=N[ 1/(Sin[Pi/n]) ];
radius=spread+Max[Map[mag[#]&, pts]];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
diagram1=Show[{mynewdrawLines[lns, GrayLevel[0], radius],redpts},
DisplayFunction->Identity];
Show[GraphicsArray[{diagram1,xaq}]];\
\>", "Input"],

Cell["Now, find the kissing points.", "Text"],

Cell["\<\
inrad=mag[ lns[[1,{1,2}]] ];(*all lines have equal inradii, \
distance-from-origin*)
rawlndist=Chop[Union[ Map[ (#.lns[[1,{1,2}]]/inrad)&, pts], SameTest->(#1 - \
#2 < .001 &)]];
(*now get rid of line(s) with distance<1*)
lndist=Select[rawlndist, #>=.9999&];
Print[\"The points lie on \", Length[circles=Union[ Map[ mag[#]&, pts], \
SameTest->(#1 - #2 < .001 &)]], \" concentric circles.\"];
maxrad=Max[circles];(*minimum PlotRange*)
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
bluecircles=Graphics[{RGBColor[0,0,1], Map[Circle[{0,0}, #]&, circles]}];

If[lndist=={},
Print[\"No further intersections.\"],
(*else*)
Print[\"There are \", Length[lndist], \" kissing point distances, which are \
\", lndist]
];

legal=Table[
testline=ReplacePart[ lns[[1]], lndist[[q]], 3];
tst=Graphics[{RGBColor[0,1,0],AbsoluteThickness[2],
Line[Join[
(*(vector * distance) +/- radius * orthogonal vector*)
{testline[[{1,2}]]*testline[[3]]-maxrad*First@NullSpace[ \
N[{testline[[{1,2}]]}] ]},
{testline[[{1,2}]]*testline[[3]]+maxrad*First@NullSpace[ \
N[{testline[[{1,2}]]}] ]}
] ]}
],
{q, Length[ lndist ]}];

Show[{legal,diagram1,redpts,bluecircles},
Frame->True,
AspectRatio->Automatic];\
\>", "Input"],

Cell["Find the missing points, join missing and kissing.", "Text"],

Cell["\<\
missing=Join[
\tTable[
\t\ta=lndist[[k]];
\t\tb=lndist[[k+1]];
\t\ta + ((b-a)/2) + Random[Real, {-((b-a)/20),((b-a)/20)}],
\t{k,Length[lndist]-1}],
{Last@lndist + Random[Real, {.25,.5}]}
]

kissing=Select[lndist, #>1.000001&]

alldist=Sort[ Join[missing,kissing] ]\
\>", "Input"],

Cell["\<\
Create a series of zonotiles, for each missing and kissing point in turn.\
\>", "Text"],

Cell["\<\
alltiles=Table[

dist=If[EvenQ[n1],Sort[Union[{-alldist[[q]],-1,1,alldist[[q]]}]], \
Sort[{1,alldist[[q]]}] ];

bothlns=Flatten[Table[
sgn=If[EvenQ[i],-1,1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

Share[zaq=zonotile[bothlns]];
s=notextcolorSort[ zaq ];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
testline=ReplacePart[ lns[[1]], alldist[[q]], 3];
rad=maxrad;
tst=Graphics[{RGBColor[0,1,0],AbsoluteThickness[2],
Line[Join[
(*(vector * distance) +/- radius * orthogonal vector*)
{testline[[{1,2}]]*testline[[3]]-rad*First@NullSpace[ N[{testline[[{1,2}]]}] \
]},
{testline[[{1,2}]]*testline[[3]]+rad*First@NullSpace[ N[{testline[[{1,2}]]}] ]}
] ]}
];
zaq1=Show[{tst,diagram1,redpts},AspectRatio->Automatic,DisplayFunction->\
Identity];
zaq2=Show[xaq,DisplayFunction->Identity];\t
Show[GraphicsArray[{zaq1,zaq2},GraphicsSpacing->0],
PlotLabel->If[OddQ[q],\"Missing Point\", \"Kissing Point\"]],
{q, Length[alldist]} ];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Holy Grail of Higher Zonogons", "Subsection"],

Cell[TextData[{
 "Here the methods used to find intersection distances in a stellation \
complex are applied again, in the example, to the stellation complex of a \
regular decagon. Note that to create this complex, we set ",
 StyleBox["n",
  FontSlant->"Italic"],
 "=5; for each vector, one perpendicular line is at distance 1, another at \
distance -1, ten lines altogether. The zonotile, not displayed, is a decagon \
of edge 2 composed by forty rhombs.  \nFifteen distances are found, and all \
fifteen are used with each of the five vectors, to construct a second line \
arrangement, and the corresponding zonotile. A plethora of \
\[OpenCurlyDoubleQuote]higher\[CloseCurlyDoubleQuote] zonogons arise in the \
tiling, including many decagons, each determined by the intersection of five \
lines.\n\nIt is intended that three blocks of code be evaluated in turn:\n\n\
1. Create initial line arrangement, find points of intersection, and \
distances from the origin, perpendicular to line 1.\n2. Create and display \
the new line arrangement, using all distances found.\n3. Construct the \
zonotile.\n\nFeel free to experiment, by changing ",
 StyleBox["n",
  FontSlant->"Italic"],
 " and the initial distance(s). But have a care: it is all too easy to end up \
with hundreds of lines, and on my computer, that means quite a long wait, for \
both the discovery of new intersection points (a step which may be deleted), \
and much more so, for the construction of the zonotile. In practice I rarely \
ever use an arrangement of more than 80 lines. Hence, where below I have ",
 StyleBox["dist=ptdist;(*the new distances*)",
  FontWeight->"Bold"],
 ", and knowing that I will end up with ",
 StyleBox["n*Length[ dist ]",
  FontWeight->"Bold"],
 " lines in total, I will use some device such as ",
 StyleBox["dist= Select[ ptdist,  Abs[ # ] <2 &]",
  FontWeight->"Bold"],
 ", so that the product of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " and the number of distances is less than one hundred."
}], "Text"],

Cell[CellGroupData[{

Cell["1. The initial line arrangement", "Subsubsection"],

Cell["\<\
(*create the initial line arrangement*)
n=5;
dist={-1,1};

lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[lns, radius], redpts}];

(*express the points of intersection as distances from the origin*)
ptdist=Chop[Union[ Map[ (#.lns[[1,{1,2}]])&, pts], SameTest->(#1 - #2 < .001 \
&)]]
Print[Length[ptdist],\" distances were found.\"];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["2. The new line arrangement", "Subsubsection"],

Cell["\<\
newdist=ptdist;(*the new distances*)
newlns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], newdist[[j]] }]],
{i,n},{j, Length[newdist]}],1];
Print[\"There are \", Length[newlns],\" lines altogether\"];

(*find all new points of intersection; optional*)
pts=findpoints[ newlns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[newlns, radius], redpts}];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["3. The zonotile", "Subsubsection"],

Cell["\<\
Timing[ Share[zaq=zonotile[newlns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["An Iterated Path to More and More and More Higher Zonogons", \
"Subsection"],

Cell["\<\
Here too we begin with a stellation complex, that of a regular pentagon. All \
points of intersection are found, and their signed distances from the origin, \
measured perpendicular to the first line of the complex (arrangement). A new \
line arrangement is formed, its zonotile created, and then once again we find \
the signed distances. These in turn give a third arrangement, of one hundred \
lines. The zonotile is duly created. The process might continue, with enough \
RAM and time.\
\>", "Text"],

Cell[CellGroupData[{

Cell["1. The initial line arrangement", "Subsubsection"],

Cell["\<\
(*create the initial line arrangement*)
(*set n1, therefore, n*)
n1=5;
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-1,1},{1}];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[lns, radius], redpts}];

(*express the points of intersection as distances from the origin*)
ptdist=Chop[Union[ Map[ (#.lns[[1,{1,2}]])&, pts], SameTest->(#1 - #2 < .001 \
&)]]
Print[Length[ptdist],\" distances were found.\"];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["2. The new line arrangement", "Subsubsection"],

Cell["\<\
Using the distances found, we make a new arrangement, adhering to the \
back-and-forth alternation of sign used above to make a stellation complex.\
\>", "Text"],

Cell["\<\
newdist=ptdist;(*the new distances*)
newlns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*newdist[[j]] }]],
{i,n},{j, Length[newdist]}],1];
Print[\"There are \", Length[newlns],\" lines altogether\"];

(*find all new points of intersection; optional*)
pts=findpoints[ newlns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[newlns, radius], redpts}];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["3. The zonotile", "Subsubsection"],

Cell["\<\
Timing[ Share[zaq=zonotile[newlns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["\<\
4. Iteration: find new distances, make new line arrangement, create zonotile\
\>", "Subsubsection"],

Cell[TextData[{
 "Here we find all the intersection distances in the second line arrangement, \
and use these to construct a third set of lines. To save time, these lines \
are not displayed. These are passed to the ",
 StyleBox["zonotile",
  FontWeight->"Bold"],
 " function. In the example provided here, this third arrangement contains \
100 lines; it takes a minute or so to build the zonotile, on my computer. \
Clearly the iteration could continue. The code is split into two sections, so \
that one can avoid creating the zonotile, if too many lines have arisen. On \
my computer, I only rarely use arrangements of as many as 100 lines, and \
never as many as 200."
}], "Text"],

Cell["\<\
(*express the points of intersection as distances from the origin*)
ptdist=Chop[Union[ Map[ (#.lns[[1,{1,2}]])&, pts], SameTest->(#1 - #2 < .001 \
&)]]
Print[Length[ptdist],\" distances were found.\"];
Print[\"Hence \", n*Length[ptdist],\" lines will arise in the new \
arrangement.\"];

newdist=ptdist;(*the new distances*)
newlns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*newdist[[j]] }]],
{i,n},{j, Length[newdist]}],1];
Print[\"There are \", Length[newlns],\" lines altogether\"];\
\>", "Input"],

Cell["\<\
Timing[ Share[zaq=zonotile[newlns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Random Wind", "Subsection"],

Cell[TextData[{
 "We return to the same example as above: having constructed the stellation \
complex of a regular decagon, we find the distances of points of \
intersection, and use these to make a new line arrangement.\n\nThere are ",
 StyleBox["j",
  FontSlant->"Italic"],
 "=15 distances, the eighth being zero; the seven less than zero are the \
negatives of the seven greater than zero. We \[OpenCurlyDoubleQuote]perturb\
\[CloseCurlyDoubleQuote] the arrangement by adding small random real numbers \
to the first five distances. Within the ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " used to make the new lines, we have ",
 StyleBox["If[ j<6, Random[Real,{-.1,.1}]+dist[[j]],  dist[[j]]  ]",
  FontWeight->"Bold"],
 ".\n\nThe resulting tilings verge upon the aperiodicity of the classic \
Penrose tilings, but include some \[OpenCurlyDoubleQuote]higher\
\[CloseCurlyDoubleQuote] zonogons. It is somewhat as though we had placed 75 \
jackstraws, five sets of fifteen, ever so carefully, so as to maximize the \
number of jackstraws crossing at various points. Then a \
\[OpenCurlyDoubleQuote]random wind\[CloseCurlyDoubleQuote] ruffles some of \
the straws, but not others.\n\nIt is intended that three blocks of code be \
evaluated in turn:\n\n1. Create initial line arrangement, find points of \
intersection, and distances from the origin, parallel to line 1.\n2. Create \
the new line arrangement, using all distances found, and randomizing some of \
these.\n3. Construct the zonotile."
}], "Text"],

Cell[CellGroupData[{

Cell["1. The initial line arrangement", "Subsubsection"],

Cell["\<\
(*create the initial line arrangement*)
n=5;
dist={-1,1};

lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[lns, radius], redpts}];

(*express the points of intersection as distances from the origin*)
inrad=mag[ lns[[1,{1,2}]] ];
ptdist=Chop[Union[ Map[ (#.lns[[1,{1,2}]]/inrad)&, pts], SameTest->(#1 - #2 < \
.001 &)]]
Print[Length[ptdist],\" distances were found.\"];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["2. The new line arrangement, with random displacements", "Subsubsection"],

Cell[TextData[{
 "Note red code; of all ",
 StyleBox["j",
  FontWeight->"Bold"],
 " distances, the first five are randomized. Many other such schemes can be \
used to randomize subsets of the lines."
}], "Text"],

Cell[TextData[{
 "dist=ptdist;(*the new distances*)\nnewlns=Flatten[Table[\nChop[N[{ \
Cos[i*Pi/n], Sin[i*Pi/n], If[",
 StyleBox["j<6",
  FontColor->RGBColor[1, 0, 0]],
 ",Random[Real,{-.1,.1}]+dist[[j]], dist[[j]] ] }]],\n{i,n},{j, \
Length[dist]}],1];\nPrint[\"There are \", Length[newlns],\" lines \
altogether\"];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["3. The randomized zonotile", "Subsubsection"],

Cell["\<\
Timing[ Share[zaq=zonotile[newlns]] ][[1]]
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]},
\tAspectRatio->Automatic];
\t
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Mixing Stars and Conjuring Shadows", "Subsection"],

Cell["\<\
Suppose one line arrangement gives a periodic tiling of regular octagons and \
squares, while another gives a Penrose tiling of 36- and 72-degree rhombs. \
One partakes of a tesseractic tessellation of tesseracts, the other, of a \
packing of 5-cubes.

Now let the more central lines in the Penrose arrangement be removed, and \
superimpose the two arrangements. A patch of octagons and squares \
\[OpenCurlyDoubleQuote]shines through\[CloseCurlyDoubleQuote] a hole.

But a picture is better than words.\
\>", "Text"],

Cell[CellGroupData[{

Cell["1. Make Penrose Arrangement", "Subsubsection"],

Cell["\<\
(*Penrose lines*)
n=5;(*set n*)
y1=Sort[ N[-1*((1+1/Floor[n/2])+Range[ Floor[n/2] ]) \
]/Sqrt[ri=Random[Real,{17,24}] ] ];
y2=N[ Range[ Ceiling[n/2] ] ]/Sqrt[ri ];
y=Sort[ If[EvenQ[n], Join[y1, -y1], Join[y1,y2] ] ];
y=y[[ scramble[n] ]];(*the offsets*)

gridlines=Range[3,6,1 ];(*inradius*)
dist=Table[
  N[ y[[i]]+gridlines ],{i,n}];


lns1=Flatten[
      Table[
sgn=If[EvenQ[i], 1,-1];
Chop[N[{Cos[i*Pi/n],Sin[i*Pi/n], sgn*dist[[i,j]]}]],{i,n},{j,
          Length[dist[[i]]]}],1];

Print[\"There are \",Length[lns1],\" lines altogether\"]

(*display lines within suitable radius*)
Show[drawLines[lns1, 10]];

colorlist={RGBColor[1., 0, 0],RGBColor[.4, .4, 1.],RGBColor[1., 1., \
0],RGBColor[0.4, 0.4, 0],RGBColor[0.2, 0.8, 0.6],RGBColor[0.8, 0.4, \
1.],GrayLevel[.5],RGBColor[0, 0, 1.],RGBColor[0.6, 0.2, 0.2],RGBColor[0, 0, \
0.8],RGBColor[0, 0.6, 0.6],RGBColor[1., 0.6, 0],RGBColor[1., 0.8, \
1.],RGBColor[0.2, 0.2, 0.8],GrayLevel[1]};

Timing[ Share[zaq=zonotile[lns1]] ][[1]]
s=colorSort[ zaq ];
Print[
    \"There are \", a1=Map[Length[#]&, s],
    \" polygons, \", Plus@@a1,\" altogether, of areas \",
    a2=Map[hullarea[First[#]]&, s]
    ];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
    MapThread[Times,{a1,a2}]];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["2. Make Octagon-Square Arrangement", "Subsubsection"],

Cell["\<\
n=4;
a=2;
dist=Table[
\tIf[EvenQ[i],f=1,f=N[Sqrt[2]]];
\tN[f*Range[-a,a,1]],
\t{i,n}];
lns2=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns2],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns2, 10]];;

Share[zaq=zonotile[lns2]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["3. Combine Line Arrangements", "Subsubsection"],

Cell["\<\
(*crude crude sort into cyclical order*)
lns=Sort[ Union[lns1,lns2], (#1[[1]]>#2[[1]])&];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];

Timing[ Share[zaq=zonotile[lns]] ][[1]]
s=colorSort[ zaq ];
Print[
    \"There are \", a1=Map[Length[#]&, s],
    \" polygons, \", Plus@@a1,\" altogether, of areas \",
    a2=Map[hullarea[First[#]]&, s]
    ];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
    MapThread[Times,{a1,a2}]];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["4. Open the Window", "Subsubsection"],

Cell[TextData[{
 "It is fun to experiment. One might make a hole in the octagon-square \
arrangement, and let the Penrose rhombs occupy center stage, for instance. \
Here we vary the size of the hole opened into the ",
 StyleBox["Penrose",
  FontSlant->"Italic"],
 " arrangement, through which a fixed octagon-square arrangement shines \
through. A ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop takes the variable ",
 StyleBox["radius",
  FontWeight->"Bold"],
 " from 0 to 11, and for each ",
 StyleBox["radius",
  FontWeight->"Bold"],
 " we put lines at distances ",
 StyleBox["radius, radius+1, radius+2, radius+3",
  FontWeight->"Bold"],
 ".\n\nOne can animate the series of images. Try letting ",
 StyleBox["radius",
  FontWeight->"Bold"],
 " go from -12 to 9 in steps of .5; begin animation by double-clicking on one \
of the resulting images."
}], "Text"],

Cell[TextData[{
 "(*a list of 25 random colors*)\ncolorlist=Table[\n\tRGBColor[\n\t  \
Random[Real,{0,1}],\n\t  Random[Real,{0,1}],\n\t  Random[Real,{0,1}]],\n\
{25}];\n",
 "\n",
 "(*the fixed octagon-square arrangement*)\nn=4;a=2;\ndist=Table[\n\t\
If[EvenQ[i],f=1,f=N[Sqrt[2]]];\n\tN[f*Range[-a,a,1]],\n\t{i,n}];\n\
lns2=Flatten[Table[\nChop[N[\n{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }\n]],\n\
{i,n}, {j, Length[dist[[1]]]}],1];\n\n(*reset n*)\nn=5;\ny1=Sort[ \
N[-1*((1+1/Floor[n/2])+Range[ Floor[n/2] ]) ]/Sqrt[ri=Random[Real,{17,24}] ] \
];\ny2=N[ Range[ Ceiling[n/2] ] ]/Sqrt[ri ];\ny=Sort[ If[EvenQ[n], Join[y1, \
-y1], Join[y1,y2] ] ];\ny=y[[ scramble[n] ]];(*the offsets*)\n\n(*And Now At \
Last*)\n(*Iterate from no hole (",
 StyleBox["radius",
  FontWeight->"Bold"],
 "=0) to a large hole (",
 StyleBox["radius",
  FontWeight->"Bold"],
 "=10)*)\nDo[\ngridlines=Range[",
 StyleBox["radius",
  FontWeight->"Bold"],
 ",",
 StyleBox["radius",
  FontWeight->"Bold"],
 "+3,1 ];\ndist=Table[\n  N[y[[i]] + gridlines ],{i,n}];\n\n\nlns1=Flatten[\n \
     Table[\nsgn=If[EvenQ[i], 1,-1];\nChop[N[{Cos[i*Pi/n],Sin[i*Pi/n], \
sgn*dist[[i,j]]}]],{i,n},{j,\n          Length[dist[[i]]]}],1];\n\nlns=Sort[ \
Union[lns1,lns2], (#1[[1]]>#2[[1]])&];\n\nzaq=zonotile[ lns ];\n\
s=notextcolorSort[ zaq ];\n\nxaq=Graphics[\n\tTable[ {colorlist[[i]],Polygon \
/@ s[[ i ]],\n\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, \
{i,Length[s]}]\n\t];\nShow[xaq,\nBackground->GrayLevel[0],\n\
AspectRatio->Automatic],\n{radius,0,11,1}];(*try -12 to 9 step .5*)"
}], "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Rose Windows Within Symmetrical Gray  Shadows", "Subsection"],

Cell[TextData[{
 "Let ",
 StyleBox["n",
  FontSlant->"Italic"],
 " be odd, and ",
 "let the lines be parallel to the sides produced of a regular ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon, and let the ",
 StyleBox["k",
  FontSlant->"Italic"],
 " distances be, say, {0, 5, 10, 20} at first, but let them be offset \
slightly by random real numbers. The zonotile is bounded by a larger 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon of edge=4, and at its center is another 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon of edge=1. This inner one is split away and given RGB colors, while \
all the rest of the zonotile has shades of gray.\n\nThe proportions of the \
small random offsets to the larger pattern of the lines are such that the \
inner 2",
 StyleBox["n",
  FontSlant->"Italic"],
 "-gon is tiled randomly and erratically, while the outer region remains \
fixed. This can be seen by using an iterator like \[OpenCurlyDoubleQuote]5\
\[CloseCurlyDoubleQuote] in the ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop below."
}], "Text"],

Cell["\<\
(*Set up your own list of colors*)
colorlist1={
RGBColor[1,1,0],RGBColor[0,0,1],RGBColor[.7,.7,1],
RGBColor[1,0,0],RGBColor[0,0,.5],RGBColor[.3,.3,.3],
RGBColor[.5,0,0],RGBColor[0,1,0]};

colorlist2={
GrayLevel[.9],GrayLevel[.6],GrayLevel[.3],
GrayLevel[.8],GrayLevel[.5],GrayLevel[.2],
GrayLevel[.7],GrayLevel[.4],GrayLevel[.1]
};

(*optional random greys*)
(*colorlist2=Table[GrayLevel[ Random[Real,{0,1}] ],{20}];*)

Do[
n1=11;
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-20,-10,0,10,20},{0,5,10,20}];
kdist=Length[dist];
lns1=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n],  Random[Real,{-.001,.001}]+sgn*dist[[j]] \
}]],
{i,0,n-1},{j, Length[dist]}],1];

Share[zaq=zonotile[lns1] ];

(*now split into colored inner 2n-gon and grey outer region*)
{c1,c2}=tilesplit[zaq,kdist];(*split into colored inner 2n-gon and grey outer \
region*)

s1=notextcolorSort[ c1 ];
s2=notextcolorSort[ c2 ];

xaq1=Graphics[
\tTable[ {colorlist1[[i]],Polygon /@ s1[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s1[[i]] ]}, {i,Length[s1]}]
\t];

xaq2=Graphics[
\tTable[ {colorlist2[[i]],Polygon /@ s2[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s2[[i]] ]}, {i,Length[s2]}]
\t];
Show[{xaq1,xaq2},
Background->GrayLevel[0],
AspectRatio->Automatic],
{1}];(*Do loop iterator*)\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Lines on the Run: Animated Transformations of Shadows", "Subsection"],

Cell[TextData[{
 "Suppose that, as in the \[OpenCurlyDoubleQuote]Iterated Path\
\[CloseCurlyDoubleQuote] subsection above, we create the stellation complex \
of a pentagon, extract kissing points, and use them all to make a second set \
of twenty-five lines, with multiple intersections. These lines determine a \
\[OpenCurlyDoubleQuote]sufficiently complicated\[CloseCurlyDoubleQuote] \
zonotile.\n\nNow let four of the five line-sets remain fixed, but translate \
the fifth set in tiny steps across the fixed lines. Let the fifth set begin \
its run to the right of the rightmost, and finish to the left of the \
leftmost, points of intersection between the fixed lines. (We begin and end \
in this way because, under the convention used throughout this notebook, the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vectors are multiples of \[Pi]/",
 StyleBox["n",
  FontSlant->"Italic"],
 " by ",
 StyleBox["i",
  FontSlant->"Italic"],
 ", ",
 StyleBox["i",
  FontSlant->"Italic"],
 "=1, 2, 3, ..., ",
 StyleBox["n",
  FontSlant->"Italic"],
 ". Hence when ",
 StyleBox["i=n",
  FontSlant->"Italic"],
 " the unit vector is {-1,0}, and under the orientation of this vector, a \
positive distance points to negative ",
 StyleBox["x,",
  FontSlant->"Italic"],
 " a negative distance to positive ",
 StyleBox["x",
  FontSlant->"Italic"],
 "; hence we move from right to left).\n\nThat is, the ",
 StyleBox["n",
  FontSlant->"Italic"],
 " vector is always horizontal, and its line-set always vertical.",
 "\n\nBegin by evaluating the cell below; then evaluate the ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop below that. Double-click on an image to initiate the animation."
}], "Text"],

Cell["\<\
(*create the initial line arrangement*)
(*set n1, therefore, n*)
n1=5;
n=If[EvenQ[n1],n1/2,n1];
dist=If[EvenQ[n1],{-1,1},{1}];

lns=Flatten[Table[
sgn=If[EvenQ[i],1,-1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*dist[[j]] }]],
{i,n},{j, Length[dist]}],1];

(*find all points of intersection*)
pts=findpoints[ lns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[lns, radius], redpts}];

(*express the points of intersection as distances from the origin*)
ptdist=Chop[Union[ Map[ (#.lns[[1,{1,2}]])&, pts], SameTest->(#1 - #2 < .001 \
&)]]
Print[Length[ptdist],\" distances were found.\"];

(************)
(*just trying to keep line count to near 50*)
newdist=If[n*Length[ptdist]<50,
ptdist,(*the new distances*)
b=Length[ptdist];
c=Ceiling[50/n];
d=Floor[(b-c)/2];
ptdist[[ Range[d+1,d+c] ]]
];
(************)


newlns=Flatten[Table[
sgn=If[EvenQ[i],-1,1];
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], sgn*newdist[[j]] }]],
{i,n},{j, Length[newdist]}],1];
Print[\"There are \", Length[newlns],\" lines altogether\"];

(*find all new points of intersection*)
pts=findpoints[ newlns ];
Print[\"There are \", Length[pts],\" points of intersection\"];
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];
rad1=Max[Map[mag[#]&, pts]];
radius=rad1+(rad1/4);(*expand a little*)
(*display lines within suitable radius*)
Show[{drawLines[newlns, radius], redpts}];

(*Set up your own list of colors*)
colorlist1={
RGBColor[1,0,0],RGBColor[.3,.3,1],RGBColor[1,1,0],
RGBColor[0,0,1],RGBColor[1,.4,.4],RGBColor[.4,.4,.4],
RGBColor[.5,0,0],RGBColor[0,1,0]};

zaq=zonotile[newlns];
s=notextcolorSort[ zaq ];

colorlist=If[Length[s]<=Length[colorlist1], colorlist1, Table[
RGBColor[Random[Real,{0,1}],Random[Real,{0,1}],Random[Real,{0,1}]],
{Length[s]}]];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];

(*express the points of intersection as distances from the origin*)
inrad=mag[ newlns[[n,{1,2}]] ];
newptdist=Chop[Union[ Map[ (#.newlns[[n,{1,2}]]/inrad)&, pts], SameTest->(#1 \
- #2 < .001 &)]];
(*Print[Length[newptdist],\" distances were found.\"];*)
maxrange=Max[newptdist];
minrange=Min[newptdist];
r=maxrange-minrange;
t1=maxrange-First@newdist;
t2=minrange-Last@newdist;
span=Ceiling[t1-t2];
Print[\"The fixed-line intersections lie within \",span, \" units of distance\
\"];\
\>", "Input"],

Cell[TextData[{
 "We have a set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " (here, 5) vectors, and also a set of ",
 StyleBox["k",
  FontSlant->"Italic"],
 " (here, 5) distances, named here ",
 StyleBox["newdist",
  FontWeight->"Bold"],
 ". The ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th lines are moved by adding the number ",
 StyleBox["off",
  FontWeight->"Bold"],
 " to their distances; any one line {",
 StyleBox["a, b, c",
  FontSlant->"Italic"],
 "} becomes {",
 StyleBox["a, b, c + ",
  FontSlant->"Italic"],
 StyleBox["off",
  FontWeight->"Bold"],
 "}. We have already found how far the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th lines must be translated, and where to start and end so as to more than \
encompass all points of intersection among the fixed lines.\n\nA ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop effects the animation. The iterator is named ",
 StyleBox["off",
  FontWeight->"Bold"],
 " and runs, here, across the span of fixed-line intersections in steps of 1 \
This \[OpenCurlyDoubleQuote]step\[CloseCurlyDoubleQuote] may be decreased for \
a more gradual translation; try .25 or .5. The offsets are themselves offset \
by .1. This avoids a zero translation, which would allow all twenty-five \
lines to intersect symmetrically, and spawn a set of decagons. The line \
arrangement is paired with its zonotile; drag the topmost graphic out larger, \
select the entire set of graphics, and choose \[OpenCurlyDoubleQuote]Align \
Selected Graphics\[CloseCurlyDoubleQuote] in the ",
 StyleBox["Cell",
  FontWeight->"Bold"],
 " menu, to force them all to the larger size.\n\nAnother code cell, below in \
a gray box, sets up a list of one hundred random colors, useful, perhaps, if \
one sets ",
 StyleBox["n",
  FontSlant->"Italic"],
 " at all large, say, ",
 StyleBox["n",
  FontSlant->"Italic"],
 ">7. Re-evaluating this makes a brand new list of colors."
}], "Text"],

Cell["\<\
(*optional random colorlist of great length*)
colorlist=Table[
RGBColor[Random[Real,{0,1}],Random[Real,{0,1}],Random[Real,{0,1}]],
{100}];\
\>", "Input",
 CellFrame->True,
 Background->GrayLevel[0.833326]],

Cell[TextData[{
 "(*now keep n-1 line-sets fixed, and move the nth set across the others*)\n\
Do[\nnewlns2=Flatten[Table[\nsgn=If[EvenQ[i],-1,1];\n",
 StyleBox["offset=If[i<n,0,off]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], offset+sgn*newdist[[j]] }]],\n\
{i,n},{j, Length[newdist]}],1];\n\nzaq=zonotile[newlns2];\ns=notextcolorSort[ \
zaq ];\n\nxaq=Graphics[\n\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],\n\t\
GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}],\n\t\
AspectRatio->Automatic];\n\t\nqaq=Show[drawLines[newlns2,r],\n\t\
PlotRange->{{-r,r},{-r,r}},\n\tFrame->True,DisplayFunction->Identity];\n\t\n\
Show[GraphicsArray[{qaq,xaq}],\nBackground->GrayLevel[1],\n\
AspectRatio->Automatic],\n(*iterator named 'off'*)\n\
{off,(t2-.1),(t2-.1)+span, 1(*change this for smaller steps*)}];"
}], "Input"],

Cell[TextData[{
 "Here we purposely use the line-distances found above, ",
 StyleBox["newptdist",
  FontWeight->"Bold"],
 ", as our offsets, picking up fixed-line intersections from right to left \
(as our generating vector is {-1,0})."
}], "Text"],

Cell[TextData[{
 "(*now keep n-1 line-sets fixed, and move the nth set across the others*)\n\
Do[\nnewlns2=Flatten[Table[\nsgn=If[EvenQ[i],-1,1];\n",
 StyleBox["offset=If[i<n, 0, newptdist[[k]]",
  FontColor->RGBColor[1, 0, 0]],
 "-First@newdist",
 StyleBox["]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], offset+sgn*newdist[[j]] }]],\n\
{i,n},{j, Length[newdist]}],1];\n\nzaq=zonotile[newlns2];\ns=notextcolorSort[ \
zaq ];\n\nxaq=Graphics[\n\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],\n\t\
GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}],\n\t\
AspectRatio->Automatic];\n\t\nqaq=Show[drawLines[newlns2,r],\n\t\
PlotRange->{{-r,r},{-r,r}},\n\tFrame->True,DisplayFunction->Identity];\n\t\n\
Show[GraphicsArray[{qaq,xaq}],\nBackground->GrayLevel[1],\n\
AspectRatio->Automatic],\n{k,Length[newptdist]}];"
}], "Input"],

Cell["\<\
Or we can try to offset interval by interval ... we\[CloseCurlyQuote]re back \
to kissing and missing points, and the two, combined. Here we try the missing \
points.\
\>", "Text"],

Cell["\<\
kissing=newptdist;

missing=Join[
{First@kissing - Random[Real, {.25,.5}]},
\tTable[
\t\ta=kissing[[k]];
\t\tb=kissing[[k+1]];
\t\ta + ((b-a)/2) + Random[Real, {-((b-a)/20),((b-a)/20)}],
\t{k,Length[kissing]-1}],
{Last@kissing + Random[Real, {.25,.5}]}
];

alldist=Sort[ Join[missing,kissing] ];\
\>", "Input"],

Cell[TextData[{
 "(*now keep n-1 line-sets fixed, and move the nth set across the others*)\n\
Do[\nnewlns2=Flatten[Table[\nsgn=If[EvenQ[i],-1,1];\n",
 StyleBox["offset=If[i<n, 0, missing[[k]]",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["+First@newdist",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], offset+sgn*newdist[[j]] }]],\n\
{i,n},{j, Length[newdist]}],1];\n\nzaq=zonotile[newlns2];\ns=notextcolorSort[ \
zaq ];\n\nxaq=Graphics[\n\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],\n\t\
GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}],\n\t\
AspectRatio->Automatic];\n\t\nqaq=Show[drawLines[newlns2,r],\n\t\
PlotRange->{{-r,r},{-r,r}},\n\tFrame->True,DisplayFunction->Identity];\n\t\n\
Show[GraphicsArray[{qaq,xaq}],\nBackground->GrayLevel[1],\n\
AspectRatio->Automatic],\n{k,Length[missing]}];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["One Line, Traversing a Stellation Complex", "Subsection"],

Cell[TextData[{
 "Here a set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines is created (",
 StyleBox["n",
  FontSlant->"Italic"],
 " odd)",
 ", ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1 remaining fixed, while the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th travels across, on missing-points."
}], "Text"],

Cell[TextData[{
 "(*create the initial line arrangement*)\n",
 StyleBox["(*n odd*)",
  FontColor->RGBColor[1, 0, 0]],
 "\n",
 StyleBox["n=15;",
  FontColor->RGBColor[1, 0, 0]],
 "\nlns=Table[\nsgn=If[EvenQ[i],1,-1];\nChop[N[ { Cos[i*Pi/n], Sin[i*Pi/n], \
sgn } ]],\n{i,n}];\n\n(*find all points of intersection*)\npts=findpoints[ \
lns ];\nPrint[\"There are \", Length[pts],\" points of intersection\"];\n\
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];\n\
rad1=Max[Map[mag[#]&, pts]];\nradius=rad1+(rad1/4);(*expand a little*)\n\
(*display lines within suitable radius*)\nShow[{drawLines[lns, radius], \
redpts},\nFrame->True];\n\n(*express the points of intersection as distances \
from the origin*)\nptdist=Chop[Union[ Map[ (#.lns[[n,{1,2}]])&, pts], \
SameTest->(#1 - #2 < .001 &)]]\nPrint[Length[ptdist],\" distances were found.\
\"];"
}], "Input"],

Cell[TextData[{
 "A ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop below makes the animation. Drag out the topmost graphic to the \
desired size, select all the graphics, and then in the ",
 StyleBox["Cell",
  FontWeight->"Bold"],
 " menu, choose ",
 StyleBox["Align Selected Graphics",
  FontWeight->"Bold"],
 "."
}], "Text"],

Cell[TextData[{
 "colorlist=Table[GrayLevel[1-i],{i,0,1,.1}];(*good up to n=20 or so*)\n\
newptdist=Join[ {First@ptdist-1}, ptdist, {Last@ptdist+1} ];\n\
miss=Table[((newptdist[[i+1]]-newptdist[[i]])/Random[Real,{1.999,2.001}])+\
newptdist[[i]], {i,Length[newptdist]-1}];\n\nr=radius+2;\n(*now keep n-1 \
line-sets fixed, and move the nth set across the others*)\nDo[\nlns=Table[\n\
sgn=If[EvenQ[i],1,-1];\n",
 StyleBox["offset=If[ i<n, sgn*1, miss[[k]] ]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], (offset) }]],\n{i,n}];\n\n\
zaq=zonotile[lns];\ns=notextcolorSort[ zaq ];\n\nxaq=Graphics[\n\tTable[ \
{colorlist[[i]],Polygon /@ s[[ i ]],\n\tGrayLevel[0],Map[Line /@ tosegs[#]&, \
s[[i]] ]}, {i,Length[s]}],\n\tBackground->RGBColor[0,0,.4],\n\t\
AspectRatio->Automatic];\n\t\nqaq=Show[drawLines[lns,radius],\n\t\
PlotRange->{{-r,r},{-r,r}},\n\tBackground->RGBColor[1,.7,.7],\n\t\
Frame->True,DisplayFunction->Identity];\n\t\nShow[GraphicsArray[{qaq,xaq}],\n\
Background->RGBColor[0,0,.6],\nAspectRatio->Automatic],\n{k,Length[miss]}];"
}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["One Line, Walking, Again", "Subsection"],

Cell[TextData[{
 "Here a set of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " lines is created, ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-1 remaining fixed, while the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th travels across, on missing-points. The only difference to the example \
above is that all distances (except the ",
 StyleBox["n",
  FontSlant->"Italic"],
 "th) are 1."
}], "Text"],

Cell[TextData[{
 "(*create the initial line arrangement*)\n",
 StyleBox["n=12;",
  FontColor->RGBColor[1, 0, 0]],
 "\nlns=Table[\nChop[N[ { Cos[i*Pi/n], Sin[i*Pi/n], 1 } ]],\n{i,n}];\n\n\
(*find all points of intersection*)\npts=findpoints[ lns ];\nPrint[\"There \
are \", Length[pts],\" points of intersection\"];\n\
redpts=Graphics[{AbsolutePointSize[5],RGBColor[1,0,0], Point /@ pts}];\n\
rad1=Max[Map[mag[#]&, pts]];\nradius=rad1+(rad1/4);(*expand a little*)\n\
r=rad1+2;\n(*display lines within suitable radius*)\nShow[{drawLines[lns, \
radius], redpts},\nPlotRange->{{-r,r},{-r,r}},\nFrame->True];\n\n(*express \
the points of intersection as distances from the origin*)\nptdist=Chop[Union[ \
Map[ (#.lns[[n,{1,2}]])&, pts], SameTest->(#1 - #2 < .001 &)]]\n\
Print[Length[ptdist],\" distances were found.\"];"
}], "Input"],

Cell[TextData[{
 "A ",
 StyleBox["Do",
  FontWeight->"Bold"],
 " loop below makes the animation. Drag out the topmost graphic to the \
desired size, select all the graphics, and then in the ",
 StyleBox["Cell",
  FontWeight->"Bold"],
 " menu, choose ",
 StyleBox["Align Selected Graphics",
  FontWeight->"Bold"],
 "."
}], "Text"],

Cell[TextData[{
 "colorlist=Table[GrayLevel[1-i],{i,0,1,.1}];(*good up to n=20 or so*)\n\
newptdist=Join[ {First@ptdist-1}, ptdist, {Last@ptdist+1} ];\n\
miss=Table[((newptdist[[i+1]]-newptdist[[i]])/Random[Real,{1.999,2.001}])+\
newptdist[[i]], {i,Length[newptdist]-1}];\n\n(*now keep n-1 line-sets fixed, \
and move the nth set across the others*)\nDo[\nlns=Table[\n",
 StyleBox["offset=If[ i<n, 1, miss[[k]] ]",
  FontColor->RGBColor[1, 0, 0]],
 ";\nChop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], (offset) }]],\n{i,n}];\n\n\
zaq=zonotile[lns];\ns=notextcolorSort[ zaq ];\n\nxaq=Graphics[\n\tTable[ \
{colorlist[[ i ]],Polygon /@ s[[ i ]],\n\tGrayLevel[0],Map[Line /@ \
tosegs[#]&, s[[i]] ]}, {i,Length[s]}],\n\tBackground->RGBColor[0,0,.3],\n\t\
AspectRatio->Automatic];\n\t\nqaq=Show[{drawLines[lns,radius],\nGraphics[\n\t\
{AbsoluteThickness[2],RGBColor[1,0,0],Last@drawLines[lns,radius][[1]]}\n]},\n\
\tPlotRange->{{-r,r},{-r,r}},\n\tBackground->RGBColor[.8,.8,1],\n\t\
AspectRatio->Automatic,\n\tFrame->True,DisplayFunction->Identity];\n\t\n\
Show[GraphicsArray[{qaq,xaq}],\nBackground->RGBColor[0,0,.6],\n\
AspectRatio->Automatic],\n{k,Length[miss]-1}];"
}], "Input"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Post-Processing: Colors, Grouted Tilings, etc.", "Section"],

Cell[CellGroupData[{

Cell["Some Coloring Methods", "Subsection"],

Cell["\<\
First, create a sample zonotile and sort its zonogons by area ...\
\>", "Text"],

Cell["\<\
n=6;
a=2;
dist=Table[
\tIf[EvenQ[i],f=1,f=N[Sqrt[3]]];
\tN[f*Range[-a,a,.5]],
\t{i,n}];
lns=Flatten[Table[
Chop[N[
{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[i,j]] }
]],
{i,n}, {j, Length[dist[[1]]]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*draw the lines within some suitable radius*)
Show[drawLines[lns, 10]];;

Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];
\
\>", "Input"],

Cell[TextData[{
 "Having created a zonotile and obtained the partition of its polygons into \
sets of equal area, the list ",
 StyleBox["s",
  FontSlant->"Italic"],
 ", it remains to devise a list of colors of the same length. Three methods \
are supplied, many more might be devised."
}], "Text"],

Cell[TextData[StyleBox["Random Coloring",
 FontSize->18,
 FontWeight->"Bold",
 FontSlant->"Italic"]], "Text"],

Cell["\<\
(*Make a list of random colors of the proper length.*)
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];

xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input",
 AspectRatioFixed->True],

Cell[TextData[StyleBox["Specified Coloring",
 FontSize->18,
 FontWeight->"Bold",
 FontSlant->"Italic"]], "Text"],

Cell["\<\
(*Set up your own list of colors*)
colorlist={
RGBColor[1,0,0],
RGBColor[0,0,1],
RGBColor[.7,.7,1],
RGBColor[1,1,0],
RGBColor[0,0,.5],
RGBColor[.3,.3,.3],
RGBColor[.5,0,0]};\
\>", "Input"],

Cell["\<\
If[Length[s]<=Length[colorlist],
xaq=Graphics[
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];,
Print[\"Not enough colors!\"]
]\
\>", "Input",
 AspectRatioFixed->True],

Cell[TextData[StyleBox["Randomized RGB Coloring",
 FontSize->18,
 FontWeight->"Bold",
 FontSlant->"Italic"]], "Text"],

Cell["\<\
z=Length /@ s;
xaq=Graphics[{GrayLevel[.25],
Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[.7],
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Discard Duplicate Edges", "Subsection"],

Cell[TextData[{
 "Sometimes it is useful to discard duplicate edges. A simple zonotile is \
created for the ",
 StyleBox["eUnion",
  FontWeight->"Bold"],
 " function."
}], "Text"],

Cell["\<\
n=3;
dist=Range[0,1];(*set to Range[-3,3] for hexagonal region*)
lns=Flatten[Table[
Chop[N[{ Cos[i*Pi/n], Sin[i*Pi/n], dist[[j]] }]],
{i,n},{j, Length[dist]}],1];
Print[\"There are \", Length[lns],\" lines altogether\"];

(*display lines within suitable radius*)
Show[drawLines[lns, 10]];

(*create and display*)
Share[zaq=zonotile[lns]];
s=colorSort[ zaq ];
Print[
\"There are \", a1=Map[Length[#]&, s],
\" polygons, \", Plus@@a1,\" altogether, of areas \",
a2=Map[hullarea[First[#]]&, s]
];
Print[\"The zonotile has total area of \",a1.a2,\", which is the sum of \",
MapThread[Times,{a1,a2}]];

z=Length /@ s;
xaq=Graphics[{Table[Table[
{RGBColor[ Sequence@@RotateLeft[{a=Random[Real,{0,.75}], 1, a},k] ],
\tPolygon[ s[[k,i]] ]},{i,z[[k]]}],
\t{k,Length[s]}],
\tTable[{GrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->GrayLevel[0],
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*Discard duplicate edges using eUnion function*)
len=Length[ zedges=Flatten[ Map[ tosegs[ # ]&, zaq],1] ];
Print[\"Before eUnion, there were \", len, \" edges.\"];
e1=eUnion[ zaq ];
Print[\"After eUnion, there are \", Length[e1], \" distinct edges.\"];
vaq=Graphics[{GrayLevel[0],Line/@e1}];
Show[vaq,
AspectRatio->Automatic];\
\>", "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Export to POV-Ray", "Subsection"],

Cell["\<\
The free raytracing program POV-Ray is available for all platforms, and \
offers photorealistic (or wildly unrealistic) renderings of three-dimensional \
scenes. Zonotile export to POV is implemented somewhat awkwardly here. A POV \
#include file is created, and for every vertex of the zonotile, a POV sphere \
is written; for every unique edge, a cylinder; and every polygon is split \
into triangles and combined in a POV mesh. Actually, a separate mesh object \
is created for each color-set of polygons, since in this notebook, zonotile \
polygons are always sorted by surface area and colored accordingly.

Various assumptions are made. First, that the zonotile has been assigned the \
global variable name \[OpenCurlyDoubleQuote]zaq,\[CloseCurlyDoubleQuote] and \
that its polygons have been sorted by surface area into the global variable \
name \[OpenCurlyDoubleQuote]s,\[CloseCurlyDoubleQuote] a list of lists.

First the unique vertices and edges are found.\
\>", "Text"],

Cell["\<\
(*Discarding duplicate edges is slow*)
Timing[ ve=vertedge[zaq] ][[1]]
Print[\"There are \", Length[ ve[[1]] ], \" distinct vertices in the tiling\"];
Print[\"There are \", Length[ ve[[2]] ], \" distinct edges in the tiling\"];
vaq=Graphics[{GrayLevel[0],Map[Line[#]&, ve[[2]] ]}];
Show[vaq,
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*make vertices 3D*)
verts=make3D[ve[[1]] ];

(*make edges 3D*)
sides=Map[ make3D[#]&, ve[[2]] ];

(*make tess polygons 3D*)
t=Chop[Table[Map[ make3D[#]&, s[[k]] ],{k,Length[s]}]];\
\>", "Input"],

Cell["Next a list of colors is made, randomly or manually  chosen.", "Text"],

Cell["\<\
(*assign random colors to polygons*)
colors=Table[{Random[Real,{0,1}],
\t\tRandom[Real,{0,1}],
\t\tRandom[Real,{0,1}]},{Length[s]}]\
\>", "Input",
 ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
(*manually make color list for polygons*)
colors={{1,1,0},{.5,0,0},{0,0,.75},{.5,.5,1}};\
\>", "Input"],

Cell["\<\
(*adopt existing color list*)
colors=colorlist;\
\>", "Input"],

Cell["Assign a directory for the POV #include file.", "Text"],

Cell["SetDirectory[\"Macintosh HD:Desktop Folder:POV zonotiles:\"]", "Input"],

Cell["Write the file.", "Text"],

Cell["TessToPOV[\"hexpenrose2.inc\",t,verts,sides]", "Input",
 ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
And here is a sample POV scene file to use as a point of beginning..\
\>", "Text"],

Cell["\<\
// Persistence of Vision Ray Tracer Scene Description File
// File: hexpenrose.pov
// Vers: 3.1
// Desc: 2D zonotile
// Date: 6/19/01
// Auth: Russell Towle
//

#version 3.1;

#include \"colors.inc\"
#include \"shapes.inc\"
#include \"textures.inc\"
#include \"metals.inc\"
#default { texture { pigment {color rgb <1,1,1>} finish {phong 0.1 ambient \
0.2 diffuse .6} }}


// ----------------------------------------
camera {
\tlocation <0, -5, 10>
\tdirection <0, 1, 0> //.75 wide angle
\tup <0, 0, 1>
\tright <4/3, 0, 0> //aspect ratio, w/h
\tsky <0., 0., 1.>
\tlook_at <0., 0., 0>
}

light_source {<20, 50, 30> color rgb <1, 1, 1>}

#declare T1 = texture{Gold_Metal}//spheres
#declare T2 = texture{T_Silver_3C}//cylinders
#include\"hexpenrose.inc\"

/*the faces, edges and vertices defined in the #include file*/
object{FACES}
object{VERTS scale<1, 1, 1>}
object{EDGES scale<1, 1, .25>}

/*a sky sphere with strange texture*/
sky_sphere {
\tpigment {
\t\tagate
\t\tcolor_map {
\t\t\t[ 0.0 rgb <0.2, 0.2, 1.000000> ]
\t\t\t[ 0.3 rgb <1.000000, 0.839979, 0.040024> ]
\t\t\t[ 1 rgb <.5, 0, .2> ]
\t\t}


\t}

}
\
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Grouted Tilings", "Subsection"],

Cell[TextData[{
 "A rather cumbersome function, ",
 StyleBox["grout",
  FontWeight->"Bold"],
 ", reduces the sizes of polygons in a tiling for uniform grout joints. The \
function is mapped across the list of polygons, with its second argument, the \
distance to shrink; this is half the width of the grout joint.\n\nNaturally, \
if this were actually used to lay out tiles for cutting and grouting, one \
would first scale the tiles suitably.\n\nThe function fails on \
non-equilateral zonotiles."
}], "Text"],

Cell["\<\
(*having created a zonotile, discard degenerate tiles*)
myzaq=Select[zaq, hullarea[#]>.00001&];

(*make space for grout*)
qaz=Map[grout[#, .15]&, myzaq];

(*sort into subsets according to area*)
s=colorSort[qaz];\
\>", "Input"],

Cell["\<\
(*find the convex hull of the shrunk tiles*)
gon=vunion[ Flatten[s,2] ];(*unique vertices*)
qaz=convexhull2D[gon];(*convex hull; slow*)
Show[Graphics[Polygon@qaz],(*test*)
AspectRatio->Automatic];\
\>", "Input"],

Cell["\<\
(*Make a list of random colors of the proper length.*)
colorlist=Table[
\tRGBColor[
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}],
\t  Random[Real,{0,1}]],
{Length[s]}];\
\>", "Input",
 AspectRatioFixed->True],

Cell["\<\
xaq=Graphics[
\t{GrayLevel[.25],Polygon@qaz,(*the grout polygon*)
\tTable[ {colorlist[[i]],Polygon /@ s[[ i ]],
\tGrayLevel[0],Map[Line /@ tosegs[#]&, s[[i]] ]}, {i,Length[s]}]}
\t];
Show[xaq,
Background->RGBColor[0.2, 0.2, 0.5],
AspectRatio->Automatic];\
\>", "Input",
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["Lofted Tilings", "Subsection"],

Cell[TextData[{
 "Here the grout function is adapted to accept a third argument, height, and \
truncated pyramids of the specified height are erected upon each zonogon. \
Since the grout function fails on non-equilateral zonotiles, so also will \
this function fail.\n\nWe create a 3D object, and use ",
 StyleBox["Graphic3D ",
  FontWeight->"Bold"],
 "to display it, somewhat obliquely."
}], "Text"],

Cell["\<\
(*having created a zonotile, discard degenerate tiles*)
myzaq=Select[zaq, hullarea[#]>.00001&];

(*apply lofting into 3D*)
uptile=Map[ loft[#, .2, .2]&, myzaq];\
\>", "Input"],

Cell[TextData[{
 "(*apply SurfaceColor specs to the polygon list*)\nxaq=Graphics3D[\n\
{EdgeForm[],SurfaceColor[RGBColor[1,.5,0],",
 StyleBox["GrayLevel[1], 5", "Input"],
 " ],\n\t\tuptile }];\n\n(*display*)\t\nShow[xaq,\nLightSources -> \n   {\n   \
{{-1,3,0}, RGBColor[.1, .1, 1]},\n   {{1,-1,2}, RGBColor[.75, .75, .75]}\n   \
},\nBoxed->False,\nAmbientLight->GrayLevel[.25],\nBackground->GrayLevel[0],\n\
ViewPoint->2.25*unit[ {0,-1, 2} ] ];"
}], "Input"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
},
AutoGeneratedPackage->None,
WindowSize->{698, 850},
WindowMargins->{{11, Automatic}, {Automatic, 9}},
SpellingDictionaries->{"CorrectWords"->{
 "zonotile", "zonogon", "zonogons", "zonotiles", "zonohedron", "zonohedra", 
  "zonohedral", "zonotopes", "zonotope", "tilings", "ipso", "facto", 
  "stellations", "stellation", "Zonotiles", "Kepler\[CloseCurlyQuote]s", 
  "quasicrystals", "Tilings", "matroids", "zonogonal", "Triacontahedron", 
  "enneacontahedron", "Triacontahedra", "triacontahedra", "Platonics", 
  "Zonotile", "triacontahedron", "spirallohedron", "Stellation", "Zonohedra", 
  "Archimedean", "eutactic", "Pentagrids", "pentagrids", "pentagrid", 
  "gridrange", "Bruijn"}},
Magnification->1,
FrontEndVersion->"11.0 for Microsoft Windows (64-bit) (2016\:5e748\:670817\
\:65e5)",
StyleDefinitions->Notebook[{
   Cell[
    CellGroupData[{
      Cell["Style Definitions", "Subtitle"], 
      Cell[
      "Modify the definitions below to change the default appearance of all \
cells in a given style.  Make modifications to any definition using commands \
in the Format menu.", "Text"], 
      Cell[
       CellGroupData[{
         Cell["Style Environment Names", "Section"], 
         Cell[
          StyleData[All, "Working"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{12, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 9], 
         Cell[
          StyleData[All, "Presentation"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{24, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 12], 
         Cell[
          StyleData[All, "Condensed"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{8, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 8], 
         Cell[
          StyleData[All, "Printout"], PageWidth -> PaperWidth, 
          CellLabelMargins -> {{2, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 5, 
          PrivateFontOptions -> {"FontType" -> "Outline"}]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Notebook Options", "Section"], 
         Cell[
         "The options defined for the style below will be used at the \
Notebook level.", "Text"], 
         Cell[
          StyleData["Notebook"], PageHeaders -> {{
             Cell[
              TextData[{
                CounterBox["Page"]}], "PageNumber"], None, 
             Cell[
              TextData[{
                ValueBox["FileName"]}], "Header"]}, {
             Cell[
              TextData[{
                ValueBox["FileName"]}], "Header"], None, 
             Cell[
              TextData[{
                CounterBox["Page"]}], "PageNumber"]}}, CellFrameLabelMargins -> 
          6, StyleMenuListing -> None]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Headings", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Title"], CellMargins -> {{12, Inherited}, {20, 40}}, 
             CellGroupingRules -> {"TitleGrouping", 0}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Title", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}, {"Subtitle", 0}, {"Subsubtitle", 0}}, FontFamily -> 
             "Helvetica", FontSize -> 36, FontWeight -> "Bold"], 
            Cell[
             StyleData["Title", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 40}}, LineSpacing -> {1, 0}, 
             FontSize -> 44], 
            Cell[
             StyleData["Title", "Condensed"], 
             CellMargins -> {{8, 10}, {4, 8}}, FontSize -> 20], 
            Cell[
             StyleData["Title", "Printout"], 
             CellMargins -> {{2, 10}, {12, 30}}, FontSize -> 24]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subtitle"], 
             CellMargins -> {{12, Inherited}, {20, 15}}, 
             CellGroupingRules -> {"TitleGrouping", 10}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subtitle", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}, {"Subsubtitle", 0}}, FontFamily -> "Helvetica", 
             FontSize -> 24], 
            Cell[
             StyleData["Subtitle", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 20}}, LineSpacing -> {1, 0}, 
             FontSize -> 36], 
            Cell[
             StyleData["Subtitle", "Condensed"], 
             CellMargins -> {{8, 10}, {4, 4}}, FontSize -> 14], 
            Cell[
             StyleData["Subtitle", "Printout"], 
             CellMargins -> {{2, 10}, {12, 8}}, FontSize -> 18]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsubtitle"], 
             CellMargins -> {{12, Inherited}, {20, 15}}, 
             CellGroupingRules -> {"TitleGrouping", 20}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsubtitle", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}}, FontFamily -> "Helvetica", FontSize -> 14, 
             FontSlant -> "Italic"], 
            Cell[
             StyleData["Subsubtitle", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 20}}, LineSpacing -> {1, 0}, 
             FontSize -> 24], 
            Cell[
             StyleData["Subsubtitle", "Condensed"], 
             CellMargins -> {{8, 10}, {8, 8}}, FontSize -> 12], 
            Cell[
             StyleData["Subsubtitle", "Printout"], 
             CellMargins -> {{2, 10}, {12, 8}}, FontSize -> 14]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Section"], CellFrame -> True, CellDingbat -> 
             "\[FilledSquare]", CellMargins -> {{25, Inherited}, {8, 24}}, 
             CellGroupingRules -> {"SectionGrouping", 30}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Section", 
             CounterAssignments -> {{"Subsection", 0}, {"Subsubsection", 0}}, 
             FontFamily -> "Helvetica", FontSize -> 16, FontWeight -> "Bold", 
             Background -> GrayLevel[0.833326]], 
            Cell[
             StyleData["Section", "Presentation"], CellFrame -> True, 
             CellMargins -> {{40, 10}, {11, 32}}, LineSpacing -> {1, 0}, 
             FontSize -> 24], 
            Cell[
             StyleData["Section", "Condensed"], CellFrame -> True, 
             CellMargins -> {{18, Inherited}, {6, 12}}, FontSize -> 12], 
            Cell[
             StyleData["Section", "Printout"], CellFrame -> True, 
             CellMargins -> {{13, 0}, {7, 22}}, FontSize -> 14]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsection"], CellDingbat -> "\[FilledSmallSquare]", 
             CellMargins -> {{22, Inherited}, {8, 20}}, 
             CellGroupingRules -> {"SectionGrouping", 40}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsection", CounterAssignments -> {{"Subsubsection", 0}}, 
             FontFamily -> "Times", FontSize -> 14, FontWeight -> "Bold"], 
            Cell[
             StyleData["Subsection", "Presentation"], 
             CellMargins -> {{36, 10}, {11, 32}}, LineSpacing -> {1, 0}, 
             FontSize -> 22], 
            Cell[
             StyleData["Subsection", "Condensed"], 
             CellMargins -> {{16, Inherited}, {6, 12}}, FontSize -> 12], 
            Cell[
             StyleData["Subsection", "Printout"], 
             CellMargins -> {{9, 0}, {7, 22}}, FontSize -> 12]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsubsection"], CellDingbat -> 
             "\[FilledSmallSquare]", 
             CellMargins -> {{22, Inherited}, {8, 18}}, 
             CellGroupingRules -> {"SectionGrouping", 50}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsubsection", FontFamily -> "Times", FontWeight -> "Bold"], 
            Cell[
             StyleData["Subsubsection", "Presentation"], 
             CellMargins -> {{34, 10}, {11, 26}}, LineSpacing -> {1, 0}, 
             FontSize -> 18], 
            Cell[
             StyleData["Subsubsection", "Condensed"], 
             CellMargins -> {{17, Inherited}, {6, 12}}, FontSize -> 10], 
            Cell[
             StyleData["Subsubsection", "Printout"], 
             CellMargins -> {{9, 0}, {7, 14}}, FontSize -> 11]}, Closed]]}, 
        Open]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Body Text", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Text"], CellMargins -> {{12, 10}, {7, 7}}, 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, Hyphenation -> 
             True, LineSpacing -> {1, 3}, CounterIncrements -> "Text", 
             FontSize -> 14], 
            Cell[
             StyleData["Text", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["Text", "Condensed"], CellMargins -> {{8, 10}, {6, 6}},
              LineSpacing -> {1, 1}, FontSize -> 11], 
            Cell[
             StyleData["Text", "Printout"], CellMargins -> {{2, 2}, {6, 6}}, 
             TextJustification -> 0.5, FontSize -> 10]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["SmallText"], CellMargins -> {{12, 10}, {6, 6}}, 
             DefaultNewInlineCellStyle -> "None", Hyphenation -> True, 
             LineSpacing -> {1, 3}, LanguageCategory -> "NaturalLanguage", 
             CounterIncrements -> "SmallText", FontFamily -> "Helvetica", 
             FontSize -> 9], 
            Cell[
             StyleData["SmallText", "Presentation"], 
             CellMargins -> {{24, 10}, {8, 8}}, LineSpacing -> {1, 5}, 
             FontSize -> 12], 
            Cell[
             StyleData["SmallText", "Condensed"], 
             CellMargins -> {{8, 10}, {5, 5}}, LineSpacing -> {1, 2}, 
             FontSize -> 9], 
            Cell[
             StyleData["SmallText", "Printout"], 
             CellMargins -> {{2, 2}, {5, 5}}, TextJustification -> 0.5, 
             FontSize -> 7]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Input/Output", "Section"], 
         Cell[
         "The cells in this section define styles used for input and output \
to the kernel.  Be careful when modifying, renaming, or removing these \
styles, because the front end associates special meanings with these style \
names. Some attributes for these styles are actually set in FormatType Styles \
(in the last section of this stylesheet). ", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Input"], CellMargins -> {{45, 10}, {5, 7}}, 
             Evaluatable -> True, CellGroupingRules -> "InputGrouping", 
             CellHorizontalScrolling -> True, PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, DefaultFormatType -> 
             DefaultInputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
             InputForm, ShowStringCharacters -> True, NumberMarks -> True, 
             LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> 
             "Input", FontWeight -> "Bold"], 
            Cell[
             StyleData["Input", "Presentation"], 
             CellMargins -> {{72, Inherited}, {8, 10}}, LineSpacing -> {1, 0},
              FontSize -> 16], 
            Cell[
             StyleData["Input", "Condensed"], 
             CellMargins -> {{40, 10}, {2, 3}}, FontSize -> 11], 
            Cell[
             StyleData["Input", "Printout"], CellMargins -> {{39, 0}, {4, 6}},
              LinebreakAdjustments -> {0.85, 2, 10, 1, 1}, FontSize -> 9]}, 
           Closed]], 
         Cell[
          StyleData["InputOnly"], Evaluatable -> True, CellGroupingRules -> 
          "InputGrouping", CellHorizontalScrolling -> True, DefaultFormatType -> 
          DefaultInputFormatType, 
          HyphenationOptions -> {"HyphenationCharacter" -> "\[Continuation]"},
           AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
          InputForm, ShowStringCharacters -> True, NumberMarks -> True, 
          LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> 
          "Input", StyleMenuListing -> None, FontWeight -> "Bold"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Output"], CellMargins -> {{47, 10}, {7, 5}}, 
             CellEditDuplicate -> True, CellGroupingRules -> "OutputGrouping",
              CellHorizontalScrolling -> True, PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, DefaultFormatType -> 
             DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
             InputForm, CounterIncrements -> "Output"], 
            Cell[
             StyleData["Output", "Presentation"], 
             CellMargins -> {{72, Inherited}, {10, 8}}, LineSpacing -> {1, 0},
              FontSize -> 16], 
            Cell[
             StyleData["Output", "Condensed"], 
             CellMargins -> {{41, Inherited}, {3, 2}}, FontSize -> 11], 
            Cell[
             StyleData["Output", "Printout"], 
             CellMargins -> {{39, 0}, {6, 4}}, FontSize -> 9]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Message"], 
             CellMargins -> {{45, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "OutputGrouping", PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, ShowCellLabel -> False, 
             DefaultFormatType -> DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, FormatType -> InputForm, 
             CounterIncrements -> "Message", StyleMenuListing -> None, 
             FontSize -> 11, FontColor -> RGBColor[0, 0, 1]], 
            Cell[
             StyleData["Message", "Presentation"], 
             CellMargins -> {{72, Inherited}, {Inherited, Inherited}}, 
             LineSpacing -> {1, 0}, FontSize -> 16], 
            Cell[
             StyleData["Message", "Condensed"], 
             CellMargins -> {{41, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 11], 
            Cell[
             StyleData["Message", "Printout"], 
             CellMargins -> {{39, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 7, FontColor -> GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Print"], 
             CellMargins -> {{45, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "OutputGrouping", CellHorizontalScrolling -> 
             True, PageBreakWithin -> False, GroupPageBreakWithin -> False, 
             GeneratedCell -> True, CellAutoOverwrite -> True, ShowCellLabel -> 
             False, DefaultFormatType -> DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, FormatType -> InputForm, 
             CounterIncrements -> "Print", StyleMenuListing -> None], 
            Cell[
             StyleData["Print", "Presentation"], 
             CellMargins -> {{72, Inherited}, {Inherited, Inherited}}, 
             LineSpacing -> {1, 0}, FontSize -> 16], 
            Cell[
             StyleData["Print", "Condensed"], 
             CellMargins -> {{41, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 11], 
            Cell[
             StyleData["Print", "Printout"], 
             CellMargins -> {{39, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 8]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Graphics"], 
             CellMargins -> {{4, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "GraphicsGrouping", CellHorizontalScrolling -> 
             True, PageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, ShowCellLabel -> False, 
             DefaultFormatType -> DefaultOutputFormatType, LanguageCategory -> 
             None, FormatType -> InputForm, CounterIncrements -> "Graphics", 
             ImageMargins -> {{43, Inherited}, {Inherited, 0}}, 
             StyleMenuListing -> None, FontFamily -> "Courier", FontSize -> 
             10], 
            Cell[
             StyleData["Graphics", "Presentation"], 
             ImageMargins -> {{62, Inherited}, {Inherited, 0}}], 
            Cell[
             StyleData["Graphics", "Condensed"], 
             ImageMargins -> {{38, Inherited}, {Inherited, 0}}, Magnification -> 
             0.6], 
            Cell[
             StyleData["Graphics", "Printout"], 
             ImageMargins -> {{30, Inherited}, {Inherited, 0}}, Magnification -> 
             0.8]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["CellLabel"], StyleMenuListing -> None, FontFamily -> 
             "Helvetica", FontSize -> 9, FontColor -> RGBColor[0, 0, 1]], 
            Cell[
             StyleData["CellLabel", "Presentation"], FontSize -> 12], 
            Cell[
             StyleData["CellLabel", "Condensed"], FontSize -> 9], 
            Cell[
             StyleData["CellLabel", "Printout"], FontFamily -> "Courier", 
             FontSize -> 8, FontSlant -> "Italic", FontColor -> 
             GrayLevel[0]]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Inline Formatting", "Section"], 
         Cell[
         "These styles are for modifying individual words or letters in a \
cell exclusive of the cell tag.", "Text"], 
         Cell[
          StyleData["RM"], StyleMenuListing -> None, FontWeight -> "Plain", 
          FontSlant -> "Plain"], 
         Cell[
          StyleData["BF"], StyleMenuListing -> None, FontWeight -> "Bold"], 
         Cell[
          StyleData["IT"], StyleMenuListing -> None, FontSlant -> "Italic"], 
         Cell[
          StyleData["TR"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["TI"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["TB"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["TBI"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          StyleData["MR"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["MO"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["MB"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["MBO"], StyleMenuListing -> None, FontFamily -> "Courier",
           FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          StyleData["SR"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["SO"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["SB"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["SBO"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["SO10"], StyleMenuListing -> None, FontFamily -> 
             "Helvetica", FontSize -> 10, FontWeight -> "Plain", FontSlant -> 
             "Italic"], 
            Cell[
             StyleData["SO10", "Printout"], StyleMenuListing -> None, 
             FontFamily -> "Helvetica", FontSize -> 7, FontWeight -> "Plain", 
             FontSlant -> "Italic"], 
            Cell[
             StyleData["SO10", "EnhancedPrintout"], StyleMenuListing -> None, 
             FontFamily -> "Futura", FontSize -> 7, FontWeight -> "Plain", 
             FontSlant -> "Italic"]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Formulas and Programming", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["InlineFormula"], CellMargins -> {{10, 4}, {0, 8}}, 
             CellHorizontalScrolling -> True, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, LanguageCategory -> 
             "Formula", ScriptLevel -> 1, SingleLetterItalics -> True], 
            Cell[
             StyleData["InlineFormula", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["InlineFormula", "Condensed"], 
             CellMargins -> {{8, 10}, {6, 6}}, LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["InlineFormula", "Printout"], 
             CellMargins -> {{2, 0}, {6, 6}}, FontSize -> 10]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["DisplayFormula"], 
             CellMargins -> {{42, Inherited}, {Inherited, Inherited}}, 
             CellHorizontalScrolling -> True, DefaultFormatType -> 
             DefaultInputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, LanguageCategory -> 
             "Formula", ScriptLevel -> 0, SingleLetterItalics -> True, 
             UnderoverscriptBoxOptions -> {LimitsPositioning -> True}], 
            Cell[
             StyleData["DisplayFormula", "Presentation"], 
             LineSpacing -> {1, 5}, FontSize -> 16], 
            Cell[
             StyleData["DisplayFormula", "Condensed"], LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["DisplayFormula", "Printout"], FontSize -> 10]}, 
           Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Program"], CellFrame -> {{0, 0}, {0.5, 0.5}}, 
             CellMargins -> {{10, 4}, {0, 8}}, CellHorizontalScrolling -> 
             True, Hyphenation -> False, LanguageCategory -> "Formula", 
             ScriptLevel -> 1, FontFamily -> "Courier"], 
            Cell[
             StyleData["Program", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["Program", "Condensed"], 
             CellMargins -> {{8, 10}, {6, 6}}, LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["Program", "Printout"], 
             CellMargins -> {{2, 0}, {6, 6}}, FontSize -> 9]}, Closed]]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["Hyperlink Styles", "Section"], 
         Cell[
         "The cells below define styles useful for making hypertext \
ButtonBoxes.  The \"Hyperlink\" style is for links within the same Notebook, \
or between Notebooks.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Hyperlink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`NotebookLocate[#2]}]& ), ButtonNote -> 
               ButtonData}], 
            Cell[
             StyleData["Hyperlink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["Hyperlink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["Hyperlink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
         "The following styles are for linking automatically to the on-line \
help system.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["MainBookLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["MainBook", #]}]& )}], 
            Cell[
             StyleData["MainBookLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["MainBookLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["MainBookLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["AddOnsLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, FontFamily -> "Courier", 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["AddOns", #]}]& )}], 
            Cell[
             StyleData["AddOnsLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["AddOnsLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["AddOnsLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["RefGuideLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, FontFamily -> "Courier", 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["RefGuide", #]}]& )}], 
            Cell[
             StyleData["RefGuideLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["RefGuideLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["RefGuideLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["GettingStartedLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["GettingStarted", #]}]& )}], 
            Cell[
             StyleData["GettingStartedLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["GettingStartedLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["GettingStartedLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["OtherInformationLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["OtherInformation", #]}]& )}], 
            Cell[
             StyleData["OtherInformationLink", "Presentation"], FontSize -> 
             16], 
            Cell[
             StyleData["OtherInformationLink", "Condensed"], FontSize -> 11], 
            
            Cell[
             StyleData["OtherInformationLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Headers and Footers", "Section"], 
         Cell[
          StyleData["Header"], CellMargins -> {{0, 0}, {4, 1}}, 
          DefaultNewInlineCellStyle -> "None", LanguageCategory -> 
          "NaturalLanguage", StyleMenuListing -> None, FontSize -> 10, 
          FontSlant -> "Italic"], 
         Cell[
          StyleData["Footer"], CellMargins -> {{0, 0}, {0, 4}}, 
          DefaultNewInlineCellStyle -> "None", LanguageCategory -> 
          "NaturalLanguage", StyleMenuListing -> None, FontSize -> 9, 
          FontSlant -> "Italic"], 
         Cell[
          StyleData["PageNumber"], CellMargins -> {{0, 0}, {4, 1}}, 
          StyleMenuListing -> None, FontFamily -> "Times", FontSize -> 10]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["Palette Styles", "Section"], 
         Cell[
         "The cells below define styles that define standard ButtonFunctions, \
for use in palette buttons.", "Text"], 
         Cell[
          StyleData["Paste"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, After]}]& )}], 
         Cell[
          StyleData["Evaluate"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               SelectionEvaluate[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["EvaluateCell"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionMove[
                FrontEnd`InputNotebook[], All, Cell, 1], 
               FrontEnd`SelectionEvaluateCreateCell[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["CopyEvaluate"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`SelectionCreateCell[
                FrontEnd`InputNotebook[], All], 
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionEvaluate[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["CopyEvaluateCell"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`SelectionCreateCell[
                FrontEnd`InputNotebook[], All], 
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionEvaluateCreateCell[
                FrontEnd`InputNotebook[], All]}]& )}]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Placeholder Styles", "Section"], 
         Cell[
         "The cells below define styles useful for making placeholder objects \
in palette templates.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Placeholder"], Placeholder -> True, StyleMenuListing -> 
             None, FontSlant -> "Italic", FontColor -> 
             RGBColor[0.890623, 0.864698, 0.384756], 
             TagBoxOptions -> {
              Editable -> False, Selectable -> False, StripWrapperBoxes -> 
               False}], 
            Cell[
             StyleData["Placeholder", "Presentation"]], 
            Cell[
             StyleData["Placeholder", "Condensed"]], 
            Cell[
             StyleData["Placeholder", "Printout"]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["PrimaryPlaceholder"], StyleMenuListing -> None, 
             DrawHighlighted -> True, FontSlant -> "Italic", Background -> 
             RGBColor[0.912505, 0.891798, 0.507774], 
             TagBoxOptions -> {
              Editable -> False, Selectable -> False, StripWrapperBoxes -> 
               False}], 
            Cell[
             StyleData["PrimaryPlaceholder", "Presentation"]], 
            Cell[
             StyleData["PrimaryPlaceholder", "Condensed"]], 
            Cell[
             StyleData["PrimaryPlaceholder", "Printout"]]}, Closed]]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["FormatType Styles", "Section"], 
         Cell[
         "The cells below define styles that are mixed in with the styles of \
most cells.  If a cell's FormatType matches the name of one of the styles \
defined below, then that style is applied between the cell's style and its \
own options. This is particularly true of Input and Output.", "Text"], 
         Cell[
          StyleData["CellExpression"], PageWidth -> Infinity, 
          CellMargins -> {{6, Inherited}, {Inherited, Inherited}}, 
          ShowCellLabel -> False, ShowSpecialCharacters -> False, 
          AllowInlineCells -> False, Hyphenation -> False, 
          AutoItalicWords -> {}, StyleMenuListing -> None, FontFamily -> 
          "Courier", FontSize -> 12, Background -> GrayLevel[1]], 
         Cell[
          StyleData["InputForm"], InputAutoReplacements -> {}, 
          AllowInlineCells -> False, Hyphenation -> False, StyleMenuListing -> 
          None, FontFamily -> "Courier"], 
         Cell[
          StyleData["OutputForm"], PageWidth -> Infinity, TextAlignment -> 
          Left, LineSpacing -> {0.6, 1}, StyleMenuListing -> None, FontFamily -> 
          "Courier"], 
         Cell[
          StyleData["StandardForm"], 
          InputAutoReplacements -> {
           "->" -> "\[Rule]", ":>" -> "\[RuleDelayed]", "<=" -> 
            "\[LessEqual]", ">=" -> "\[GreaterEqual]", "!=" -> "\[NotEqual]", 
            "==" -> "\[Equal]", Inherited}, LineSpacing -> {1.25, 0}, 
          StyleMenuListing -> None, FontFamily -> "Courier"], 
         Cell[
          StyleData["TraditionalForm"], 
          InputAutoReplacements -> {
           "->" -> "\[Rule]", ":>" -> "\[RuleDelayed]", "<=" -> 
            "\[LessEqual]", ">=" -> "\[GreaterEqual]", "!=" -> "\[NotEqual]", 
            "==" -> "\[Equal]", Inherited}, LineSpacing -> {1.25, 0}, 
          SingleLetterItalics -> True, TraditionalFunctionNotation -> True, 
          DelimiterMatching -> None, StyleMenuListing -> None], 
         Cell[
         "The style defined below is mixed in to any cell that is in an \
inline cell within another.", "Text"], 
         Cell[
          StyleData["InlineCell"], TextAlignment -> Left, ScriptLevel -> 1, 
          StyleMenuListing -> None], 
         Cell[
          StyleData["InlineCellEditing"], StyleMenuListing -> None, 
          Background -> RGBColor[1, 0.749996, 0.8]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Automatic Styles", "Section"], 
         Cell[
         "The cells below define styles that are used to affect the display \
of certain types of objects in typeset expressions.  For example, \
\"UnmatchedBracket\" style defines how unmatched bracket, curly bracket, and \
parenthesis characters are displayed (typically by coloring them to make them \
stand out).", "Text"], 
         Cell[
          StyleData["UnmatchedBracket"], StyleMenuListing -> None, FontColor -> 
          RGBColor[0.760006, 0.330007, 0.8]]}, Closed]]}, Open]]}, Visible -> 
  False, FrontEndVersion -> 
  "11.0 for Microsoft Windows (64-bit) (2016\:5e748\:670817\:65e5)", 
  StyleDefinitions -> "Default.nb"],
MacintoshSystemPageSetup -> \
"02P0005X0FP000003X<;V_oCom<?B`_78085:0?l0000005X0FP000003X<;VP5d\n\
038;VTRX04/00@41000007d000400@000000000000000000000000000040I0<0\n\
00000000000@8P404A002000000eDflP"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[580, 22, 34, 0, 103, "Title"],
Cell[617, 24, 169, 5, 119, "Subsubtitle"],
Cell[CellGroupData[{
Cell[811, 33, 78, 2, 67, "Section"],
Cell[892, 37, 2355, 58, 416, "Text"],
Cell[CellGroupData[{
Cell[3272, 99, 89, 2, 61, "Subsection"],
Cell[3364, 103, 4341, 89, 791, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[7742, 197, 101, 2, 61, "Subsection"],
Cell[7846, 201, 5070, 124, 847, "Text"],
Cell[12919, 327, 58, 4, 62, "Input"],
Cell[12980, 333, 242, 8, 31, "Text"],
Cell[13225, 343, 153, 4, 62, "Input"],
Cell[13381, 349, 8439, 189, 1569, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[21857, 543, 101, 2, 61, "Subsection"],
Cell[21961, 547, 429, 9, 69, "Text"],
Cell[CellGroupData[{
Cell[22415, 560, 84, 2, 57, "Subsubsection"],
Cell[22502, 564, 2265, 38, 505, "Text"],
Cell[24770, 604, 26, 0, 28, "Input"],
Cell[24799, 606, 1021, 20, 240, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[25857, 631, 98, 2, 57, "Subsubsection"],
Cell[25958, 635, 382, 8, 125, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[26377, 648, 94, 2, 57, "Subsubsection"],
Cell[26474, 652, 4495, 119, 854, "Text"],
Cell[30972, 773, 549, 21, 351, "Input"],
Cell[31524, 796, 1822, 42, 394, "Text"],
Cell[33349, 840, 525, 14, 232, "Input"],
Cell[33877, 856, 678, 25, 419, "Input"],
Cell[34558, 883, 1010, 25, 221, "Text"],
Cell[35571, 910, 569, 15, 249, "Input"],
Cell[36143, 927, 678, 25, 419, "Input"],
Cell[36824, 954, 3954, 105, 640, "Text"],
Cell[40781, 1061, 539, 16, 266, "Input"],
Cell[41323, 1079, 196, 4, 49, "Text"],
Cell[41522, 1085, 551, 19, 317, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[42110, 1109, 89, 2, 57, "Subsubsection"],
Cell[42202, 1113, 849, 22, 106, "Text"],
Cell[43054, 1137, 436, 13, 215, "Input"],
Cell[43493, 1152, 1572, 44, 240, "Text"],
Cell[45068, 1198, 354, 13, 215, "Input"],
Cell[45425, 1213, 3189, 85, 607, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[48651, 1303, 102, 2, 57, "Subsubsection"],
Cell[48756, 1307, 258, 11, 31, "Text"],
Cell[49017, 1320, 72, 0, 28, "Input"],
Cell[49092, 1322, 2408, 79, 266, "Text"],
Cell[51503, 1403, 63, 0, 28, "Input"],
Cell[51569, 1405, 283, 10, 164, "Input"],
Cell[51855, 1417, 1575, 58, 168, "Text"],
Cell[53433, 1477, 381, 16, 266, "Input"],
Cell[53817, 1495, 564, 16, 90, "Text"],
Cell[54384, 1513, 215, 8, 130, "Input"],
Cell[54602, 1523, 1378, 31, 244, "Text"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[56041, 1561, 85, 2, 67, "Section"],
Cell[56129, 1565, 144, 6, 61, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[56298, 1575, 87, 2, 61, "Subsection"],
Cell[56388, 1579, 331, 8, 95, "Input",
 InitializationCell->True],
Cell[56722, 1589, 151, 3, 44, "Input",
 InitializationCell->True],
Cell[56876, 1594, 427, 12, 135, "Input",
 InitializationCell->True],
Cell[57306, 1608, 455, 15, 214, "Input",
 InitializationCell->True],
Cell[57764, 1625, 293, 10, 129, "Input",
 InitializationCell->True],
Cell[58060, 1637, 147, 3, 44, "Input",
 InitializationCell->True],
Cell[58210, 1642, 550, 15, 197, "Input",
 InitializationCell->True],
Cell[58763, 1659, 452, 13, 163, "Input",
 InitializationCell->True],
Cell[59218, 1674, 334, 13, 180, "Input",
 InitializationCell->True],
Cell[59555, 1689, 302, 9, 112, "Input",
 InitializationCell->True],
Cell[59860, 1700, 177, 6, 61, "Input",
 InitializationCell->True],
Cell[60040, 1708, 428, 14, 197, "Input",
 InitializationCell->True],
Cell[60471, 1724, 840, 49, 792, "Input",
 InitializationCell->True],
Cell[61314, 1775, 363, 20, 299, "Input",
 InitializationCell->True],
Cell[61680, 1797, 362, 9, 112, "Input",
 InitializationCell->True],
Cell[62045, 1808, 964, 18, 418, "Input",
 InitializationCell->True],
Cell[63012, 1828, 670, 32, 503, "Input",
 InitializationCell->True],
Cell[63685, 1862, 1001, 37, 588, "Input",
 InitializationCell->True],
Cell[64689, 1901, 1017, 37, 588, "Input",
 InitializationCell->True],
Cell[65709, 1940, 755, 25, 367, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[66501, 1970, 89, 2, 61, "Subsection"],
Cell[66593, 1974, 331, 10, 129, "Input",
 InitializationCell->True],
Cell[66927, 1986, 660, 17, 248, "Input",
 InitializationCell->True],
Cell[67590, 2005, 996, 35, 503, "Input",
 InitializationCell->True],
Cell[68589, 2042, 973, 22, 333, "Input",
 InitializationCell->True],
Cell[69565, 2066, 3370, 52, 1982, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[72972, 2123, 100, 2, 61, "Subsection"],
Cell[73075, 2127, 213, 6, 61, "Input",
 InitializationCell->True],
Cell[73291, 2135, 355, 12, 163, "Input",
 InitializationCell->True],
Cell[73649, 2149, 344, 17, 248, "Input",
 InitializationCell->True],
Cell[73996, 2168, 178, 6, 61, "Input",
 InitializationCell->True],
Cell[74177, 2176, 535, 17, 248, "Input",
 InitializationCell->True],
Cell[74715, 2195, 750, 21, 248, "Input",
 InitializationCell->True],
Cell[75468, 2218, 457, 17, 248, "Input",
 InitializationCell->True],
Cell[75928, 2237, 376, 17, 248, "Input",
 InitializationCell->True],
Cell[76307, 2256, 477, 17, 248, "Input",
 InitializationCell->True],
Cell[76787, 2275, 409, 13, 180, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[77233, 2293, 89, 2, 61, "Subsection"],
Cell[77325, 2297, 322, 12, 163, "Input",
 InitializationCell->True],
Cell[77650, 2311, 316, 11, 146, "Input",
 InitializationCell->True],
Cell[77969, 2324, 1914, 60, 928, "Input",
 InitializationCell->True],
Cell[79886, 2386, 1045, 41, 656, "Input",
 InitializationCell->True],
Cell[80934, 2429, 988, 40, 639, "Input",
 InitializationCell->True],
Cell[81925, 2471, 901, 36, 571, "Input",
 InitializationCell->True],
Cell[82829, 2509, 393, 16, 231, "Input",
 InitializationCell->True],
Cell[83225, 2527, 462, 18, 265, "Input",
 InitializationCell->True],
Cell[83690, 2547, 2849, 54, 843, "Input",
 InitializationCell->True]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[86588, 2607, 79, 2, 67, "Section"],
Cell[CellGroupData[{
Cell[86692, 2613, 41, 0, 45, "Subsection"],
Cell[86736, 2615, 1004, 19, 183, "Text"],
Cell[CellGroupData[{
Cell[87765, 2638, 32, 0, 41, "Subsubsection"],
Cell[87800, 2640, 1151, 19, 657, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[88988, 2664, 58, 0, 41, "Subsubsection"],
Cell[89049, 2666, 247, 9, 51, "Text"],
Cell[89299, 2677, 1005, 17, 572, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[90341, 2699, 55, 0, 41, "Subsubsection"],
Cell[90399, 2701, 262, 5, 68, "Text"],
Cell[90664, 2708, 651, 15, 317, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[91352, 2728, 59, 0, 41, "Subsubsection"],
Cell[91414, 2730, 117, 3, 30, "Text"],
Cell[91534, 2735, 1061, 17, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[92632, 2757, 66, 0, 41, "Subsubsection"],
Cell[92701, 2759, 89, 2, 30, "Text"],
Cell[92793, 2763, 560, 14, 266, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[93390, 2782, 49, 0, 41, "Subsubsection"],
Cell[93442, 2784, 490, 11, 89, "Text"],
Cell[93935, 2797, 565, 14, 266, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[94537, 2816, 59, 0, 41, "Subsubsection"],
Cell[94599, 2818, 296, 5, 68, "Text"],
Cell[94898, 2825, 800, 13, 357, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[95747, 2844, 49, 0, 30, "Subsection"],
Cell[95799, 2846, 668, 12, 107, "Text"],
Cell[96470, 2860, 462, 16, 266, "Input"],
Cell[96935, 2878, 152, 3, 30, "Text"],
Cell[97090, 2883, 83, 3, 45, "Input"],
Cell[97176, 2888, 156, 3, 49, "Text"],
Cell[97335, 2893, 86, 3, 45, "Input"],
Cell[97424, 2898, 225, 4, 49, "Text"],
Cell[97652, 2904, 89, 3, 45, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[97790, 2913, 53, 0, 67, "Section"],
Cell[CellGroupData[{
Cell[97868, 2917, 34, 0, 45, "Subsection"],
Cell[97905, 2919, 7387, 148, 1385, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[105329, 3072, 58, 0, 45, "Subsection"],
Cell[105390, 3074, 4337, 109, 845, "Text"],
Cell[109730, 3185, 692, 14, 107, "Text"],
Cell[110425, 3201, 78, 1, 28, "Input"],
Cell[110506, 3204, 451, 13, 70, "Text"],
Cell[110960, 3219, 78, 1, 28, "Input"],
Cell[111041, 3222, 482, 9, 88, "Text"],
Cell[111526, 3233, 88, 1, 28, "Input"],
Cell[111617, 3236, 607, 13, 107, "Text"],
Cell[112227, 3251, 80, 1, 28, "Input"],
Cell[112310, 3254, 403, 11, 69, "Text"],
Cell[112716, 3267, 80, 1, 28, "Input"],
Cell[112799, 3270, 169, 3, 49, "Text"],
Cell[112971, 3275, 89, 1, 28, "Input"],
Cell[113063, 3278, 604, 11, 145, "Text"],
Cell[113670, 3291, 161, 7, 28, "Input"],
Cell[113834, 3300, 1188, 20, 222, "Text"],
Cell[115025, 3322, 161, 7, 28, "Input"],
Cell[115189, 3331, 906, 19, 166, "Text"],
Cell[116098, 3352, 181, 7, 27, "Input"],
Cell[116282, 3361, 483, 7, 90, "Text"],
Cell[116768, 3370, 182, 7, 27, "Input"],
Cell[116953, 3379, 141, 3, 33, "Text"],
Cell[117097, 3384, 103, 3, 42, "Input"],
Cell[117203, 3389, 762, 19, 111, "Text"],
Cell[117968, 3410, 333, 7, 96, "Input"],
Cell[118304, 3419, 706, 15, 201, "Text"],
Cell[119013, 3436, 123, 4, 45, "Input"],
Cell[119139, 3442, 194, 4, 49, "Text"],
Cell[119336, 3448, 330, 14, 232, "Input"],
Cell[119669, 3464, 153, 3, 49, "Text"],
Cell[119825, 3469, 333, 7, 96, "Input"],
Cell[120161, 3478, 1115, 24, 202, "Text"],
Cell[121279, 3504, 320, 7, 96, "Input"],
Cell[121602, 3513, 108, 3, 30, "Text"],
Cell[121713, 3518, 93, 3, 45, "Input"],
Cell[121809, 3523, 200, 4, 49, "Text"],
Cell[122012, 3529, 330, 14, 232, "Input"],
Cell[122345, 3545, 362, 6, 68, "Text"],
Cell[122710, 3553, 214, 6, 96, "Input"],
Cell[122927, 3561, 272, 5, 68, "Text"],
Cell[123202, 3568, 58, 0, 28, "Input"],
Cell[123263, 3570, 225, 4, 49, "Text"],
Cell[123491, 3576, 399, 9, 164, "Input"],
Cell[123893, 3587, 461, 7, 87, "Text"],
Cell[124357, 3596, 199, 7, 45, "Input"],
Cell[124559, 3605, 199, 7, 45, "Input"],
Cell[124761, 3614, 196, 7, 45, "Input"],
Cell[124960, 3623, 208, 7, 45, "Input"],
Cell[125171, 3632, 274, 6, 87, "Text"],
Cell[125448, 3640, 188, 7, 28, "Input"],
Cell[125639, 3649, 145, 3, 49, "Text"],
Cell[125787, 3654, 188, 7, 28, "Input"],
Cell[125978, 3663, 466, 9, 88, "Text"],
Cell[126447, 3674, 193, 7, 28, "Input"],
Cell[126643, 3683, 110, 3, 30, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[126790, 3691, 49, 0, 45, "Subsection"],
Cell[126842, 3693, 1302, 21, 201, "Text"],
Cell[128147, 3716, 57, 0, 28, "Input"],
Cell[128207, 3718, 57, 0, 28, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[128301, 3723, 74, 0, 45, "Subsection"],
Cell[128378, 3725, 62, 0, 28, "Input"],
Cell[128443, 3727, 335, 10, 50, "Text"],
Cell[128781, 3739, 115, 4, 62, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[128933, 3748, 42, 0, 45, "Subsection"],
Cell[128978, 3750, 1025, 27, 147, "Text"],
Cell[130006, 3779, 57, 0, 28, "Input"],
Cell[130066, 3781, 443, 9, 215, "Input"],
Cell[130512, 3792, 479, 13, 70, "Text"],
Cell[130994, 3807, 335, 13, 215, "Input"],
Cell[131332, 3822, 303, 5, 68, "Text"],
Cell[131638, 3829, 1586, 68, 1150, "Input"],
Cell[133227, 3899, 379, 8, 113, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[133643, 3912, 46, 0, 45, "Subsection"],
Cell[133692, 3914, 814, 24, 110, "Text"],
Cell[134509, 3940, 112, 3, 45, "Input"],
Cell[134624, 3945, 443, 9, 215, "Input"],
Cell[135070, 3956, 315, 7, 69, "Text"],
Cell[135388, 3965, 409, 9, 215, "Input"],
Cell[135800, 3976, 119, 3, 30, "Text"],
Cell[135922, 3981, 1419, 24, 844, "Input"],
Cell[137344, 4007, 76, 0, 30, "Text"],
Cell[137423, 4009, 430, 14, 232, "Input"],
Cell[137856, 4025, 113, 3, 30, "Text"],
Cell[137972, 4030, 508, 19, 317, "Input"],
Cell[138483, 4051, 71, 0, 30, "Text"],
Cell[138557, 4053, 75, 0, 28, "Input"],
Cell[138635, 4055, 76, 0, 30, "Text"],
Cell[138714, 4057, 164, 4, 62, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[138915, 4066, 35, 0, 45, "Subsection"],
Cell[138953, 4068, 286, 5, 49, "Text"],
Cell[139242, 4075, 807, 13, 504, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[140098, 4094, 54, 0, 67, "Section"],
Cell[CellGroupData[{
Cell[140177, 4098, 55, 0, 45, "Subsection"],
Cell[CellGroupData[{
Cell[140257, 4102, 32, 0, 41, "Subsubsection"],
Cell[140292, 4104, 220, 6, 49, "Text"],
Cell[140515, 4112, 882, 32, 538, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[141434, 4149, 41, 0, 41, "Subsubsection"],
Cell[141478, 4151, 612, 17, 87, "Text"],
Cell[142093, 4170, 925, 32, 538, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[143055, 4207, 58, 0, 41, "Subsubsection"],
Cell[143116, 4209, 410, 11, 68, "Text"],
Cell[143529, 4222, 944, 37, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[144510, 4264, 45, 0, 41, "Subsubsection"],
Cell[144558, 4266, 944, 37, 623, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[145551, 4309, 40, 0, 45, "Subsection"],
Cell[145594, 4311, 431, 13, 69, "Text"],
Cell[146028, 4326, 942, 36, 606, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[147007, 4367, 60, 0, 45, "Subsection"],
Cell[147070, 4369, 1048, 26, 145, "Text"],
Cell[148121, 4397, 26, 0, 28, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[148184, 4402, 51, 0, 45, "Subsection"],
Cell[148238, 4404, 1476, 32, 222, "Text"],
Cell[149717, 4438, 55, 4, 62, "Input"],
Cell[149775, 4444, 1697, 35, 258, "Text"],
Cell[151475, 4481, 110, 2, 40, "Text"],
Cell[151588, 4485, 974, 37, 623, "Input"],
Cell[152565, 4524, 129, 3, 40, "Text"],
Cell[152697, 4529, 1128, 39, 657, "Input"],
Cell[153828, 4570, 142, 3, 38, "Input"],
Cell[153973, 4575, 1132, 39, 657, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[155142, 4619, 115, 5, 46, "Subsection"],
Cell[155260, 4626, 376, 13, 49, "Text"],
Cell[155639, 4641, 292, 11, 181, "Input"],
Cell[155934, 4654, 110, 3, 30, "Text"],
Cell[156047, 4659, 638, 22, 368, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[156722, 4686, 70, 0, 45, "Subsection"],
Cell[156795, 4688, 449, 15, 68, "Text"],
Cell[157247, 4705, 305, 11, 181, "Input"],
Cell[157555, 4718, 110, 3, 30, "Text"],
Cell[157668, 4723, 638, 22, 368, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[158343, 4750, 36, 0, 45, "Subsection"],
Cell[158382, 4752, 603, 26, 68, "Text"],
Cell[158988, 4780, 1084, 38, 640, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[160109, 4823, 39, 0, 45, "Subsection"],
Cell[160151, 4825, 716, 33, 555, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[160904, 4863, 78, 1, 61, "Subsection"],
Cell[160985, 4866, 1479, 46, 164, "Text"],
Cell[162467, 4914, 449, 13, 215, "Input"],
Cell[162919, 4929, 652, 22, 368, "Input"],
Cell[163574, 4953, 412, 17, 266, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[164023, 4975, 78, 1, 61, "Subsection"],
Cell[164104, 4978, 902, 29, 107, "Text"],
Cell[165009, 5009, 427, 13, 215, "Input"],
Cell[165439, 5024, 652, 22, 368, "Input"],
Cell[166094, 5048, 412, 17, 266, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[166543, 5070, 72, 1, 61, "Subsection"],
Cell[166618, 5073, 120, 3, 30, "Text"],
Cell[166741, 5078, 577, 22, 368, "Input"],
Cell[167321, 5102, 349, 17, 283, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[167707, 5124, 62, 1, 61, "Subsection"],
Cell[167772, 5127, 152, 3, 49, "Text"],
Cell[167927, 5132, 917, 35, 589, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[168893, 5173, 39, 0, 67, "Section"],
Cell[168935, 5175, 108, 3, 30, "Text"],
Cell[CellGroupData[{
Cell[169068, 5182, 39, 0, 45, "Subsection"],
Cell[169110, 5184, 922, 34, 572, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[170069, 5223, 41, 0, 45, "Subsection"],
Cell[170113, 5225, 908, 35, 572, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[171058, 5265, 41, 0, 45, "Subsection"],
Cell[171102, 5267, 1128, 38, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[172267, 5310, 41, 0, 45, "Subsection"],
Cell[172311, 5312, 1133, 38, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[173481, 5355, 42, 0, 45, "Subsection"],
Cell[173526, 5357, 171, 5, 31, "Text"],
Cell[173700, 5364, 1060, 17, 657, "Input"],
Cell[174763, 5383, 64, 0, 30, "Text"],
Cell[174830, 5385, 332, 15, 249, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[175199, 5405, 42, 0, 45, "Subsection"],
Cell[175244, 5407, 1078, 38, 640, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[176359, 5450, 47, 0, 45, "Subsection"],
Cell[176409, 5452, 169, 3, 49, "Text"],
Cell[176581, 5457, 293, 11, 181, "Input"],
Cell[176877, 5470, 110, 3, 30, "Text"],
Cell[176990, 5475, 638, 22, 368, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[177665, 5502, 60, 0, 45, "Subsection"],
Cell[177728, 5504, 899, 42, 708, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[178664, 5551, 62, 0, 45, "Subsection"],
Cell[178729, 5553, 748, 30, 504, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[179526, 5589, 34, 0, 67, "Section"],
Cell[179563, 5591, 178, 8, 31, "Text"],
Cell[CellGroupData[{
Cell[179766, 5603, 69, 0, 45, "Subsection"],
Cell[179838, 5605, 2027, 60, 320, "Text"],
Cell[181868, 5667, 1895, 32, 1218, "Input"],
Cell[CellGroupData[{
Cell[183788, 5703, 46, 0, 41, "Subsubsection"],
Cell[183837, 5705, 361, 13, 51, "Text"],
Cell[184201, 5720, 1328, 23, 1031, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[185578, 5749, 48, 0, 45, "Subsection"],
Cell[185629, 5751, 2484, 66, 478, "Text"],
Cell[188116, 5819, 260, 11, 181, "Input"],
Cell[188379, 5832, 292, 9, 50, "Text"],
Cell[188674, 5843, 506, 9, 181, "Input"],
Cell[189183, 5854, 117, 3, 30, "Text"],
Cell[189303, 5859, 1051, 18, 725, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[190391, 5882, 54, 0, 45, "Subsection"],
Cell[190448, 5884, 613, 11, 108, "Text"],
Cell[191064, 5897, 1532, 74, 1252, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[192645, 5977, 35, 0, 67, "Section"],
Cell[CellGroupData[{
Cell[192705, 5981, 103, 1, 45, "Subsection"],
Cell[CellGroupData[{
Cell[192833, 5986, 35, 0, 41, "Subsubsection"],
Cell[192871, 5988, 4712, 98, 895, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[197620, 6091, 32, 0, 41, "Subsubsection"],
Cell[197655, 6093, 948, 36, 589, "Input"],
Cell[198606, 6131, 743, 32, 521, "Input"],
Cell[199352, 6165, 130, 3, 30, "Text"],
Cell[199485, 6170, 158, 6, 96, "Input"],
Cell[199646, 6178, 738, 29, 487, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[200421, 6212, 51, 0, 41, "Subsubsection"],
Cell[200475, 6214, 208, 6, 49, "Text"],
Cell[200686, 6222, 685, 20, 317, "Input"],
Cell[201374, 6244, 284, 7, 113, "Input"],
Cell[201661, 6253, 434, 18, 300, "Input"],
Cell[202098, 6273, 37, 0, 30, "Text"],
Cell[202138, 6275, 346, 10, 164, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[202521, 6290, 53, 0, 41, "Subsubsection"],
Cell[202577, 6292, 151, 5, 30, "Text"],
Cell[202731, 6299, 685, 20, 317, "Input"],
Cell[203419, 6321, 446, 12, 181, "Input"],
Cell[203868, 6335, 434, 18, 300, "Input"],
Cell[204305, 6355, 37, 0, 30, "Text"],
Cell[204345, 6357, 364, 10, 164, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[204746, 6372, 77, 0, 41, "Subsubsection"],
Cell[204826, 6374, 77, 1, 34, "Text"],
Cell[204906, 6377, 788, 21, 334, "Input"],
Cell[205697, 6400, 106, 2, 34, "Text"],
Cell[205806, 6404, 259, 9, 147, "Input"],
Cell[206068, 6415, 80, 1, 34, "Text"],
Cell[206151, 6418, 540, 16, 249, "Input"],
Cell[206694, 6436, 49, 1, 34, "Text"],
Cell[206746, 6439, 431, 18, 300, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[207226, 6463, 49, 0, 45, "Subsection"],
Cell[207278, 6465, 2829, 61, 505, "Text"],
Cell[210110, 6528, 324, 13, 215, "Input"],
Cell[210437, 6543, 99, 1, 34, "Text"],
Cell[210539, 6546, 1059, 37, 623, "Input"],
Cell[211601, 6585, 104, 1, 34, "Text"],
Cell[211708, 6588, 1077, 37, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[212822, 6630, 56, 0, 45, "Subsection"],
Cell[212881, 6632, 324, 13, 215, "Input"],
Cell[213208, 6647, 722, 26, 436, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[213967, 6678, 43, 0, 45, "Subsection"],
Cell[214013, 6680, 784, 15, 144, "Text"],
Cell[214800, 6697, 1809, 62, 1014, "Input"],
Cell[216612, 6761, 1271, 26, 259, "Text"],
Cell[217886, 6789, 1430, 23, 1048, "Input"],
Cell[219319, 6814, 769, 17, 128, "Text"],
Cell[220091, 6833, 715, 18, 300, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[220855, 6857, 39, 0, 67, "Section"],
Cell[220897, 6859, 524, 10, 163, "Text"],
Cell[CellGroupData[{
Cell[221446, 6873, 63, 0, 45, "Subsection"],
Cell[221512, 6875, 1402, 30, 239, "Text"],
Cell[222917, 6907, 1072, 46, 776, "Input"],
Cell[223992, 6955, 45, 0, 30, "Text"],
Cell[224040, 6957, 1224, 36, 538, "Input"],
Cell[225267, 6995, 66, 0, 30, "Text"],
Cell[225336, 6997, 289, 13, 215, "Input"],
Cell[225628, 7012, 97, 2, 30, "Text"],
Cell[225728, 7016, 1210, 38, 606, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[226975, 7059, 55, 0, 45, "Subsection"],
Cell[227033, 7061, 2010, 37, 432, "Text"],
Cell[CellGroupData[{
Cell[229068, 7102, 56, 0, 41, "Subsubsection"],
Cell[229127, 7104, 788, 23, 368, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[229952, 7132, 52, 0, 41, "Subsubsection"],
Cell[230007, 7134, 595, 15, 249, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[230639, 7154, 40, 0, 41, "Subsubsection"],
Cell[230682, 7156, 655, 22, 368, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[231386, 7184, 82, 1, 45, "Subsection"],
Cell[231471, 7187, 513, 8, 106, "Text"],
Cell[CellGroupData[{
Cell[232009, 7199, 56, 0, 41, "Subsubsection"],
Cell[232068, 7201, 826, 25, 402, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[232931, 7231, 52, 0, 41, "Subsubsection"],
Cell[232986, 7233, 171, 3, 49, "Text"],
Cell[233160, 7238, 622, 16, 266, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[233819, 7259, 40, 0, 41, "Subsubsection"],
Cell[233862, 7261, 655, 22, 368, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[234554, 7288, 109, 2, 41, "Subsubsection"],
Cell[234666, 7292, 684, 12, 126, "Text"],
Cell[235353, 7306, 544, 14, 198, "Input"],
Cell[235900, 7322, 655, 22, 368, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[236604, 7350, 37, 0, 45, "Subsection"],
Cell[236644, 7352, 1512, 26, 335, "Text"],
Cell[CellGroupData[{
Cell[238181, 7382, 56, 0, 41, "Subsubsection"],
Cell[238240, 7384, 823, 24, 402, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[239100, 7413, 79, 0, 41, "Subsubsection"],
Cell[239182, 7415, 211, 6, 50, "Text"],
Cell[239396, 7423, 331, 8, 113, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[239764, 7436, 51, 0, 41, "Subsubsection"],
Cell[239818, 7438, 655, 22, 368, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[240522, 7466, 56, 0, 45, "Subsection"],
Cell[240581, 7468, 527, 11, 163, "Text"],
Cell[CellGroupData[{
Cell[241133, 7483, 52, 0, 41, "Subsubsection"],
Cell[241188, 7485, 1477, 48, 810, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[242702, 7538, 59, 0, 41, "Subsubsection"],
Cell[242764, 7540, 945, 37, 623, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[243746, 7582, 53, 0, 41, "Subsubsection"],
Cell[243802, 7584, 756, 25, 419, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[244595, 7614, 43, 0, 41, "Subsubsection"],
Cell[244641, 7616, 865, 24, 147, "Text"],
Cell[245509, 7642, 1561, 32, 946, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[247119, 7680, 74, 0, 45, "Subsection"],
Cell[247196, 7682, 1054, 30, 164, "Text"],
Cell[248253, 7714, 1310, 49, 810, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[249600, 7768, 75, 0, 45, "Subsection"],
Cell[249678, 7770, 1684, 43, 297, "Text"],
Cell[251365, 7815, 2661, 87, 1439, "Input"],
Cell[254029, 7904, 1910, 53, 281, "Text"],
Cell[255942, 7959, 215, 7, 95, "Input"],
Cell[256160, 7968, 851, 14, 436, "Input"],
Cell[257014, 7984, 248, 6, 50, "Text"],
Cell[257265, 7992, 861, 16, 419, "Input"],
Cell[258129, 8010, 190, 4, 49, "Text"],
Cell[258322, 8016, 320, 14, 232, "Input"],
Cell[258645, 8032, 899, 17, 419, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[259581, 8054, 63, 0, 45, "Subsection"],
Cell[259647, 8056, 319, 15, 30, "Text"],
Cell[259969, 8073, 877, 17, 368, "Input"],
Cell[260849, 8092, 329, 12, 51, "Text"],
Cell[261181, 8106, 1080, 17, 572, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[262298, 8128, 46, 0, 45, "Subsection"],
Cell[262347, 8130, 395, 15, 49, "Text"],
Cell[262745, 8147, 828, 14, 368, "Input"],
Cell[263576, 8163, 329, 12, 51, "Text"],
Cell[263908, 8177, 1163, 18, 606, "Input"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[265120, 8201, 65, 0, 67, "Section"],
Cell[CellGroupData[{
Cell[265210, 8205, 43, 0, 45, "Subsection"],
Cell[265256, 8207, 89, 2, 30, "Text"],
Cell[265348, 8211, 638, 27, 453, "Input"],
Cell[265989, 8240, 297, 7, 49, "Text"],
Cell[266289, 8249, 109, 3, 35, "Text"],
Cell[266401, 8254, 412, 17, 266, "Input"],
Cell[266816, 8273, 112, 3, 35, "Text"],
Cell[266931, 8278, 198, 10, 164, "Input"],
Cell[267132, 8290, 306, 12, 181, "Input"],
Cell[267441, 8304, 117, 3, 35, "Text"],
Cell[267561, 8309, 345, 12, 198, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[267943, 8326, 45, 0, 45, "Subsection"],
Cell[267991, 8328, 179, 6, 31, "Text"],
Cell[268173, 8336, 925, 32, 538, "Input"],
Cell[269101, 8370, 352, 9, 147, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[269490, 8384, 39, 0, 45, "Subsection"],
Cell[269532, 8386, 992, 16, 220, "Text"],
Cell[270527, 8404, 341, 8, 130, "Input"],
Cell[270871, 8414, 205, 9, 147, "Input"],
Cell[271079, 8425, 76, 0, 30, "Text"],
Cell[271158, 8427, 188, 6, 79, "Input"],
Cell[271349, 8435, 113, 3, 45, "Input"],
Cell[271465, 8440, 72, 3, 45, "Input"],
Cell[271540, 8445, 61, 0, 30, "Text"],
Cell[271604, 8447, 77, 0, 28, "Input"],
Cell[271684, 8449, 31, 0, 30, "Text"],
Cell[271718, 8451, 93, 1, 28, "Input"],
Cell[271814, 8454, 92, 2, 30, "Text"],
Cell[271909, 8458, 1134, 55, 1018, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[273080, 8518, 37, 0, 45, "Subsection"],
Cell[273120, 8520, 510, 10, 164, "Text"],
Cell[273633, 8532, 237, 9, 147, "Input"],
Cell[273873, 8543, 221, 6, 96, "Input"],
Cell[274097, 8551, 220, 9, 130, "Input"],
Cell[274320, 8562, 304, 10, 147, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[274661, 8577, 36, 0, 45, "Subsection"],
Cell[274700, 8579, 400, 8, 107, "Text"],
Cell[275103, 8589, 185, 6, 96, "Input"],
Cell[275291, 8597, 459, 8, 283, "Input"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)

